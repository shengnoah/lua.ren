---
layout: post
title: 深入Lua  
tags: [lua文章]
categories: [topic]
---
<p>该篇文章将从Lua string的底层代码去分析字符串是如何创建、缓存、以及扩容的，深入分析了Lua字符串的整个工作原理。</p>
<h1 id="字符串结构定义"><a href="https://jygod.github.io/#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89" class="headerlink" title="字符串结构定义"></a>字符串结构定义</h1><p>Lua中字符串结构体定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Header for string value; string bytes follow the end of this structure</span></span><br><span class="line"><span class="comment">** (aligned according to 'UTString'; see next).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  {</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; "has hash" for longs */</span></span><br><span class="line">  lu_byte shrlen;  <span class="comment">/* length for short strings */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">union</span> {</span><br><span class="line">    <span class="keyword">size_t</span> lnglen;  <span class="comment">/* length for long strings */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  *<span class="title">hnext</span>;</span>  <span class="comment">/* linked list for hash table */</span></span><br><span class="line">  } u;</span><br><span class="line">} TString;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Ensures that address after this type is always fully aligned.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> UTString {</span><br><span class="line">  L_Umaxalign dummy;  <span class="comment">/* ensures maximum alignment for strings */</span></span><br><span class="line">  TString tsv;</span><br><span class="line">} UTString;</span><br></pre></td></tr></table></figure>

<h1 id="字符串缓存"><a href="https://jygod.github.io/#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%93%E5%AD%98" class="headerlink" title="字符串缓存"></a>字符串缓存</h1><p>在创建字符串时，首先会从global_State的strcache缓存中查找看是否存在:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2952813-44b34dcfd6c335f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strcache结构.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define STRCACHE_N		53</span></span><br><span class="line"><span class="comment">// #define STRCACHE_M		2</span></span><br><span class="line"></span><br><span class="line"><span class="function">TString *<span class="title">luaS_new</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>{</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = point2uint(str) % STRCACHE_N;  <span class="comment">/* hash */</span></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  TString **p = G(L)-&gt;strcache[i];</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; STRCACHE_M; j++) {</span><br><span class="line">    <span class="comment">// strcmp == 0，两个str相同</span></span><br><span class="line">    <span class="comment">// getstr --&gt; TString转string</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str, getstr(p[j])) == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> p[j]; <span class="comment">// 找到相同str</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (j = STRCACHE_M - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">    p[j] = p[j - <span class="number">1</span>]; <span class="comment">// 移动元素</span></span><br><span class="line">  <span class="comment">// 新元素会插入到list最前端</span></span><br><span class="line">  p[<span class="number">0</span>] = luaS_newlstr(L, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">  <span class="keyword">return</span> p[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>创建一个字符串的时候，首先会在strcache中查找，第7行根据str计算出该str在strcache的索引位置，在该strcache位置上又有一个大小为2( STRCACHE_M )的TString数组，若在这个数组中找到相同的字符串，则返回cache中字符串对应的TString；若未找到，会将p[0]位置的TString挪到p[1]位置，而p[0]位置存放<code>luaS_newlstr</code>新创建的TString。</p>
<h1 id="创建字符串"><a href="https://jygod.github.io/#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" class="headerlink" title="创建字符串"></a>创建字符串</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define LUAI_MAXSHORTLEN	40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** new string (with explicit length)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TString *<span class="title">luaS_newlstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= LUAI_MAXSHORTLEN)  <span class="comment">/* short string? */</span></span><br><span class="line">    <span class="keyword">return</span> internshrstr(L, str, l);</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    TString *ts;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= (MAX_SIZE - <span class="keyword">sizeof</span>(TString))/<span class="keyword">sizeof</span>(<span class="keyword">char</span>))</span><br><span class="line">      luaM_toobig(L);</span><br><span class="line">    ts = luaS_createlngstrobj(L, l);</span><br><span class="line">    <span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>新建一个TString时，会判断字符串长度是否大于40( LUAI_MAXSHORTLEN )，对于长度大于40的str，会直接创建TString并返回，而对于长度40以内的short string，会从global_State中的一个stringtable(strt)查找并记录:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** checks whether short string exists and reuses it or creates a new one</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TString *<span class="title">internshrstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>{</span><br><span class="line">  TString *ts;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">  TString **<span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];</span><br><span class="line">  lua_assert(str != <span class="literal">NULL</span>);  <span class="comment">/* otherwise 'memcmp'/'memcpy' are undefined */</span></span><br><span class="line">  <span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;u.hnext) {</span><br><span class="line">    <span class="keyword">if</span> (l == ts-&gt;shrlen &amp;&amp;</span><br><span class="line">        (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)) == <span class="number">0</span>)) {</span><br><span class="line">      <span class="comment">/* found! */</span></span><br><span class="line">      <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br><span class="line">        changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br><span class="line">      <span class="keyword">return</span> ts;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// list中如果没找到</span></span><br><span class="line">  <span class="comment">// resize 扩容</span></span><br><span class="line">  <span class="keyword">if</span> (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/<span class="number">2</span>) {</span><br><span class="line">    luaS_resize(L, g-&gt;strt.size * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];  <span class="comment">/* recompute with new size */</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 不需要扩容的情况</span></span><br><span class="line">  ts = createstrobj(L, l, LUA_TSHRSTR, h);</span><br><span class="line">  <span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  ts-&gt;shrlen = cast_byte(l);</span><br><span class="line">  ts-&gt;u.hnext = *<span class="built_in">list</span>;</span><br><span class="line">  *<span class="built_in">list</span> = ts;</span><br><span class="line">  g-&gt;strt.nuse++;</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>strt的数据结构类似于HashMap，它的初始化的数组长度为128，首先根据str计算得到的hash值(0~127),找到数组对应的下标索引，取出对应下标的list链表，10 ~ 18行是对该list进行遍历，若找到则直接返回；如未找到，则继续向下走。第21行， 如果 nuse(当前strt中TSring总数) 超过容量size(初始128)值，就会进行<code>luaS_resize</code>扩容操作(后续细讲)，strt的容量将扩为原来的2倍。如果不需要扩容，第26行开始，会创建一个新的TString，并将其插入到当前list的头部。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2952813-fefca9de2b7e2015.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strt结构.png"></p>
<h1 id="扩容"><a href="https://jygod.github.io/#%E6%89%A9%E5%AE%B9" class="headerlink" title="扩容"></a>扩容</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** resizes the string table</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaS_resize</span> <span class="params">(lua_State *L, <span class="keyword">int</span> newsize)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  stringtable *tb = &amp;G(L)-&gt;strt;</span><br><span class="line">  <span class="keyword">if</span> (newsize &gt; tb-&gt;size) {  <span class="comment">/* grow table if needed */</span></span><br><span class="line">    luaM_reallocvector(L, tb-&gt;hash, tb-&gt;size, newsize, TString *);</span><br><span class="line">    <span class="keyword">for</span> (i = tb-&gt;size; i &lt; newsize; i++)</span><br><span class="line">      tb-&gt;hash[i] = <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tb-&gt;size; i++) {  <span class="comment">/* rehash */</span></span><br><span class="line">    TString *p = tb-&gt;hash[i];</span><br><span class="line">    tb-&gt;hash[i] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) {  <span class="comment">// 遍历每一个节点</span></span><br><span class="line">      TString *hnext = p-&gt;u.hnext; </span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> h = lmod(p-&gt;hash, newsize); </span><br><span class="line">      p-&gt;u.hnext = tb-&gt;hash[h];</span><br><span class="line">      tb-&gt;hash[h] = p;</span><br><span class="line">      p = hnext;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (newsize &lt; tb-&gt;size) {  <span class="comment">/* shrink table if needed */</span></span><br><span class="line">    <span class="comment">/* vanishing slice should be empty */</span></span><br><span class="line">    lua_assert(tb-&gt;hash[newsize] == <span class="literal">NULL</span> &amp;&amp; tb-&gt;hash[tb-&gt;size - <span class="number">1</span>] == <span class="literal">NULL</span>);</span><br><span class="line">    luaM_reallocvector(L, tb-&gt;hash, tb-&gt;size, newsize, TString *);</span><br><span class="line">  }</span><br><span class="line">  tb-&gt;size = newsize;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>第7行，如果需要扩容，则调用<code>luaM_reallocvector</code>将 tb-&gt;hash 数组扩大到newsize (2倍)，12行~22行对每一个数组位置list链表中每一个TString节点的元素<strong>重新计算hash值</strong>，并将其插入到对应数组中的链表头部位置处。</p>