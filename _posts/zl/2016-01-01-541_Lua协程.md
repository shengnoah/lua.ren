---
layout: post
title: Lua协程 
tags: [lua文章]
categories: [topic]
---
<ul id="markdown-toc">
  <li><a href="#lua的协程" id="markdown-toc-lua的协程">Lua的协程</a></li>
</ul>

<h3 id="lua的协程">Lua的协程</h3>
<ul>
  <li>定义
    <ul>
      <li>两个子过程通过相互协作完成某个任务，用它可以实现协作式多任务，</li>
      <li>协程(coroutine)技术本质上是一种程序控制机制</li>
    </ul>
  </li>
  <li>分类
    <ul>
      <li>对称协程(asymmetric)
        <ul>
          <li>当前协程将控制权让给另外一个协程，协程之间的优先级是平等的</li>
        </ul>
      </li>
      <li>非对称协程(symmetric)
        <ul>
          <li>当前协程将控制权让给当前调用者</li>
          <li>lua采用此类协程</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>



<ul>
  <li>范例
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local co = coroutine.create( 
  function( first_param )
      local result = &#34;ok&#34;
      print( &#34;first_param = &#34;, first_param )
      local second_param = coroutine.yield( result )
      print( &#34;second_param = &#34;,second_param )
      return 1024
  end   
)
print( &#34;coroutine status = &#34;, coroutine.status(co) )
local i, j = coroutine.resume( co, 1 )
print( i, j )
print( &#34;coroutine status = &#34;, coroutine.status(co) )
i, j = coroutine.resume( co, 2 )
print( i, j )
print( &#34;coroutine status = &#34;, coroutine.status(co) )
</code></pre></div>    </div>
  </li>
  <li>输出结果
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>coroutine status =  suspended
first_param =   1
true    ok
coroutine status =  suspended
second_param =  2
true    1024
coroutine status =  dead
</code></pre></div>    </div>
  </li>
  <li>逻辑梳理
    <ul>
      <li>一个协程需要一个闭包（匿名函数）</li>
      <li>create后的协程状态为suspended</li>
      <li>第一次唤醒协程时候传递的参数将作为匿名函数的入参</li>
      <li>yield第一次交出控制权，yield的参数作为当前协程的输出传递出来</li>
      <li>第二次唤醒协程时候传递的参数，将通过yield的返回值作为协程的数据
        <ul>
          <li>在第一次调用了yield后，协程被挂起，类似阻塞</li>
          <li>第二次调用resume后，放开阻塞，继续执行yield，并将外部传入参数作为yield返回值</li>
        </ul>
      </li>
      <li>当闭包完成时，协程状态变为dead</li>
    </ul>
  </li>
  <li>应用场景
    <ul>
      <li>同步原语写异步逻辑
        <ul>
          <li>没有协程之前，异步逻辑采用的是函数回调，需要保留上下文</li>
          <li>编程思路会断断续续，需要在几个函数之间不停切换</li>
          <li>协程自动保存了上下文，且让逻辑更加连续
            <ul>
              <li>C++协程实现中，也是采用了系统函数进行上下文切换</li>
              <li>windows采用了CreateFiber、SwitchToFiber</li>
              <li>linux采用了makecontext、swapcontext</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>