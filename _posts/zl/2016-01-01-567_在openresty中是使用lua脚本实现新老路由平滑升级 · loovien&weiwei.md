---
layout: post
title: 在openresty中是使用lua脚本实现新老路由平滑升级 · loovien&weiwei 
tags: [lua文章]
categories: [topic]
---
<p>想升级PHP框架phalcon到3.x, 但是发现升级后与老版本基本不兼容, 也就意味着代码基本要重写了。考虑到不可能一下把所有的接口切换到新的框架上去（不能短时间内全部迁移所有的接口，新的框架提供的接口需要测试时间）。想到的方案是， 一方面提供新的接口使用新的框架编写，然后网关判断， 如果是新的接口就路由到新的框架部署的服务器上。空闲的时间，慢慢的把老的接口往新的框架上迁移。一下简单的实现了一个demo案列。</p>

<p><strong>环境以及依赖软件</strong></p>
<ul>
<li>window 10。</li>
<li>openresty/1.13.6.1 提供网关服务。</li>
<li>redis-server 提供新路由存储。</li>
<li>golang 模拟提供web服务。</li>
</ul>
<p>这里不对<a href="http://openresty.org" target="_blank" rel="noopener noreferrer">openresty</a>, <a href="https://golang.org/" target="_blank" rel="noopener noreferrer">golang</a>做介绍了。</p>
<p><strong>openresty配置</strong></p>
<p>编辑<code>nginx.conf</code>文件, 默认使用<code>phalcon1</code>upstream,当<code>rewrite_by_lua_file</code>执行完后, 如果是新的路由, 会重写<code>phalcon1</code>到<code>phalcon3</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/></pre></td><td class="code"><pre><span class="line">upstream phalcon1 {</span><br/><span class="line">    server 127.0.0.1:8088 fail_timeout=53 weight=4 max_fails=100;</span><br/><span class="line">}</span><br/><span class="line">upstream phalcon3 {</span><br/><span class="line">    server 127.0.0.1:8089 fail_timeout=53 weight=10 max_fails=100;</span><br/><span class="line">}</span><br/><span class="line">server {</span><br/><span class="line">    listen       80;</span><br/><span class="line">    server_name  localhost;</span><br/><span class="line">    #charset koi8-r;</span><br/><span class="line">    access_log  logs/host.access.log  main;</span><br/><span class="line">    error_page   500 502 503 504  /50x.html;</span><br/><span class="line">    location / {</span><br/><span class="line">        root   html;</span><br/><span class="line">        index  index.html index.htm;</span><br/><span class="line">    }</span><br/><span class="line">    location /api/user {</span><br/><span class="line">        default_type text/html;</span><br/><span class="line">        set $upstream &#34;phalcon1&#34;;</span><br/><span class="line">        # set_by_lua_file $upstream &#34;lualib/zq/chrbyuri.lua&#34;; # set_by_lua_file 关闭了 resty_redis API</span><br/><span class="line">        rewrite_by_lua_file &#34;lualib/zq/chrbyuri.lua&#34;;</span><br/><span class="line">        proxy_pass http://$upstream;</span><br/><span class="line">    }</span><br/><span class="line">    location = /50x.html {</span><br/><span class="line">        root   html;</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
<p><strong>chrbyuri.lua</strong></p>
<p>从redis中查找是否是新的路由, 新的话重写<code>phalcon1</code>到<code>phalcon3</code>, 这里有个小规则, 框架中有的路由是 <code>/api/user/{page}/{num}.json</code> 由于这些路由是动态, 不好固化存在redis中, 这列只做了简单的处理, 就是替换成 <code>{num}</code>, 比如请求路由: <code>/api/user/100/10/post.json</code> =&gt; <code>/api/user/{num}/{num}/post.json</code>, 对应的在redis存替换的key就好了。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> newupstream = <span class="string">&#34;phalcon3&#34;</span></span><br/><span class="line"><span class="keyword">local</span> redis_host = <span class="string">&#34;127.0.0.1&#34;</span></span><br/><span class="line"><span class="keyword">local</span> redis_port = <span class="number">6379</span></span><br/><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&#34;resty.redis&#34;</span></span><br/><span class="line"><span class="keyword">local</span> uri = ngx.var.uri</span><br/><span class="line"><span class="keyword">local</span> r = uri:<span class="built_in">gsub</span>(<span class="string">&#34;/%d+&#34;</span>, <span class="string">&#34;/{num}&#34;</span>)</span><br/><span class="line">ngx.<span class="built_in">log</span>(ngx.INFO, <span class="string">&#34;origin document_uri:&#34;</span>, uri)</span><br/><span class="line">ngx.<span class="built_in">log</span>(ngx.INFO, <span class="string">&#34;replace document_uri:&#34;</span>, r)</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> route_redis = redis:new()</span><br/><span class="line"><span class="keyword">local</span> ok, err = route_redis:connect(redis_host, redis_port)</span><br/><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br/><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&#34;connect to redis error&#34;</span>, err)</span><br/><span class="line">    <span class="keyword">return</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"><span class="comment">-- query document_uri is exists or not</span></span><br/><span class="line"><span class="keyword">local</span> newsrv, err = route_redis:get(r)</span><br/><span class="line"><span class="keyword">if</span> newsrv == ngx.null <span class="keyword">then</span></span><br/><span class="line">  ngx.<span class="built_in">log</span>(ngx.INFO, <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&#34;route %s is not new route&#34;</span>, r))</span><br/><span class="line">  <span class="keyword">return</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- override upstream</span></span><br/><span class="line">ngx.var.upstream = newupstream</span><br/></pre></td></tr></tbody></table></figure>
<p><strong>golang实现的web服务</strong></p>
<p>端口8088为老的接口服务器，提供 <code>/api/user/user.info1</code> <code>/api/user/user.info2</code> 2个接口。</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/></pre></td><td class="code"><pre><span class="line"># filename: phalcon1.<span class="keyword">go</span></span><br/><span class="line"><span class="keyword">package</span> main</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">import</span> (</span><br/><span class="line">	<span class="string">&#34;net/http&#34;</span></span><br/><span class="line">	<span class="string">&#34;log&#34;</span></span><br/><span class="line">)</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  {</span><br/><span class="line">	http.HandleFunc(<span class="string">&#34;/api/user/user.info1&#34;</span>, <span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> {</span><br/><span class="line">		rw.Write([]<span class="keyword">byte</span>(<span class="string">&#34;phalcon1:8088 handle route: {api/user/user.info2}&#34;</span>))</span><br/><span class="line">	})</span><br/><span class="line">	http.HandleFunc(<span class="string">&#34;/api/user/user.info2&#34;</span>, <span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> {</span><br/><span class="line">		rw.Write([]<span class="keyword">byte</span>(<span class="string">&#34;phalcon1:8088 handle route: {api/user/user.info2}&#34;</span>))</span><br/><span class="line">	})</span><br/><span class="line">	log.Fatalf(<span class="string">&#34;server exception: %+v n&#34;</span>, http.ListenAndServe(<span class="string">&#34;:8088&#34;</span>, <span class="literal">nil</span>))</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
<p>端口8089为新的接口服务器，提供 <code>/api/user/user.info3</code> 1个接口。</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br/><span class="line"># filename: phalcon3.<span class="keyword">go</span></span><br/><span class="line"><span class="keyword">import</span> (</span><br/><span class="line">	<span class="string">&#34;net/http&#34;</span></span><br/><span class="line">	<span class="string">&#34;log&#34;</span></span><br/><span class="line">)</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  {</span><br/><span class="line">	http.HandleFunc(<span class="string">&#34;/api/user/user.info3&#34;</span>, <span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> {</span><br/><span class="line">		rw.Write([]<span class="keyword">byte</span>(<span class="string">&#34;phalcon1:8089 handle route: {api/user/user.info2}&#34;</span>))</span><br/><span class="line">	})</span><br/><span class="line">	log.Fatalf(<span class="string">&#34;server exception: %+v n&#34;</span>, http.ListenAndServe(<span class="string">&#34;:8089&#34;</span>, <span class="literal">nil</span>))</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
<p><strong>测试</strong></p>
<ol>
<li>启动openresty <code>cd /path/to/openresty/nginx.exe</code>。</li>
<li>启动redis-server <code>cd /path/to/redis-server/redis-server -c /path/to/redis-server.conf</code>。</li>
<li>启动phalcon2 <code>go run phalcon3.go</code>。</li>
<li><p>启动phalcon1 <code>go run phalcon1.go</code>。</p>
</li>
<li><p>将新的路由写入到redis中 <code>redis-cli set /api/user/user.info3 1</code>。</p>
</li>
<li><p>访问 <code>http://localhost/api/user/user.info1</code>  <code>http://localhost/api/user/user.info2</code> 还是代理到了phalcon1上。</p>
</li>
<li>访问 <code>http://localhost/api/user/user.info3</code> 就代理到了phalcon3上了。</li>
</ol>
<p><strong>后续</strong></p>
<p>当有新的接口发布时候, 记得往redis写入新的路由标识即可了。</p>