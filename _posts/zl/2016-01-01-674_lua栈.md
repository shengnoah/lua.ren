---
layout: post
title: lua栈 
tags: [lua文章]
categories: [topic]
---
<p>既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构.</p>
<p>lua虚拟机在初始化创建lua_State结构体时,会走到stack_init函数中,这个函数主要就是对Lua栈和CallInfo数组的初始化:</p>
<pre><code>static void stack_init (lua_State *L1, lua_State *L) {
  /* initialize CallInfo array */
  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
  L1-&gt;ci = L1-&gt;base_ci;
  L1-&gt;size_ci = BASIC_CI_SIZE;
  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - 1;
  /* initialize stack array */
  L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TValue);
  L1-&gt;stacksize = BASIC_STACK_SIZE + EXTRA_STACK;
  L1-&gt;top = L1-&gt;stack;
  L1-&gt;stack_last = L1-&gt;stack+(L1-&gt;stacksize - EXTRA_STACK)-1;
  /* initialize first ci */
  L1-&gt;ci-&gt;func = L1-&gt;top;
  setnilvalue(L1-&gt;top++);  /* `function&#39; entry for this `ci&#39; */
  L1-&gt;base = L1-&gt;ci-&gt;base = L1-&gt;top;
  L1-&gt;ci-&gt;top = L1-&gt;top + LUA_MINSTACK;
}
</code></pre><p>可以看到的是,初始化了两个数组,分别保存Lua栈和CallInfo结构体数组.<br/>其中,与Lua栈相关的lua_State结构体成员变量有base,stack,top,lastfree,stack保存的是数组的初始位置,base会根据每次函数调用的情况发生变化,top指针指向的是当前第一个可用的栈位置,每次向栈中增加/删减元素都要对应的增减top指针,lastfee指针指向的书Lua栈的最后位置.</p>
<p>CallInfo结构体,是每次有函数调用时都会去初始化的一个结构体,它的成员变量中,也有top,base指针,同样的是指向Lua栈的位置,所不同的是,它关注的仅是函数调用时的相关位置.从代码中可以看出,CallInfo数组是有限制的,换言之,在Lua中的嵌套函数调用层次也是有限制,不能超过一定数量.<br/><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215144229849-16830691.png" alt=""/></p>
<p>首先看f_parser函数:</p>
<pre><code>static void f_parser (lua_State *L, void *ud) {
  int i;
  Proto *tf;
  Closure *cl;
  struct SParser *p = cast(struct SParser *, ud);
  int c = luaZ_lookahead(p-&gt;z);
  luaC_checkGC(L);
  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,
                                                             &amp;p-&gt;buff, p-&gt;name);
  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));
  cl-&gt;l.p = tf;
  for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */
    cl-&gt;l.upvals[i] = luaF_newupval(L);
  setclvalue(L, L-&gt;top, cl);
  incr_top(L);
}
</code></pre><p>f_parser函数的最后两句,将分析完毕之后的结构Closure指针压入了Lua栈.</p>
<p>再来看luaD_precall函数,这里为将代码放入Lua虚拟机中执行准备了相关数据,我们只截取其中的一部分来看:</p>
<pre><code>int luaD_precall (lua_State *L, StkId func, int nresults) {
  ….
  if (!cl-&gt;isC) {  /* Lua function? prepare its call */
    CallInfo *ci;
    StkId st, base;
    Proto *p = cl-&gt;p;

// 1) 根据函数的参数类型,计算出该CallInfo的base指针位置
    if (!p-&gt;is_vararg) {  /* no varargs? */
      base = func + 1;
      if (L-&gt;top &gt; base + p-&gt;numparams)
        L-&gt;top = base + p-&gt;numparams;
    }
    else {  /* vararg function */
      int nargs = cast_int(L-&gt;top - func) - 1;
      base = adjust_varargs(L, p, nargs);
      func = restorestack(L, funcr);  /* previous call may change the stack */
}

// 2) 分配一个新的CallInfo结构体,用于保存此次函数调用的相关信息:top,base指针,func函数
    ci = inc_ci(L);  /* now `enter&#39; new function */
    ci-&gt;func = func;
    L-&gt;base = ci-&gt;base = base;
    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;
    lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);

    // 3) LuaState的PC指针指向函数原型的代码数组
    L-&gt;savedpc = p-&gt;code;  /* starting point */
    // …..
    return PCRLUA;
  }
</code></pre><p>到这一步,跟某次具体的Lua代码执行相关的代码(保存在Proto的code数组中)和执行时所需环境(Lua栈),就已经准备完毕了.后面就是进入Lua虚拟机的主循环中解释执行代码了.</p>