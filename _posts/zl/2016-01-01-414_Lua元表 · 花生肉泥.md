---
layout: post
title: Lua元表 · 花生肉泥 
tags: [lua文章]
categories: [topic]
---
<h2 id="Metatable元表"><a href="#Metatable元表" class="headerlink" title="Metatable元表"></a>Metatable元表</h2><p>lua中的每个值都可以用一个metatable</p>
<p>两个table类型的变量，你是无法直接用 + 操作的，如果你定义了一个指定的函数，就可以进行了</p>
<p>setmetatable(table,metatable)：对指定table设置元表（metatable），如果元表中存在__metatable键值，setmetatable会失败</p>
<p>getmetatable(table)：返回对象的元表</p>
<h3 id="元表创建"><a href="#元表创建" class="headerlink" title="元表创建"></a>元表创建</h3><p>lua在创建新的table时不会创建元表<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = {<span class="number">1</span>,<span class="number">2</span>}</span><br/><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t))     </span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>使用getmetatable来获取一个table或userdata类型变量的元表，当创建新的table变量时，使用getmetatable去获得元表，将返回nil，同理，我们也可以使用setmetatable去设置一个table或者userdata类型变量的元表</p>
<p>lua代码中，只能设置table元表<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = {}</span><br/><span class="line"><span class="built_in">setmetatable</span>(t,t1)</span><br/><span class="line"><span class="built_in">assert</span>(<span class="built_in">getmetatable</span>(t) == t1)</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="string">&#34;hello world&#34;</span>))</span><br/><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(<span class="number">10</span>))</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line">=====结果=====</span><br/><span class="line"><span class="literal">nil</span></span><br/><span class="line"><span class="built_in">table</span>：<span class="number">0061</span>DE68</span><br/><span class="line"><span class="literal">nil</span></span><br/></pre></td></tr></tbody></table></figure><p></p>
<h3 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a>__index元方法</h3><p>当我们访问一个table中不存在的字段时，得到的结果是nil，但是这种状况很容易被改变，lua是按照以下步骤决定是返回nil还是其他的值:</p>
<p>当访问一个table字段时，如果table有这个字段，则直接返回对应值。</p>
<p>当table没有这个字段，则会促使解释器去查找一个叫__index的元方法，接下来就会调用对应的元方法，返回元方法的值。</p>
<p>如果没有这个元方法，那么返回nil结果<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/></pre></td><td class="code"><pre><span class="line">Windows = {}     <span class="comment">-- 创建一个命名空间</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 创建默认值表</span></span><br/><span class="line">Windows.default = {x=<span class="number">0</span>,y=<span class="number">0</span>,width=<span class="number">100</span>,height=<span class="number">100</span>,color={r=<span class="number">255</span>,g=<span class="number">255</span>,b=<span class="number">255</span>}}</span><br/><span class="line"></span><br/><span class="line">Windows.mt = {}     <span class="comment">-- 创建元表</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 声明构造函数</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(o)</span></span></span><br/><span class="line">     <span class="built_in">setmetatable</span>(o,Windows.mt)</span><br/><span class="line">     <span class="keyword">return</span> <span class="number">0</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 定义__index元方法</span></span><br/><span class="line">Windows.mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(table,key)</span></span></span><br/><span class="line">     <span class="keyword">return</span> Windows.default[key]</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> win = Windows.new({x=<span class="number">10</span>,y=<span class="number">10</span>})</span><br/><span class="line"><span class="built_in">print</span>(win.x)     <span class="comment">-- 10</span></span><br/><span class="line"><span class="built_in">print</span>(win.width)     <span class="comment">-- 100</span></span><br/><span class="line"><span class="built_in">print</span>(win.color.r)     <span class="comment">-- 255</span></span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>__index元方法不必一定是一个函数，他还可以是一个table</p>
<h3 id="newindex元方法"><a href="#newindex元方法" class="headerlink" title="__newindex元方法"></a>__newindex元方法</h3><p> <strong>newindex元方法与</strong>index类似，<strong>newindex用于更新table中的数据，而</strong>index用于查询table中的数据</p>
<p>lua解释器先判断这个table是否有元表</p>
<p>如果有元表，就查找元表中是否有__newindex元方法，如果没有元表，就直接添加这个索引，然后对应的赋值</p>
<p>如果有这个__newindex元方法，lua解释器就执行它，而不是执行赋值</p>
<p>如果这个__newindex对应的不是一个函数，而是一个table，lua解释器就在这个table中执行赋值么不是对原来的table<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tb1 = {}</span><br/><span class="line"><span class="keyword">local</span> tb2 = {}</span><br/><span class="line">tb1.<span class="built_in">__newindex</span> = tb2</span><br/><span class="line">tb2.<span class="built_in">__newindex</span> = tb1</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">setmetatable</span>(tb1,tb2)</span><br/><span class="line"><span class="built_in">setmetatable</span>(tb2,tb1)</span><br/><span class="line"></span><br/><span class="line">tb1.x  = <span class="number">10</span></span><br/></pre></td></tr></tbody></table></figure><p></p>