---
layout: post
title: lua c api  
tags: [lua文章]
categories: [topic]
---
   <h2 id="一-概述">一 概述</h2> <p>在 <code class="highlighter-rouge">C</code> 中使用 <code class="highlighter-rouge">API</code> 通过栈操作表或数组类型的数据，本篇使用示例来演示如果通过栈来操作表。</p> <h2 id="二-渠道秘钥更新">二 渠道秘钥更新</h2> <p><code class="highlighter-rouge">set_channel_key</code> 函数接收一个 <code class="highlighter-rouge">table</code> 作为参数，从 <code class="highlighter-rouge">table</code> 中获取 <code class="highlighter-rouge">channel_name</code> 的值作为 <code class="highlighter-rouge">key</code>，之后从动态库的全局渠道秘钥表中获取相应渠道的秘钥，并在 <code class="highlighter-rouge">table</code> 中添加或更新 <code class="highlighter-rouge">channel_key</code> 条目。</p> <h3 id="1-示例代码">1. 示例代码</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// gcc -fPIC -I/usr/local/lua5.1.5/include  -g -c private_cfg.c -Wall
// gcc -shared -I/usr/local/lua5.1.5/include  -L/usr/local/lua5.1.5/lib -llua -o private_cfg.so private_cfg.o
</span>
<span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
</span>
<span class="cp">#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">channel_key_s</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
<span class="p">}</span> <span class="n">channel_key</span><span class="p">;</span>


<span class="k">static</span> <span class="n">channel_key</span> 
<span class="n">g_channel_keys</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">"mobile"</span><span class="p">,</span> <span class="s">"mobile key"</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"pc"</span><span class="p">,</span> <span class="s">"pc key"</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*******************************************************************************
 * 从全局渠道秘钥表获取秘钥
 ******************************************************************************/</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">get_key</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">channel_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="n">channel_key</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">g_channel_keys</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">channel_name</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
 * do_set_channel_key 
 * 函数接收一个 table 作为参数，从 table 中获取 channel_name 的值作为 key，
 * 之后从全局渠道秘钥表中获取相应渠道的秘钥，并在 table 中添加 channel_key 条目。
 ******************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_set_channel_key</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 参数必须是 table
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lua_istable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">luaL_error</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"type error, should use table as param!"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 将 table 的 key `channel` 压入栈顶
</span>    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"channel_name"</span><span class="p">);</span>
    <span class="c1">// 从 table 中获取 channel 字段，并其放到栈顶
</span>    <span class="c1">// 注意：此时栈顶是 channel 值，栈顶第二个元素是 table。
</span>    <span class="c1">//      原先栈顶的 "channel" 字符串已经被使用并移出栈。
</span>    <span class="n">lua_gettable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lua_isstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">luaL_error</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"channel type error, should use string as param!"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 取出 channel 名
</span>    <span class="kt">char</span> <span class="o">*</span><span class="n">channel_name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// 将栈顶的 channel 值出栈，此时栈顶元素是 table
</span>    <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="kt">char</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">get_key</span><span class="p">(</span><span class="n">channel_name</span><span class="p">);</span>
    
    <span class="c1">// 在表中添加记录
</span>    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"channel_key"</span><span class="p">);</span>
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">lua_settable</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> 
<span class="k">struct</span> <span class="n">luaL_reg</span> <span class="n">private_cfg</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">"set_channel_key"</span><span class="p">,</span> <span class="n">do_set_channel_key</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/******************************************************************************
* 注册函数
******************************************************************************/</span>
<span class="kt">int</span> 
<span class="nf">luaopen_private_cfg</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">luaL_openlib</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="s">"private_cfg"</span><span class="p">,</span> <span class="n">private_cfg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="2-执行">2. 执行</h3> <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">requrie</span> <span class="s2">"private_cfg"</span>
<span class="n">tb</span> <span class="o">=</span> <span class="p">{</span><span class="n">channel_name</span> <span class="o">=</span> <span class="s1">'mobile'</span><span class="p">,</span> <span class="n">channel_key</span> <span class="o">=</span> <span class="s1">'no'</span><span class="p">}</span>
<span class="n">private_cfg</span><span class="p">.</span><span class="n">set_channel_key</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="s1">'channel_key'</span><span class="p">])</span> <span class="c1">--&gt; mobile key</span>
</code></pre></div></div> <h2 id="三-函数说明">三 函数说明</h2> <h3 id="1-访问表">1. 访问表</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">lua_gettable</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lua_rawget</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lua_rawgeti</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div></div> <p><code class="highlighter-rouge">lua_gettable</code> 将 <code class="highlighter-rouge">t[k]</code> 的值压入栈顶，表是由 <code class="highlighter-rouge">index</code> 索引确定的栈上元素，<code class="highlighter-rouge">k</code> 使用栈顶元素。<strong>函数会将栈顶的 <code class="highlighter-rouge">k</code> 元素 <code class="highlighter-rouge">pop</code> 出栈</strong>。</p> <p><code class="highlighter-rouge">lua_rawget</code> 与 <code class="highlighter-rouge">lua_gettable</code> 函数功能相似，只是 <code class="highlighter-rouge">lua_rawget</code> 不会使用表的元方法（<code class="highlighter-rouge">metamethods</code>）。</p> <p><code class="highlighter-rouge">lua_rawgeti</code> 将 <code class="highlighter-rouge">t[n]</code> 值压入栈，<code class="highlighter-rouge">t</code> 由 <code class="highlighter-rouge">index</code> 索引指定，<code class="highlighter-rouge">n</code> 为字面值，不会使用元方法。</p> <h3 id="2-更新表">2. 更新表</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">lua_settable</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lua_rawset</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">lua_rawseti</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div></div> <p><code class="highlighter-rouge">lua_settable</code> 与 <code class="highlighter-rouge">lua</code> 中的 <code class="highlighter-rouge">t[k] = v</code> 语义相同，表 <code class="highlighter-rouge">t</code> 是由 <code class="highlighter-rouge">index</code> 索引确定的栈上元素，<code class="highlighter-rouge">v</code> 是当前栈顶元素，<code class="highlighter-rouge">k</code> 是当前次栈顶元素。<strong>此函数会将栈顶、次栈顶元素 <code class="highlighter-rouge">pop</code> 出栈</strong>。</p> <p><code class="highlighter-rouge">lua_rawset</code> 与 <code class="highlighter-rouge">lua_settable</code> 函数功能相似，只是 <code class="highlighter-rouge">lua_rawset</code> 不会使用表的元方法（<code class="highlighter-rouge">metamethods</code>）。</p> <p><code class="highlighter-rouge">lua_rawseti</code> 与 <code class="highlighter-rouge">lua</code> 中的 <code class="highlighter-rouge">t[n] = v</code> 语义相同，表 <code class="highlighter-rouge">t</code> 是由 <code class="highlighter-rouge">index</code> 索引确定的栈上元素，<code class="highlighter-rouge">v</code> 是当前栈顶元素，<code class="highlighter-rouge">n</code> 为字面值，该函数不会使用元方法。</p> <h3 id="3-错误输出">3. 错误输出</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">luaL_error</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div></div> <p>触发错误，并输出 <code class="highlighter-rouge">fmt</code> 格式的错误信息，如果能获取文档名或行号会添加这些信息。</p> <h2 id="四-参考">四 参考</h2> <ul> <li><a href="https://www.lua.org/pil/25.1.html">programming in lua</a></li> <li><a href="https://www.lua.org/manual/5.1/manual.html">lua 5.1 c api 手册</a></li> </ul>