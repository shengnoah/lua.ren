---
layout: post
title: nginx_lua 扩展让 nginx 拥有可编程能力 
tags: [lua文章]
categories: [topic]
---
<p>公司使用 <a href="https://www.lighttpd.net" target="_blank" rel="external noopener noreferrer">lighttpd</a> 的比较多, 主要是接入层的一些工作，而且增加了一些很多自己的模块防火墙等等. 后来<br/>nginx开始流行起来因为 lighttpd 和 nginx整体是实现方式比较类似(个人感觉nginx 借鉴了 lighttpd的实现方式)，<br/>都使用了多进程异步非阻塞处理请求I/O和timer，对于静态文件服务使用sendfile系统调用.  作为静态文件server<br/>和接入层来说 lighttpd 已经足够的快，所以用lighttpd 和 nginx没太大区别.  简单来说nginx 相对于lighttpd 没有<br/>质的提高, 所以公司推广nginx 的动力不是太大.</p>
<p>nginx_lua 模块的推出使得 nginx 和 lighttpd 不在一个水平线上了. nginx_lua大大降低了nginx moudle开发的<br/>门槛，使用lua 语言可以替代以前使用c开发nginx moudle的很多场景. 可以很方便的给nginx 增加功能，这点lighttpd<br/>很难做到.</p>
<p>关于nginx_lua的介绍可以看看作者的一个演讲记录: <a href="http://blog-zq-org.qiniucdn.com/pyblosxom/2012/03/index.html#toc2R0lYQ0FUR" target="_blank" rel="external noopener noreferrer">由Lua 粘合的Nginx生态环境</a> ,本文主要介绍lua socket<br/>I/O特点。 根据nginx 工作方式的特点每Nginx工作进程使用一个Lua VM，工作进程内所有协程共享VM. 每一个<br/>外部请求都由一个新的Lua协程处理, 协程之间数据隔离. 当Lua代码调用I/O操作接口时，若该操作无法立刻完成<br/>(例如 recv 会引起阻塞)协程会保存当前状态, 由Nginx 继续处理其他请求,  相关数据I/O操作完成时resume相关协<br/>程并继续运行。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">location = /tcptest {</span><br/><span class="line">    content_by_lua &#39;</span><br/><span class="line">		local sock = ngx.socket.tcp()</span><br/><span class="line">		sock:settimeout(1000)   </span><br/><span class="line">		local ok, err = sock:connect(&#34;127.0.0.1&#34;, 11211)</span><br/><span class="line">		if not ok then</span><br/><span class="line">   			ngx.say(&#34;failed to connect: &#34;, err)</span><br/><span class="line">   			return</span><br/><span class="line">		end</span><br/><span class="line"></span><br/><span class="line">		local bytes, err = sock:send(&#34;flush_allrn&#34;)</span><br/><span class="line">		if not bytes then</span><br/><span class="line">    		ngx.say(&#34;failed to send query: &#34;, err)</span><br/><span class="line">    		return</span><br/><span class="line">		end</span><br/><span class="line"> </span><br/><span class="line">		local line, err = sock:receive()</span><br/><span class="line">		if not line then</span><br/><span class="line">    		ngx.say(&#34;failed to receive a line: &#34;, err)</span><br/><span class="line">    		return</span><br/><span class="line">		end</span><br/><span class="line"> </span><br/><span class="line">		ngx.say(&#34;result: &#34;, line)</span><br/><span class="line">    &#39;;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
<p>上述例子中的 socket:receive()要等待对方数据返回的, nginx_lua 模块适配了 nginx.socket I/O操作，<br/>nginx.socket的 I/O 操作都不会阻塞当前工作进程， nginx.socket 可以使用同步的方式实现异步I/O, 工作方式<br/>上面说了一些，下面简单来分析一下:<br/></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.  新的http请求执行到 lua 代码时会创建一个新的lua 协程</span><br/><span class="line"></span><br/><span class="line">2.  当该lua 协程调用sock:receive()等函数时, 会有nginx.socket 来接管 I/O操作，nginx.socket 会yield当前协程，</span><br/><span class="line"></span><br/><span class="line">     注册 I/O的回调到nginx事件循环中，继续Nginx的其他处理</span><br/><span class="line"></span><br/><span class="line">3.  当收到数据时，Nginx获得到该事件调用回调，唤醒之前的协程继续处理</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>我们拿最简单的ngx.sleep 流程看一下nginx 的内部处理, 下面lua 代码针对该请求sleep 1秒钟， 并返回结果<br/></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">location /sleep {</span><br/><span class="line">    content_by_lua_block {</span><br/><span class="line">        ngx.sleep(1)</span><br/><span class="line">        ngx.say(&#34;1s later..&#34;)</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>Nginx lua 实现：<br/></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><br/><span class="line"> * Copyright (C) Xiaozhe Wang (chaoslawful)</span><br/><span class="line"> * Copyright (C) Yichun Zhang (agentzh)</span><br/><span class="line"> */</span></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDEBUG 0</span></span><br/><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br/><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">&#34;ddebug.h&#34;</span></span></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">&#34;ngx_http_lua_util.h&#34;</span></span></span><br/><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">&#34;ngx_http_lua_sleep.h&#34;</span></span></span><br/><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">&#34;ngx_http_lua_contentby.h&#34;</span></span></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="params">(lua_State *L)</span></span>;</span><br/><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ngx_http_lua_sleep_handler</span><span class="params">(ngx_event_t *ev)</span></span>;</span><br/><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ngx_http_lua_sleep_cleanup</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br/><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_lua_sleep_resume</span><span class="params">(ngx_http_request_t *r)</span></span>;</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br/><span class="line"><span class="params">(lua_State *L)</span></span><br/><span class="line"></span>{</span><br/><span class="line">    <span class="keyword">int</span>                          n;</span><br/><span class="line">    <span class="keyword">ngx_int_t</span>                    delay; <span class="comment">/* in msec */</span></span><br/><span class="line">    <span class="keyword">ngx_http_request_t</span>          *r;</span><br/><span class="line">    <span class="keyword">ngx_http_lua_ctx_t</span>          *ctx;</span><br/><span class="line">    <span class="keyword">ngx_http_lua_co_ctx_t</span>       *coctx;</span><br/><span class="line"></span><br/><span class="line">    n = lua_gettop(L);</span><br/><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) {</span><br/><span class="line">        <span class="keyword">return</span> luaL_error(L, <span class="string">&#34;attempt to pass %d arguments, but accepted 1&#34;</span>, n);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    lua_pushlightuserdata(L, &amp;ngx_http_lua_request_key);</span><br/><span class="line">    lua_rawget(L, LUA_GLOBALSINDEX);</span><br/><span class="line">    r = lua_touserdata(L, <span class="number">-1</span>);</span><br/><span class="line">    lua_pop(L, <span class="number">1</span>);</span><br/><span class="line"></span><br/><span class="line">    delay = luaL_checknumber(L, <span class="number">1</span>) * <span class="number">1000</span>;</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>) {</span><br/><span class="line">        <span class="keyword">return</span> luaL_error(L, <span class="string">&#34;invalid sleep duration &#34;%d&#34;&#34;</span>, delay);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> (delay == <span class="number">0</span>) {</span><br/><span class="line">        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br/><span class="line">                       <span class="string">&#34;lua sleep for 0ms&#34;</span>);</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);</span><br/><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) {</span><br/><span class="line">        <span class="keyword">return</span> luaL_error(L, <span class="string">&#34;no request ctx found&#34;</span>);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    coctx = ctx-&gt;cur_co_ctx;</span><br/><span class="line">    <span class="keyword">if</span> (coctx == <span class="literal">NULL</span>) {</span><br/><span class="line">        <span class="keyword">return</span> luaL_error(L, <span class="string">&#34;no co ctx found&#34;</span>);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    coctx-&gt;data = r;</span><br/><span class="line">    <span class="comment">// 指定 timer超时的回调函数  </span></span><br/><span class="line">    coctx-&gt;sleep.handler = ngx_http_lua_sleep_handler;</span><br/><span class="line">    coctx-&gt;sleep.data = coctx;</span><br/><span class="line">    coctx-&gt;sleep.<span class="built_in">log</span> = r-&gt;connection-&gt;<span class="built_in">log</span>;</span><br/><span class="line"></span><br/><span class="line">    dd(<span class="string">&#34;adding timer with delay %lu ms, r:%.*s&#34;</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) delay,</span><br/><span class="line">       (<span class="keyword">int</span>) r-&gt;uri.len, r-&gt;uri.data);</span><br/><span class="line">    <span class="comment">// 将timer 回调event 加入到 nginx timer 管理中  </span></span><br/><span class="line">    ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br/><span class="line"></span><br/><span class="line">    coctx-&gt;cleanup = ngx_http_lua_sleep_cleanup;</span><br/><span class="line"></span><br/><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br/><span class="line">                   <span class="string">&#34;lua ready to sleep for %d ms&#34;</span>, delay);</span><br/><span class="line">    <span class="comment">// 保存当前协程上下文， 并返回到nginx主循环由nginx继续处理其他请求</span></span><br/><span class="line">    <span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">// timer expired 触发的回调  </span></span><br/><span class="line"><span class="function"><span class="keyword">void</span></span><br/><span class="line"><span class="title">ngx_http_lua_sleep_handler</span><span class="params">(ngx_event_t *ev)</span></span><br/><span class="line"></span>{</span><br/><span class="line">    <span class="keyword">ngx_connection_t</span>        *c;</span><br/><span class="line">    <span class="keyword">ngx_http_request_t</span>      *r;</span><br/><span class="line">    <span class="keyword">ngx_http_lua_ctx_t</span>      *ctx;</span><br/><span class="line">    <span class="keyword">ngx_http_log_ctx_t</span>      *log_ctx;</span><br/><span class="line">    <span class="keyword">ngx_http_lua_co_ctx_t</span>   *coctx;</span><br/><span class="line"></span><br/><span class="line">    coctx = ev-&gt;data;</span><br/><span class="line"></span><br/><span class="line">    r = coctx-&gt;data;</span><br/><span class="line">    c = r-&gt;connection;</span><br/><span class="line"></span><br/><span class="line">    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) {</span><br/><span class="line">        <span class="keyword">return</span>;</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    log_ctx = c-&gt;<span class="built_in">log</span>-&gt;data;</span><br/><span class="line">    log_ctx-&gt;current_request = r;</span><br/><span class="line"></span><br/><span class="line">    coctx-&gt;cleanup = <span class="literal">NULL</span>;</span><br/><span class="line"></span><br/><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br/><span class="line">                   <span class="string">&#34;lua sleep timer expired: &#34;%V?%V&#34;&#34;</span>, &amp;r-&gt;uri, &amp;r-&gt;args);</span><br/><span class="line"></span><br/><span class="line">    ctx-&gt;cur_co_ctx = coctx;</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> (ctx-&gt;entered_content_phase) {</span><br/><span class="line">    	<span class="comment">//恢复之前的 lua协程，继续处理  </span></span><br/><span class="line">        (<span class="keyword">void</span>) ngx_http_lua_sleep_resume(r);</span><br/><span class="line"></span><br/><span class="line">    } <span class="keyword">else</span> {</span><br/><span class="line">        ctx-&gt;resume_handler = ngx_http_lua_sleep_resume;</span><br/><span class="line">        ngx_http_core_run_phases(r);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    ngx_http_run_posted_requests(c);</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">void</span></span><br/><span class="line"><span class="title">ngx_http_lua_inject_sleep_api</span><span class="params">(lua_State *L)</span></span><br/><span class="line"></span>{</span><br/><span class="line">    lua_pushcfunction(L, ngx_http_lua_ngx_sleep);</span><br/><span class="line">    lua_setfield(L, <span class="number">-2</span>, <span class="string">&#34;sleep&#34;</span>);</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br/><span class="line"><span class="title">ngx_http_lua_sleep_cleanup</span><span class="params">(<span class="keyword">void</span> *data)</span></span><br/><span class="line"></span>{</span><br/><span class="line">    <span class="keyword">ngx_http_lua_co_ctx_t</span>          *coctx = data;</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> (coctx-&gt;sleep.timer_set) {</span><br/><span class="line">        dd(<span class="string">&#34;cleanup: deleting timer for ngx.sleep&#34;</span>);</span><br/><span class="line"></span><br/><span class="line">        ngx_del_timer(&amp;coctx-&gt;sleep);</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span><br/><span class="line"><span class="title">ngx_http_lua_sleep_resume</span><span class="params">(ngx_http_request_t *r)</span></span><br/><span class="line"></span>{</span><br/><span class="line">    <span class="keyword">ngx_connection_t</span>            *c;</span><br/><span class="line">    <span class="keyword">ngx_int_t</span>                    rc;</span><br/><span class="line">    <span class="keyword">ngx_http_lua_ctx_t</span>          *ctx;</span><br/><span class="line">    <span class="keyword">ngx_http_lua_main_conf_t</span>    *lmcf;</span><br/><span class="line"></span><br/><span class="line">    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);</span><br/><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) {</span><br/><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    ctx-&gt;resume_handler = ngx_http_lua_wev_handler;</span><br/><span class="line"></span><br/><span class="line">    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);</span><br/><span class="line"></span><br/><span class="line">    c = r-&gt;connection;</span><br/><span class="line"></span><br/><span class="line">    rc = ngx_http_lua_run_thread(lmcf-&gt;lua, r, ctx, <span class="number">0</span>);</span><br/><span class="line"></span><br/><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br/><span class="line">                   <span class="string">&#34;lua run thread returned %d&#34;</span>, rc);</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> (rc == NGX_AGAIN) {</span><br/><span class="line">        <span class="keyword">return</span> ngx_http_lua_run_posted_threads(c, lmcf-&gt;lua, r, ctx);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> (rc == NGX_DONE) {</span><br/><span class="line">        ngx_http_finalize_request(r, NGX_DONE);</span><br/><span class="line">        <span class="keyword">return</span> ngx_http_lua_run_posted_threads(c, lmcf-&gt;lua, r, ctx);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> (ctx-&gt;entered_content_phase) {</span><br/><span class="line">        ngx_http_finalize_request(r, rc);</span><br/><span class="line">        <span class="keyword">return</span> NGX_DONE;</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">return</span> rc;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>转载请注明出处，谢谢。。</p>