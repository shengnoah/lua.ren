---
layout: post
title: openresty通过lua增加随机traceid 
tags: [lua文章]
categories: [topic]
---
<p>在没有引入zipkin（或者阿里的鹰眼，百度的华佗）这种trace系统的时候，排查问题的一般思路都是按照请求链路来寻找问题源。因此如果能在请求链路中有一个唯一的标识就最好了，而在nginx/openresty做接入层的架构中，可以通过lua脚本生成一个随机traceid。</p><p>随机数的生成原理，都是先初始化一个随机数种子，由于伪随机数的特性，种子的随机性就显得格外重要，而一般种子的生成都是通过时间的倒序来选取</p><h4 id="lua-随机数生成方法">lua 随机数生成方法</h4><p>首先我们看下通常lua的随机数生成方法</p><div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">math.randomseed</span><span class="p">(</span><span class="nb">tonumber</span><span class="p">(</span><span class="nb">tostring</span><span class="p">(</span><span class="nb">os.time</span><span class="p">()):</span><span class="n">reverse</span><span class="p">():</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)))</span>
<span class="nb">math.random</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</code></pre></div></div><p>通过时间字符串的逆序初始化随机种子，这里注意到有个<code class="highlighter-rouge">sub</code>函数做了截断，是因为</p><blockquote><p><code class="highlighter-rouge">math.randomseed</code> will call the underlying C function <code class="highlighter-rouge">srand</code> which takes an unsigned integer valueLua will cast the value of the seed to this format. In case of an overflow the seed will actually become a bad seed, without warning</p></blockquote><p>所以需要避免出现高类型向低类型转换的溢出问题</p><h3 id="common-方法的问题">common 方法的问题</h3><p>但上面的方法有个问题，就是<code class="highlighter-rouge">os.time()</code>函数返回的是秒(10位整数), 所以在做web请求的traceid时很容易就出现重复，影响问题追踪的效率，而lua如果要以毫秒为单位的时间来初始化随机种子，需要引入socket等外部模块，对于openresty来说一般都是封装好的，不方便去做这种定制</p><h4 id="利用openresty-与lua生成traceid">利用openresty 与lua生成traceid</h4><p>幸运的是，nginx-lua中有个函数<code class="highlighter-rouge">ngx.now</code>会返回一个浮点数（当然在lua中统一为number类型），3位小数即为毫秒位，所以问题就变得简单了</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>access_by_lua_block <span class="o">{</span>
    math.randomseed<span class="o">(</span>tonumber<span class="o">(</span>tostring<span class="o">(</span>ngx.now<span class="o">()</span><span class="k">*</span>1000<span class="o">)</span>:reverse<span class="o">()</span>:sub<span class="o">(</span>1,9<span class="o">)))</span>
    <span class="nb">local </span>randvar <span class="o">=</span> string.format<span class="o">(</span><span class="s2">&#34;%.0f&#34;</span>,math.random<span class="o">(</span>1000000000000000000,9223372036854775807<span class="o">))</span>
    ngx.req.set_header<span class="o">(</span><span class="s2">&#34;traceid&#34;</span>, randvar<span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div><p>通过<code class="highlighter-rouge">ngx.now()*1000</code>拿到毫秒数据转换为字符串取反，这样毫秒数据的变化才能显出效果; unsigned int（64bit机器下为4byte) 最大值为10位数，我们取前9位避免数据溢出带来的转换问题; lua在显示大于64bit的数据时会自动用科学技术法表示，所以我们需要通过string.format函数来将其转换为19位数字，然后通过ngx.req.set_header添加到请求头中去</p><div class="post-links"> <a class="link-to-post" href="/ops/OPS-samba%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"> <span class="link-to-post__next">⤧  Next post</span> <span class="link-to-post__title">samba安装及配置说明</span> </a> <a class="link-to-post" href="/ops/OPS-ssh-%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"> <span class="link-to-post__prev">⤧  Previous post</span> <span class="link-to-post__title">[译]ssh免密登录失败问题排查思路</span> </a></div>