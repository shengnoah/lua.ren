---
layout: post
title: Lua + OpenResty修改response body 
tags: [lua文章]
categories: [topic]
---
<blockquote>
<p>最近公司前端框架组提了个需求，希望修改response中的一个css文件，去掉一个样式：max-width:1632px;。于是便想到了利用lua。</p>
</blockquote>
<h2 id="OpenResty-lua编程相关资料"><a href="#OpenResty-lua编程相关资料" class="headerlink" title="OpenResty lua编程相关资料"></a>OpenResty lua编程相关资料</h2><ul>
<li><a href="https://github.com/openresty/lua-nginx-module#name" target="_blank" rel="external noopener noreferrer">OpenResty Readme</a></li>
<li><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/lua/main.html" target="_blank" rel="external noopener noreferrer">OpenResty最佳实践
</a></li>
</ul>
<p>其中Readme要看完，是github上对OpenResty的lua-nginx-module比较全面的介绍。</p>
<h2 id="Nginx处理的几个阶段"><a href="#Nginx处理的几个阶段" class="headerlink" title="Nginx处理的几个阶段"></a>Nginx处理的几个阶段</h2><p>此处放上从网上找来的一幅图，<br/><img src="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/24.png" alt=""/><br/>我这里修改response body显然是需要用到body_filter_by_lua*指令。</p>
<h2 id="修改Response-Body"><a href="#修改Response-Body" class="headerlink" title="修改Response Body"></a>修改Response Body</h2><p>修改Response Body的方式总体来说有4种，分别是：</p>
<ul>
<li>1.使用 body_filter_by_lua<br/>指令来实现：<a href="http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua" target="_blank" rel="external noopener noreferrer">http://wiki.nginx.org/HttpLuaModule#body_filter_by_lua</a> 这个支持流式处理。 </li>
<li>2.使用 ngx.location.capture 发起子请求，然后对子请求的响应体进行全缓冲式修改</li>
<li><p>3.可以使用 <a href="https://github.com/agentzh/replace-filter-nginx-module" target="_blank" rel="external noopener noreferrer">ngx_replace_filter 模块</a>来进行流式正则替换<br/>替换成的目标值可以通过 ngx_lua 模块嵌入一小段 Lua 代码来事先计算好，放置在你自己定义的 nginx 变量中，然后在 replace_filter 指令中直接引用之。比如 </p>
<p>  set_by_lua $my_var ‘… return …’;<br/>  replace_filter ‘folderlist=w+’ ‘folderlist=$my_var’ ‘g’; </p>
</li>
<li>4.使用http_sub_module模块</li>
</ul>
<p>根据实际的需求，使用第3种，需要先安装sregex library，然后重新编译安装OpenResty，在编译时 ./configure –add-module=/path/to/replace-filter-nginx-module 启用replace-filter-nginx-module模块。<br/>如果使用第4种方式都需要重新编译安装OpenResty，在编译时 –with-http_sub_module 启用http_sub_module模块。<br/>这两种他们都不接受，因为涉及的客户太多。<br/>对于第2种方式，是个比较好的方式，但是使用第二种方式需要增加一个用于子请求的location，相当于大动了配置文件，并且相应的我还得去修改之前写的安装升级脚本，于是最终还是选择了第一种方式。<br/>虽然第2种到第4种的方案不适用于此次的需求，但是我还是尝试了使用下第2种和第4种的方案，并会把相关的脚本和配置贴在下面。</p>
<h3 id="第一种处理办法"><a href="#第一种处理办法" class="headerlink" title="第一种处理办法"></a>第一种处理办法</h3><p>lua脚本代码如下：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">-- body_filter_by_lua, body filter模块，ngx.arg[1]代表输入的chunk，ngx.arg[2]代表当前chunk是否为last</div><div class="line">local chunk, eof = ngx.arg[1], ngx.arg[2]</div><div class="line">local buffered = ngx.ctx.buffered</div><div class="line">if not buffered then</div><div class="line">   buffered = {}  -- XXX we can use table.new here </div><div class="line">   ngx.ctx.buffered = buffered</div><div class="line">end</div><div class="line">if chunk ~= &#34;&#34; then</div><div class="line">   buffered[#buffered + 1] = chunk</div><div class="line">   ngx.arg[1] = nil</div><div class="line">end</div><div class="line">if eof then</div><div class="line">   local whole = table.concat(buffered)</div><div class="line">   ngx.ctx.buffered = nil</div><div class="line">   -- try to unzip</div><div class="line">   -- local status, debody = pcall(com.decode, whole) </div><div class="line">   -- if status then whole = debody end</div><div class="line"></div><div class="line">   -- try to add or replace response body</div><div class="line">   -- local js_code = ...</div><div class="line">   -- whole = whole .. js_code</div><div class="line">   whole = string.gsub(whole, &#34;max%-width%:1632px%;&#34;,  &#34;&#34;)</div><div class="line">   ngx.arg[1] = whole</div><div class="line">end</div></pre></td></tr></tbody></table></figure><p></p>
<p>Nginx相关location配置如下：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location  /fe_components/ {</div><div class="line">     location ~ /fe_components/jqwidget/.*/bh-scenes-1.2.min.css {</div><div class="line">            root   /usr/local/nginx/nginx/html/;</div><div class="line">            body_filter_by_lua_file /opt/lua/replace.lua;</div><div class="line">     }</div><div class="line"></div><div class="line">     root   /usr/local/nginx/nginx/html;</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p>
<p>但是重载Nginx后发现，这个css样式的响应时间竟然是1.1min，可怕。。。<br/><img src="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/25.png" alt=""/><br/><img src="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/26.png" alt=""/><br/>仔细阅读上面贴出来的<a href="https://github.com/openresty/lua-nginx-module#name" target="_blank" rel="external noopener noreferrer">OpenResty Readme</a>，发现有这么一段话：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">When the Lua code may change the length of the response body, then it is required to always clear out the Content-Length response header (if any) in a header filter to enforce streaming output, as in</div></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location /foo {</div><div class="line">    # fastcgi_pass/proxy_pass/...</div><div class="line"></div><div class="line">    header_filter_by_lua_block { ngx.header.content_length = nil }</div><div class="line">    body_filter_by_lua &#39;ngx.arg[1] = string.len(ngx.arg[1]) .. &#34;\n&#34;&#39;;</div><div class="line">}</div></pre></td></tr></tbody></table></figure>
<p>于是需要修改配置文件，在body_filter_by_lua_file /opt/lua/replace.lua之前就得把header中的 content_length 置为空。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">location  /fe_components/ {</div><div class="line">     location ~ /fe_components/jqwidget/.*/bh-scenes-1.2.min.css {</div><div class="line">            root   /usr/local/nginx/nginx/html/;</div><div class="line">            header_filter_by_lua &#39;ngx.header.content_length = nil&#39;;</div><div class="line">            body_filter_by_lua_file /opt/lua/replace.lua;</div><div class="line">     }</div><div class="line"></div><div class="line">     root   /usr/local/nginx/nginx/html;</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p>
<p>这样重载Nginx，清除缓存重新访问下，发现加载就正常了。<br/>仔细了解了下原因，当代码运行到 body_filter_by_lua<em> 时，HTTP 报头（header）已经发送出去了。如果在之前设置了跟响应体相关的报头，而又在 body_filter_by_lua</em> 中修改了响应体，会导致响应报头和实际响应的不一致。举个简就是说这个例子里上游的服务器返回了 Content-Length 报头，而 body_filter_by_lua* 又修改了响应体的实际大小（因为我删除了一些字符串）。客户端收到这个报头后，按其中的 Content-Length 去处理，顺着一头栽进坑里。由于Nginx 的流式响应，发出去的报头就像泼出去的水，要想修改只能提前进行。这是流式处理常常面对的悖论：要在流的开始输出长度，但又不能在那个时间事先知道流的长度。<br/>对于处理逻辑简单的场景来说，Lua是十分合适的。 </p>
<h3 id="第二种处理办法"><a href="#第二种处理办法" class="headerlink" title="第二种处理办法"></a>第二种处理办法</h3><p>lua脚本：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ngx.req.read_body()</div><div class="line">local data = ngx.req.get_body_data()</div><div class="line">local args = ngx.req.get_uri_args()</div><div class="line">local res = ngx.location.capture(&#34;/bh-scenes-1.2.min.css&#34;, {method = ngx.HTTP_GET, body=data, args=args})</div><div class="line">res.body = string.gsub(res.body, &#34;max%-width%:1632px%;&#34;, &#34;&#34;)</div><div class="line">ngx.say(res.body)</div></pre></td></tr></tbody></table></figure><p></p>
<p>Nginx相关配置：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">location = /bh-scenes-1.2.min.css {</div><div class="line">      root   /usr/local/nginx/nginx/html/fe_components/jqwidget/teal/;</div><div class="line">}</div><div class="line"></div><div class="line">location  /fe_components/ {</div><div class="line">     location ~ /fe_components/jqwidget/.*/bh-scenes-1.2.min.css {</div><div class="line">          content_by_lua_file /opt/lua/replace2.lua;</div><div class="line">     }</div><div class="line"></div><div class="line">     root   /usr/local/nginx/nginx/html;</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p>
<h3 id="第四种处理办法"><a href="#第四种处理办法" class="headerlink" title="第四种处理办法"></a>第四种处理办法</h3><p>需要重新编译安装OpenResty，编译时加入参数 –with-http_sub_module。<br/>Nginx相关配置如下：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">location  /fe_components/ {</div><div class="line">        location ~ /jqwidget/teal/bh-scenes-1.2.min.css {</div><div class="line">           #sub_filter_types *;</div><div class="line">           sub_filter_types text/css;</div><div class="line">           sub_filter &#39;max-width:1632px;&#39;  &#39;&#39;;</div><div class="line">           sub_filter_once off;</div><div class="line">           root   /usr/local/nginx/nginx/html/;</div><div class="line">        }</div><div class="line">        root   /usr/local/nginx/nginx/html;</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p>