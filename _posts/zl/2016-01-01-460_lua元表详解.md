---
layout: post
title: lua元表详解 
tags: [lua文章]
categories: [topic]
---
<h2 id="元表的作用"><a href="#元表的作用" class="headerlink" title="元表的作用"></a>元表的作用</h2><p>元表是用来定义对table或userdata操作方式的表<br/></p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t1 = {<span class="number">1</span>}</span><br/><span class="line"><span class="keyword">local</span> t2 = {<span class="number">2</span>}</span><br/><span class="line"><span class="keyword">local</span> t3 = t1 + t2</span><br/></pre></td></tr></tbody></table></figure>
<p>我们直接对两个table执行＋运算，会报错</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">lua: /usercode/file.lua:<span class="number">3</span>: attempt to perform arithmetic on <span class="keyword">local</span> <span class="string">&#39;t1&#39;</span> (a <span class="built_in">table</span> value)</span><br/></pre></td></tr></tbody></table></figure>
<p>因为程序不知道如何对两个表执行+运行，这时候就需要通过元表来定义如何执行t1的+运算，有点类似于c语言中的运算符重载。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"></span><br/><span class="line">mt.<span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br/><span class="line">	<span class="keyword">local</span> temp = {}</span><br/><span class="line">	<span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t1) <span class="keyword">do</span></span><br/><span class="line">		<span class="built_in">table</span>.<span class="built_in">insert</span>(temp,v)</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t2) <span class="keyword">do</span></span><br/><span class="line">		<span class="built_in">table</span>.<span class="built_in">insert</span>(temp,v)</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">return</span> temp</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"><span class="keyword">local</span> t1 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br/><span class="line"><span class="keyword">local</span> t2 = {<span class="number">2</span>}</span><br/><span class="line"><span class="comment">--设置t1的元表为mt</span></span><br/><span class="line"><span class="built_in">setmetatable</span>(t1,mt)</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> t3 = t1 + t2</span><br/><span class="line"><span class="comment">--输出t3</span></span><br/><span class="line"><span class="keyword">local</span> st = <span class="string">&#34;{&#34;</span></span><br/><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t3) <span class="keyword">do</span></span><br/><span class="line">	st = st..v..<span class="string">&#34;, &#34;</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line">st = st..<span class="string">&#34;}&#34;</span></span><br/><span class="line"><span class="built_in">print</span>(st)</span><br/></pre></td></tr></tbody></table></figure>
<p>结果为：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, }</span><br/></pre></td></tr></tbody></table></figure>
<p>因为程序在执行t1+t2的时候，会去调用t1的元表mt的__add元方法进行计算。<br/><strong>具体的过程是：</strong><br/>1.查看t1是否有元表，若有，则查看t1的元表是否有__add元方法，若有则调用。<br/>2.查看t2是否有元表，若有，则查看t2的元表是否有__add元方法，若有则调用。<br/>3.若都没有则会报错。<br/><strong>所以说，我们通过定义了t1元表的__add元方法，达到了让两个表通过+号来相加的效果</strong></p>
<h2 id="元表的元方法"><a href="#元表的元方法" class="headerlink" title="元表的元方法"></a>元表的元方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__add</td>
<td>运算符 +</td>
</tr>
<tr>
<td>__sub</td>
<td>运算符 -</td>
</tr>
<tr>
<td>__mul</td>
<td>运算符 *</td>
</tr>
<tr>
<td>__ div</td>
<td>运算符 /</td>
</tr>
<tr>
<td>__mod</td>
<td>运算符 %</td>
</tr>
<tr>
<td>__unm</td>
<td>运算符 -（取反）</td>
</tr>
<tr>
<td>__concat</td>
<td>运算符 ..</td>
</tr>
<tr>
<td>__eq</td>
<td>运算符 ==</td>
</tr>
<tr>
<td>__lt</td>
<td>运算符 &lt;</td>
</tr>
<tr>
<td>__le</td>
<td>运算符 &lt;=</td>
</tr>
<tr>
<td>__call</td>
<td>当函数调用</td>
</tr>
<tr>
<td>__tostring</td>
<td>转化为字符串</td>
</tr>
<tr>
<td>__index</td>
<td>调用一个索引</td>
</tr>
<tr>
<td>__newindex</td>
<td>给一个索引赋值</td>
</tr>
</tbody>
</table>
<p>由于那几个运算符使用类似，所以就不单独说明了，接下来说 __call， __tostring， __index， __newindex四个元方法。</p>
<h2 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h2><p>__call可以让table当做一个函数来使用。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"><span class="comment">--__call的第一参数是表自己</span></span><br/><span class="line">mt.<span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable,...)</span></span></span><br/><span class="line">    <span class="comment">--输出所有参数</span></span><br/><span class="line">    <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">ipairs</span>{...} <span class="keyword">do</span></span><br/><span class="line">        <span class="built_in">print</span>(v)</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">t = {}</span><br/><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br/><span class="line"><span class="comment">--将t当作一个函数调用</span></span><br/><span class="line">t(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br/></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br/><span class="line"><span class="number">2</span></span><br/><span class="line"><span class="number">3</span></span><br/></pre></td></tr></tbody></table></figure>
<h2 id="tostring"><a href="#tostring" class="headerlink" title="__tostring"></a>__tostring</h2><p>__tostring可以修改table转化为字符串的行为</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"><span class="comment">--参数是表自己</span></span><br/><span class="line">mt.<span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br/><span class="line">    <span class="keyword">local</span> s = <span class="string">&#34;{&#34;</span></span><br/><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br/><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">then</span></span><br/><span class="line">            s = s..<span class="string">&#34;, &#34;</span></span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">        s = s..v</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    s = s ..<span class="string">&#34;}&#34;</span></span><br/><span class="line">    <span class="keyword">return</span> s</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">t = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br/><span class="line"><span class="comment">--直接输出t</span></span><br/><span class="line"><span class="built_in">print</span>(t)</span><br/><span class="line"><span class="comment">--将t的元表设为mt</span></span><br/><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br/><span class="line"><span class="comment">--输出t</span></span><br/><span class="line"><span class="built_in">print</span>(t)</span><br/></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>: <span class="number">0x14e2050</span></span><br/><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br/></pre></td></tr></tbody></table></figure>
<h2 id="index"><a href="#index" class="headerlink" title="__index"></a>__index</h2><p>调用table的一个不存在的索引时，会使用到元表的__index元方法，和前几个元方法不同，__index可以是一个函数也可是一个table。<br/><strong>作为函数：</strong><br/>将表和索引作为参数传入__index元方法，return一个返回值</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"><span class="comment">--第一个参数是表自己，第二个参数是调用的索引</span></span><br/><span class="line">mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,key)</span></span></span><br/><span class="line">    <span class="keyword">return</span> <span class="string">&#34;it is &#34;</span>..key</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">t = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br/><span class="line"><span class="comment">--输出未定义的key索引，输出为nil</span></span><br/><span class="line"><span class="built_in">print</span>(t.key)</span><br/><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br/><span class="line"><span class="comment">--设置元表后输出未定义的key索引，调用元表的__index函数，返回&#34;it is key&#34;输出</span></span><br/><span class="line"><span class="built_in">print</span>(t.key)</span><br/></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br/><span class="line">it is key</span><br/></pre></td></tr></tbody></table></figure>
<p><strong>作为table：</strong><br/>查找__index元方法表，若有该索引，则返回该索引对应的值，否则返回nil</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line">mt.<span class="built_in">__index</span> = {key = <span class="string">&#34;it is key&#34;</span>}</span><br/><span class="line"></span><br/><span class="line">t = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br/><span class="line"><span class="comment">--输出未定义的key索引，输出为nil</span></span><br/><span class="line"><span class="built_in">print</span>(t.key)</span><br/><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br/><span class="line"><span class="comment">--输出表中未定义，但元表的__index中定义的key索引时，输出__index中的key索引值&#34;it is key&#34;</span></span><br/><span class="line"><span class="built_in">print</span>(t.key)</span><br/><span class="line"><span class="comment">--输出表中未定义，但元表的__index中也未定义的值时，输出为nil</span></span><br/><span class="line"><span class="built_in">print</span>(t.key2)</span><br/></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br/><span class="line">it is key</span><br/><span class="line"><span class="literal">nil</span></span><br/></pre></td></tr></tbody></table></figure>
<h2 id="newindex"><a href="#newindex" class="headerlink" title="__newindex"></a>__newindex</h2><p>当为table中一个不存在的索引赋值时，会去调用元表中的__newindex元方法<br/><strong>作为函数</strong><br/>__newindex是一个函数时会将赋值语句中的表、索引、赋的值当作参数去调用。不对表进行改变</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"><span class="comment">--第一个参数时表自己，第二个参数是索引，第三个参数是赋的值</span></span><br/><span class="line">mt.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,index,value)</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;index is &#34;</span>..index)</span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;value is &#34;</span>..value)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">t = {key = <span class="string">&#34;it is key&#34;</span>}</span><br/><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br/><span class="line"><span class="comment">--输出表中已有索引key的值</span></span><br/><span class="line"><span class="built_in">print</span>(t.key)</span><br/><span class="line"><span class="comment">--为表中不存在的newKey索引赋值，调用了元表的__newIndex元方法，输出了参数信息</span></span><br/><span class="line">t.newKey = <span class="number">10</span></span><br/><span class="line"><span class="comment">--表中的newKey索引值还是空，上面看着是一个赋值操作，其实只是调用了__newIndex元方法，并没有对t中的元素进行改动</span></span><br/><span class="line"><span class="built_in">print</span>(t.newKey)</span><br/></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">it is key</span><br/><span class="line">index is newKey</span><br/><span class="line">value is <span class="number">10</span></span><br/><span class="line"><span class="literal">nil</span></span><br/></pre></td></tr></tbody></table></figure>
<p><strong>作为table</strong><br/>__newindex是一个table时，为t中不存在的索引赋值会将该索引和值赋到__newindex所指向的表中，不对原来的表进行改变。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"><span class="comment">--将__newindex元方法设置为一个空表newTable</span></span><br/><span class="line"><span class="keyword">local</span> newTable = {}</span><br/><span class="line">mt.<span class="built_in">__newindex</span> = newTable</span><br/><span class="line">t = {}</span><br/><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br/><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br/><span class="line"><span class="comment">--对t中不存在的索引进行负值时，由于t的元表中的__newindex元方法指向了一个表，所以并没有对t中的索引进行赋值操作将，而是将__newindex所指向的newTable的newKey索引赋值为了&#34;it is newKey&#34;</span></span><br/><span class="line">t.newKey = <span class="string">&#34;it is newKey&#34;</span></span><br/><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br/></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span>	<span class="literal">nil</span></span><br/><span class="line"><span class="literal">nil</span>	it is newKey</span><br/></pre></td></tr></tbody></table></figure>
<h2 id="rawget-和-rawset"><a href="#rawget-和-rawset" class="headerlink" title="rawget 和 rawset"></a>rawget 和 rawset</h2><p>有时候我们希望直接改动或获取表中的值时，就需要rawget和rawset方法了。<br/><strong>rawget可以让你直接获取到表中索引的实际值，而不通过元表的__index元方法。</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line">mt.<span class="built_in">__index</span> = {key = <span class="string">&#34;it is key&#34;</span>}</span><br/><span class="line">t = {}</span><br/><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br/><span class="line"><span class="built_in">print</span>(t.key)</span><br/><span class="line"><span class="comment">--通过rawget直接获取t中的key索引</span></span><br/><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(t,<span class="string">&#34;key&#34;</span>))</span><br/></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">it is key</span><br/><span class="line"><span class="literal">nil</span></span><br/></pre></td></tr></tbody></table></figure>
<p><strong>rawset可以让你直接为表中索引的赋值，而不通过元表的__newindex元方法。</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br/><span class="line"><span class="keyword">local</span> newTable = {}</span><br/><span class="line">mt.<span class="built_in">__newindex</span> = newTable</span><br/><span class="line">t = {}</span><br/><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br/><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br/><span class="line"><span class="comment">--通过rawset直接向t的newKey索引赋值</span></span><br/><span class="line"><span class="built_in">rawset</span>(t,<span class="string">&#34;newKey&#34;</span>,<span class="string">&#34;it is newKey&#34;</span>)</span><br/><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br/></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span>	<span class="literal">nil</span></span><br/><span class="line">it is newKey	<span class="literal">nil</span></span><br/></pre></td></tr></tbody></table></figure>
<h2 id="元表的使用场景"><a href="#元表的使用场景" class="headerlink" title="元表的使用场景"></a>元表的使用场景</h2><h3 id="作为table的元表"><a href="#作为table的元表" class="headerlink" title="作为table的元表"></a>作为table的元表</h3><p>通过为table设置元表可以在lua中实现面向对象编程。</p>
<h3 id="作为userdata的元表"><a href="#作为userdata的元表" class="headerlink" title="作为userdata的元表"></a>作为userdata的元表</h3><p>通过对userdata和元表可以实现在lua中对c中的结构进行面向对象式的访问。</p>