---
layout: post
title: Lua学习笔记：对函数的深入理解 
tags: [lua文章]
categories: [topic]
---
<div class="content" itemprop="articleBody">
    <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><strong>lua中的函数都可以认为是闭包，只不过为了便于理解还是用了函数的概念。</strong></li>
<li><strong>lua中函数的返回值可以是匿名函数，也就是闭包。以下面的代码为例，提出一个概念：非局部的变量。在下面的代码中，匿名函数访问了一个变量i，它对于newCount来说是局部变量，对于匿名函数来说是既不是局部变量也不是全局变量，在lua中这个称谓非局部的变量。</strong></li>
<li><strong>在lua中一个闭包指的是一个函数和该函数所需要访问的非局部的变量。lua会把它们看做是一个整体，因此在下面的代码中多次允许c1和c2，会发现变量i是在递增的。这是因为c1 = newCount()这句代码相当于给c1赋值了一个闭包，它包含了i这个变量。因此多次执行相当于就是在反复执行一个对象，这样i就一直是原来那个i。</strong></li>
</ul>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line">	<span class="keyword">local</span> i =<span class="number">0</span></span><br/><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line">		i=i+<span class="number">1</span></span><br/><span class="line">		<span class="built_in">print</span>(i)</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">c1 = newCount()</span><br/><span class="line"><span class="built_in">print</span>(c1())</span><br/><span class="line"><span class="built_in">print</span>(c1())</span><br/><span class="line"></span><br/><span class="line">c2 = newCount()</span><br/><span class="line"><span class="built_in">print</span>(c2())</span><br/><span class="line"><span class="built_in">print</span>(c2())</span><br/><span class="line"><span class="built_in">print</span>(c1())</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="number">1</span></span><br/><span class="line"><span class="number">2</span></span><br/><span class="line"><span class="number">1</span></span><br/><span class="line"><span class="number">2</span></span><br/><span class="line"><span class="number">3</span></span><br/></pre></td></tr></tbody></table></figure>

<h2 id="闭包的沙盒"><a href="#闭包的沙盒" class="headerlink" title="闭包的沙盒"></a>闭包的沙盒</h2><ul>
<li><strong>下面这段代码中，修改了math库的sin方法。类似的还可以用来处理一些不安全的代码，这样的方式类似沙盒，将不安全包装了起来。</strong><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">45</span>))</span><br/><span class="line"></span><br/><span class="line">oldSin = <span class="built_in">math</span>.<span class="built_in">sin</span></span><br/><span class="line"><span class="built_in">math</span>.<span class="built_in">sin</span> = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span></span><br/><span class="line">	<span class="keyword">return</span> oldSin(x*<span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">180</span>)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">45</span>))</span><br/></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>直接使用非全局的函数递归会报错，如下代码，会报：<code>attempt to call global &#39;foo&#39; (a nil value)</code>这个是因为在调用foo(x-1)时，这个foo函数还没有定义完，因此表达式在尝试调用一个全局的函数foo，但是显然这个全局函数是不存在的。</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span></span><br/><span class="line">	<span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">then</span></span><br/><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br/><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x*foo(x<span class="number">-1</span>)</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(foo(<span class="number">3</span>))</span><br/></pre></td></tr></tbody></table></figure>

<p><strong>正确写法</strong></p>
<pre><code class="lua"><span class="keyword">local</span> foo
fool = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span>
    <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="number">1</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> x*foo(x<span class="number">-1</span>)    
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">-- 相当于</span>
<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span></span>    </code></pre>
<p><strong>正确的尾调用本质是为了不记录函数的返回位置，这样在栈中就可以无限的调用函数。在lua中只有return <func>(<args>)这样的形式才是尾调用。</args></func></strong></p>

  </div>