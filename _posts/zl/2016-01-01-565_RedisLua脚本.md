---
layout: post
title: RedisLua脚本 
tags: [lua文章]
categories: [topic]
---
<h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><ol>
<li><p>使用脚本可以直接在服 务器端执行 Redis 命令,一般的数据 处理操作可以直接使用 Lua 语言或者 Lua 解释器提供的函数 库来完成,不必再返回 给客户端进行处理。</p>
</li>
<li><p>所有脚本都是以事 务的形式来执行的,脚本在 执行过程中不会被其他工作打断,也不会引起任何 竞争条件,完全可以使用 Lua 脚本来代替事 务和乐观锁。</p>
</li>
<li><p>所有脚本都是可重用的,也即是 说,重复执行相同的操作 时,只要调用储存在服务器内部的脚本 缓存就可以了,不用重新 发送整个脚本,从而尽可能地 节约网络资源。</p>
</li>
</ol>
<h2 id="执行-Lua-脚本"><a href="#执行-Lua-脚本" class="headerlink" title="执行 Lua 脚本"></a>执行 Lua 脚本</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br/></pre></td></tr></tbody></table></figure>
<ul>
<li>script 参数是要执行的 Lua 脚本。</li>
<li>numkeys 是脚本要处理的数据库键的数量,之后的 key [key …] 参数指定了脚本要 处理的数据库键,被传入的键可以在脚本里面通 过访问 KEYS 数组来取得,比如 KEYS[1] 就取出第一个 输入的键,KEYS[2] 取出第二个输入的键,诸如此类。</li>
<li>arg [arg …] 参数指定了脚本要用到的参数,在脚本里面可以通 过访问 ARGV 数组来获取这些参数。显式地指定脚本里面用到的 键是为了配合 Redis 集群对键的检查,如果不这样做的话,在集群里面使用脚本可能会出 错。</li>
</ul>
<p>另外,通过显式地指定脚本要用到的数据 库键以及相关参数,而不是将数据 库键和参数硬写在脚本里面,用户可以更方便地重用同一个脚本。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &#34;return redis.call(&#39;PING&#39;)&#34; 0   # 在 Lua 脚本里面执行 PING 命令</span><br/><span class="line">PONG</span><br/><span class="line">redis&gt; EVAL &#34;return redis.call(&#39;DBSIZE&#39;)&#34; 0  # 在 Lua 脚本里面执行 DBSIZE 命令</span><br/><span class="line">(integer) 4</span><br/><span class="line"></span><br/><span class="line"># 在 Lua 脚本里面执行 GET 命令,取出键 msg 的值,并对值进行字符串拼接操作</span><br/><span class="line">redis&gt; SET msg &#34;hello world&#34;</span><br/><span class="line">OK</span><br/><span class="line">redis&gt; EVAL &#34;return &#39;The message is: &#39; .. redis.call(&#39;GET&#39;, KEYS[1]) &#39;&#34; 1 msg</span><br/><span class="line">&#34;The message is: hello world&#34;</span><br/></pre></td></tr></tbody></table></figure><p></p>
<h2 id="redis-call-和-redis-pcall-的区别"><a href="#redis-call-和-redis-pcall-的区别" class="headerlink" title="redis.call() 和 redis.pcall() 的区别"></a>redis.call() 和 redis.pcall() 的区别</h2><p>redis.call() 和 redis.pcall() 都可以用来执行 Redis 命令,它们的不同之处在于，当被执行的脚本出错时：</p>
<ul>
<li>redis.call() 会返回出错脚本的名字以及 EVAL 命令的错误信息</li>
<li>redis.pcall() 只返回 EVAL 命令的错误信息。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &#34;return redis.call(&#39;NotExistsCommand&#39;)&#34; 0</span><br/><span class="line">(error) ERR Error running script (call to f_ddabd662fa0a8e105765181ee7606562c1e6f1ce):</span><br/><span class="line">@user_script:1: @user_script: 1: Unknown Redis command called from Lua script</span><br/><span class="line"></span><br/><span class="line">redis&gt; EVAL &#34;return redis.pcall(&#39;NotExistsCommand&#39;)&#34; 0</span><br/><span class="line">(error) @user_script: 1: Unknown Redis command called from Lua script</span><br/></pre></td></tr></tbody></table></figure>
<p>换句话来说,在被执行的脚本出错时, redis.call() 可以提供更详细的错误信息,方便进行查错。</p>
<h2 id="使用-EVALSHA-来减少网络资源损耗"><a href="#使用-EVALSHA-来减少网络资源损耗" class="headerlink" title="使用 EVALSHA 来减少网络资源损耗"></a>使用 EVALSHA 来减少网络资源损耗</h2><p>任何 Lua 脚本,只要被 EVAL 命令执行过一次,就会被 储存到服务器的脚本缓存里面,用户只要通过 EVALSHA 命令,指定被 缓存脚本的 SHA1 值,就可以在不 发送脚本的情况下,再次 执行脚本:<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">EVALSHA sha1 numkeys key [key ...] arg [arg ...]</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>通过 SHA1 值来重用返回 ‘hello world’ 信息的脚本:<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &#34;return &#39;hello world&#39;&#34; 0</span><br/><span class="line">&#34;hello world&#34;</span><br/><span class="line">redis&gt; EVALSHA 5332031c6b470dc5a0dd9b4bf2030dea6d65de91 0</span><br/><span class="line">&#34;hello world&#34;</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>通过 SHA1 值来重用之前实现的 ZDECRBY 命令,这样就不用每次都 发送整个脚本了:<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">redis&gt; EVALSHA 918130cae39ff0759b8256948742f77300a91cb2 1 salary 500 peter</span><br/><span class="line">(integer) 0</span><br/></pre></td></tr></tbody></table></figure><p></p>
<h2 id="脚本管理命令"><a href="#脚本管理命令" class="headerlink" title="脚本管理命令"></a>脚本管理命令</h2><p>检查 sha1 值所代表的脚本是否已经被加入到脚本缓存里面,是的话返回 1 ,不是的话返回 0 。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">SCRIPT EXISTS sha1 [sha1 ...]</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>将脚本储存到脚本缓存里面,等待将来 EVALSHA 使用。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">SCRIPT LOAD script</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>清除脚本缓存储存的所有脚本。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">SCRIPT FLUSH</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>杀死运行超时的脚本。如果脚本已经执行过写入操作,那么还需要使用 SHUTDOWN NOSAVE 命令来强制服务器不保存数据,以免错误的数据被保存到数据库里面。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">SCRIPT KILL</span><br/></pre></td></tr></tbody></table></figure><p></p>