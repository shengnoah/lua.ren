---
layout: post
title: Lua中关于table对象引用传递的注意事项 
tags: [lua文章]
categories: [topic]
---
<p>最近写了挺长一段时间的Lua，发现Lua这个语言真的是很随意，产生这种感觉的根本原因应该是它把“函数” 作为了“第一类值”，也就是说函数也可以作为变量的“值”，这使得Lua可以随处定义函数，进而改变逻辑的走向，整个流程任你摆布。</p>

<p>虽说把一个函数来回设置方便了许多，但是同样带来了一些不容易发现的问题，如果搞不清定义域和引用关系，常常会导致程序错误，比如最近用Lua写按钮的触发事件时，使用公有函数创建了对应的闭包，一开始感觉table的引用有问题，写了很多中转的代码，最后发现直接就可以使用，浪费了不少时间，最后仔细分析就是闭包最根本的形式，只不过被业务逻辑给干扰了视线，接下来我们一起看看，table和闭包究竟会发生什么关系！</p>
<h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><ol>
<li><p>table作为函数参数时的操作</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#34;nexample 1:&#34;</span>);</span><br/><span class="line">data_table = {a = <span class="number">1</span>, b = <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};</span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(data_tb)</span></span></span><br/><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(data_tb) <span class="keyword">do</span></span><br/><span class="line">        <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">then</span></span><br/><span class="line">            data_tb[k] = <span class="literal">nil</span>;</span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line">filter(data_table);</span><br/><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(data_table) <span class="keyword">do</span></span><br/><span class="line">    <span class="built_in">print</span>(k,v)</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">example 1:</span><br/><span class="line">1   3</span><br/><span class="line">3   5</span><br/><span class="line">a   1</span><br/></pre></td></tr></tbody></table></figure>
<p>以上为去掉table中的偶数的代码，直接操作参数<code>data_tb</code>就可以对传入的<code>data_table</code>进行改变，这样的逻辑一般不会出错，接着我们看下接下来需求，直接将表中数据清空。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#34;nexample 2:&#34;</span>);</span><br/><span class="line">data_table = {a = <span class="number">1</span>, b = <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};</span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span><span class="params">(data_tb)</span></span></span><br/><span class="line">    data_tb = {};</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 销毁整个表</span></span><br/><span class="line">destroy(data_table);</span><br/><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(data_table) <span class="keyword">do</span></span><br/><span class="line">    <span class="built_in">print</span>(k,v)</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line">example 2:</span><br/><span class="line">1   3</span><br/><span class="line">2   4</span><br/><span class="line">3   5</span><br/><span class="line">4   6</span><br/><span class="line">b   2</span><br/><span class="line">a   1</span><br/></pre></td></tr></tbody></table></figure>
<p>看到这次的输出可能有些人就感到奇怪了，怎么上个例子改变元素可以，而这里直接给变量<code>data_tb</code>赋值，变成空表怎么不行了？这是因为<code>data_tb</code>是对变量<code>data_table</code>的整体引用，所以可以通过<code>data_tb</code>来改变变量<code>data_table</code>内部的值，但是当执行<code>data_tb = {};</code>代码时表示<code>data_tb</code>不再引用<code>data_table</code>，而去引用<code>{}</code>了，也就是<code>data_tb</code>和<code>data_table</code>脱离了关系，这一点可以类比C++代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_string</span><span class="params">(<span class="keyword">char</span>* pStr)</span></span></span><br/><span class="line"><span class="function"></span>{</span><br/><span class="line">    pStr[<span class="number">0</span>] = <span class="string">&#39;5&#39;</span>;</span><br/><span class="line">    pStr[<span class="number">1</span>] = <span class="string">&#39;0&#39;</span>;</span><br/><span class="line"></span><br/><span class="line">    pStr = <span class="string">&#34;only testn&#34;</span>;</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br/><span class="line"><span class="function"></span>{</span><br/><span class="line">    <span class="keyword">char</span> szContent[<span class="number">32</span>] = <span class="string">&#34;help&#34;</span>;</span><br/><span class="line">    </span><br/><span class="line">    change_string(szContent);</span><br/><span class="line">    <span class="built_in">cout</span> &lt;&lt; szContent &lt;&lt; <span class="built_in">endl</span>;</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
<p>分析一下这段代码的输出结果，如果你能知道结果为<code>50lp</code>，那说明你的C++水平已经超过了入门级别，理解了这段代码有助于清楚的理解前两段Lua代码。</p>
</li>
<li><p>看一个标准闭包实现的计数器</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#34;nexample 3:&#34;</span>);</span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span><span class="params">()</span></span></span><br/><span class="line">    <span class="keyword">local</span> count = <span class="number">0</span>;</span><br/><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">        count = count + <span class="number">1</span>;</span><br/><span class="line">        <span class="keyword">return</span> count;</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">func = counter();</span><br/><span class="line"><span class="built_in">print</span>(func());</span><br/><span class="line"><span class="built_in">print</span>(func());</span><br/><span class="line"><span class="built_in">print</span>(func());</span><br/></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">example 3:</span><br/><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td></tr></tbody></table></figure>
<p>这段代码的不同之处就在于变量<code>count</code>，这是一个标准的计数器，也是一个标准的闭包，也就是说Lua支持这样的语法，闭包中可以在定义之后一直引用外部的变量，并且在返回函数的整个使用生命周期内都可以引用这个变量，加入外部修改了这个变量，闭包中引用的值也会改变，换句话来说就是闭包这种引用是引用的变量，而不是仅仅保存了一个值。</p>
</li>
<li><p>lua中常见的table引用</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#34;nexample 4:&#34;</span>);</span><br/><span class="line"><span class="keyword">local</span> t1 = {i = <span class="number">1</span>};</span><br/><span class="line"><span class="keyword">local</span> t2 = t1;</span><br/><span class="line">t1.i = <span class="number">666</span>;</span><br/><span class="line"><span class="built_in">print</span>(t2.i)</span><br/></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">example 4:</span><br/><span class="line">666</span><br/></pre></td></tr></tbody></table></figure>
<p>这个例子类似于前面“过滤掉偶数”的代码，首先定义了表<code>t1</code>，然后定义了变量<code>t2</code>引用了变量<code>t1</code>，实际上这里<code>t2</code>不是定义了变量<code>t1</code>本身，而是引用了<code>t1</code>的值，也就是引用的是<code>{i=1}</code>，这里通过<code>t1.i = 666</code>也可以影响到变量<code>t2</code>，其实这个例子看不出引用的究竟是变量<code>t1</code>还是<code>t1</code>的值，可以接着看下面的例子。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#34;nexample 5:&#34;</span>);</span><br/><span class="line"><span class="keyword">local</span> t1 = {i = <span class="number">1</span>};</span><br/><span class="line"><span class="keyword">local</span> t2 = t1;</span><br/><span class="line">t1 = {i = <span class="number">11</span>};</span><br/><span class="line"><span class="built_in">print</span>(t2.i)</span><br/></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">example 5:</span><br/><span class="line">1</span><br/></pre></td></tr></tbody></table></figure>
<p>通过这个例子就很清楚了，前面的部分和上个例子一致，但是后面直接给变量<code>t1</code>赋值时并没有改变<code>t2</code>的值，由此可以看出<code>t1</code>和<code>t2</code>已经“分离”了。</p>
</li>
<li><p>table引用和闭包结合的例子</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#34;nexample 6:&#34;</span>);</span><br/><span class="line"><span class="keyword">local</span> tb = {i= <span class="number">1</span>};</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span></span></span><br/><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">        <span class="keyword">local</span> t = tb;</span><br/><span class="line">        <span class="built_in">print</span>(t.i);</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> show = outer();</span><br/><span class="line">tb = {i = <span class="number">6</span>};</span><br/><span class="line">show();</span><br/></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">example 6:</span><br/><span class="line">6</span><br/></pre></td></tr></tbody></table></figure>
<p>这个例子应该会有猜错结果的人，我自己就是在类似的代码中搞糊涂的，一种想法是函数<code>outer</code>定义的时候变量<code>t</code>的值已经定义了，还有一种就是认为在返回函数<code>show</code>的时候变量<code>t</code>的值会定义，但是这两种想法都是错误的，实际上是调用函数<code>show</code>的时候才给<code>t</code>赋值，这时变量<code>t</code>引用的是拥有最新值的<code>tb</code>，所以<code>t.i</code>的值是6，如果你猜对了这个例子的结果，接下来看看下面的代码。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#34;nexample 7:&#34;</span>);</span><br/><span class="line"><span class="keyword">local</span> tb = {i= <span class="number">1</span>};</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span></span></span><br/><span class="line">    <span class="keyword">local</span> t = tb;</span><br/><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">        <span class="built_in">print</span>(t.i);</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> show = outer();</span><br/><span class="line">tb = {i = <span class="number">7</span>};</span><br/><span class="line">show();</span><br/></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">example 7:</span><br/><span class="line">1</span><br/></pre></td></tr></tbody></table></figure>
<p>如果清楚了上个例子的运行过程，就应该很容易知道这个例子的结果，其中变量<code>t</code>的值是在调用函数<code>outer</code>时确定的，所以后面的赋值<code>tb = {i = 7};</code>对变量<code>t</code>的值没有影响。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>lua中操作变量注意值和引用，其实很多语言都有这种区分。</li>
<li>注意闭包可以访问外部变量的特性，程序中使用起来非常方便。</li>
<li>实际使用过程中往往还夹杂着业务逻辑，要学会挖掘本质问题，这样往往可以看到真正的运行逻辑。</li>
</ol>
<h1 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a>测试源码</h1><p><a href="https://github.com/AlbertGithubHome/Bella/blob/master/lua/problem/table_refrence.lua" target="_blank" rel="noopener noreferrer">示例传送门：lua中table引用</a></p>