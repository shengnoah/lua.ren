---
layout: post
title: lua 协程和状态 
tags: [lua文章]
categories: [topic]
---
<p>协程(协同式多线程)是一种用户级的非抢占式线程。用户级是指它的切换和调度由用户控制，非抢占指一个协程只有在其挂起(yield)或者协程结束才会返回。协程和C线程一样，有自己的堆栈，自己的局部变量，自己的指令指针，并且和其它协程共享全局变量等信息。用户可以实现自己调度协程，这主要得益于yield函数可以自动保存协程当前上下文，这样当挂起的协程被唤醒(resume)时，会从yield处继续向下执行，看起来就像是一个”可以返回多次的函数”。协程还有一个强大的功能就是可通过resume/yield来交换数据，这样使得它可以用于异步回调：当执行异步代码时，切换协程，执行完成后，再切换回来(附带异步执行结果)。由于切换都是用户控制的，在同一时刻只有一个协同程序在运行(这也是和传统线程最大的区别之一)，因此无需考虑同步和加锁的问题。</p>

<p>Lua协程的相关函数封装在coroutine中，对应的 C API为<code>lua_newthread</code>，<code>lua_resume</code>等。Lua文档中的thread和coroutine是一个概念，但与操作系统的线程是两个东西。</p>
<p>C API通过<code>lua_State</code>维护一个协程的状态(以及Lua虚拟机状态的引用)，协程的状态主要指协程上下文(如交互栈)，Lua虚拟机状态是全局的，可被多个协程共享。以下描述摘自Lua5.3官方文档：</p>
<blockquote>
<blockquote>
<p>An opaque structure that points to a thread and indirectly (through the thread) to the whole state of a Lua interpreter. The Lua library is fully reentrant: it has no global variables. All information about a state is accessible through this structure.</p>
<p>A pointer to this structure must be passed as the first argument to every function in the library, except to lua_newstate, which creates a Lua state from scratch.</p>
</blockquote>
</blockquote>
<p>当调用<code>lua_newstate</code>时，实际上分为两步，1. 创建并初始化一个Lua虚拟机；2.创建一个主线程运行于虚拟机中。调用<code>lua_newthread</code>时，将在已有Lua虚拟机上，创建另一个协程执行环境，该协程与已有协程共享虚拟机状态。这两个函数返回不同的lua_State，但却共享同一个虚拟机状态，因此将lua_State理解为协程执行上下文可能更合适，lua_State本身也是一个类型为thread的GCObject，无需手动释放(Lua也没有提供对应close或destroy接口)。</p>
<h3 id="两个例子"><a href="#两个例子" class="headerlink" title="两个例子"></a>两个例子</h3><p>pil上关于协程有两个很好的例子。</p>
<p>在生产者消费者例子中，当消费者需要生产者的数据时(相当于一个异步回调)，切换到生产者协程(resume)，生产者开始运行，生产完成后，挂起自己(yield)并且传入生产的数据。此时调度回到消费者协程中，消费者从resume的返回值中得到数据，使用数据，在需要数据时再次唤醒生产者。这样我们像写同步代码一样(resume相当于函数调用，yield相当于函数返回)，完成了异步功能。而无需考虑传统生产者和消费者模型中的同步问题，因为执行顺序都由我们严格控制的。代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/></pre></td><td class="code"><pre><span class="line">pfun = function()</span><br/><span class="line">	while true do</span><br/><span class="line">		local value = io.read()</span><br/><span class="line">		print(&#34;生产: &#34;, value)</span><br/><span class="line">		coroutine.yield(value)</span><br/><span class="line">	end</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">cfun = function(p)</span><br/><span class="line">	while true do</span><br/><span class="line">		local _, value = coroutine.resume(p)</span><br/><span class="line">		print(&#34;消费: &#34;, value)</span><br/><span class="line">	end</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">p = coroutine.create(pfun)</span><br/><span class="line">cfun(p)</span><br/></pre></td></tr></tbody></table></figure>
<p>还有个例子是关于模拟多线程下载文件的，每个协程下载一个文件，由我们控制各个协程的调度，当某个协程暂时没有数据可读时(异步读取)，挂起(yield)自己，返回到调度器，开始调度(resume)下一个协程。这样总是能保证将时间片分给读取数据的协程上，而不是等待数据的协程上。当所有协程都没有数据可读时，分配器将进入忙查询，这样会空转CPU，可以通过select函数来优化，在所有协程都没有数据时，让出CPU。最终代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/><span class="line">60</span><br/><span class="line">61</span><br/><span class="line">62</span><br/><span class="line">63</span><br/><span class="line">64</span><br/><span class="line">65</span><br/><span class="line">66</span><br/><span class="line">67</span><br/><span class="line">68</span><br/></pre></td><td class="code"><pre><span class="line">socket = require &#34;socket&#34;</span><br/><span class="line"></span><br/><span class="line">-- 下载文件 在超时时挂起(返回: 连接c) 在接收完成时结束协程(返回: nil)</span><br/><span class="line">function download(host, file)</span><br/><span class="line">	local c = assert(socket.connect(host, 80))</span><br/><span class="line">	local count = 0</span><br/><span class="line">	c:send(&#34;GET &#34;.. file .. &#34; HTTP/1.0rnrn&#34;)</span><br/><span class="line">	while true do</span><br/><span class="line">		local s, status = receive(c)	</span><br/><span class="line">		if status == &#34;closed&#34; then break end</span><br/><span class="line">		if s then </span><br/><span class="line">			count = count + string.len(s) </span><br/><span class="line">			break </span><br/><span class="line">		end </span><br/><span class="line">	end</span><br/><span class="line">	c:close()</span><br/><span class="line">	print(&#34;-- download &#34;, file, &#34; completed. file size: &#34;, count)</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">function receive(conn)</span><br/><span class="line">	conn:settimeout(0)</span><br/><span class="line">	local s, status = conn:receive(&#34;*a&#34;)</span><br/><span class="line">	if status == &#34;timeout&#34; then</span><br/><span class="line">		coroutine.yield(conn)</span><br/><span class="line">	end</span><br/><span class="line">	return s, status</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">-- 保存所有协程</span><br/><span class="line">local threads = {}</span><br/><span class="line">-- 创建一个协程 对应下载一个文件</span><br/><span class="line">function get(host, file)</span><br/><span class="line">	local co = coroutine.create(function() </span><br/><span class="line">		download(host, file)</span><br/><span class="line">	end)</span><br/><span class="line"></span><br/><span class="line">	table.insert(threads, co)</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">-- 调度线程</span><br/><span class="line">function dispatcher()</span><br/><span class="line">	while true do</span><br/><span class="line">		local conns = {}</span><br/><span class="line">		local n = #threads</span><br/><span class="line">		if n == 0 then break end</span><br/><span class="line">		for i = 1,n do</span><br/><span class="line">			local status, c = coroutine.resume(threads[i])</span><br/><span class="line">			if not c then -- 接收数据完成 即download 函数正常返回</span><br/><span class="line">				table.remove(threads, i) -- 移除协程</span><br/><span class="line">				break -- 重新遍历</span><br/><span class="line">			else</span><br/><span class="line">				table.insert(conns, c)</span><br/><span class="line">			end</span><br/><span class="line">		end</span><br/><span class="line">		if #conns == n then</span><br/><span class="line">			socket.select(conns)</span><br/><span class="line">		end</span><br/><span class="line">	end</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">get(&#34;www.baidu.com&#34;, &#34;/index.html&#34;)</span><br/><span class="line">get(&#34;wudaijun.com&#34;, &#34;/2014/12/shared_ptr-reference/&#34;)</span><br/><span class="line">get(&#34;wudaijun.com&#34;, &#34;/2014/11/cpp-constructor/&#34;)</span><br/><span class="line"></span><br/><span class="line">local start = os.time()</span><br/><span class="line">dispatcher()</span><br/><span class="line">local cost = os.time()-start</span><br/><span class="line">print(&#34;-- cost time: &#34;, cost)</span><br/></pre></td></tr></tbody></table></figure>