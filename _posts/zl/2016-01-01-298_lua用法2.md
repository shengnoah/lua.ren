---
layout: post
title: lua用法2 
tags: [lua文章]
categories: [topic]
---
<p>从给定的字符串得到块(函数)。lua5.3使用load()替换loadstring(). </p>
<p>一般如下用法：<br/><code>assert(loadstring(script))()</code><br/><code>f = loadstring(&#34;a = 1&#34;)</code><br/>语义上相当于：<br/><code>f = loadstring(&#34;function() a = 1 end&#34;)</code><br/>复杂用法如下：<br/>下面是动态加载字符串，并执行，结果为一个table       </p>
<pre><code>local script = &#34;localee={[0]={id=0,lv=5,text=&#39;yy&#39;},[1]={id=1,lv=3,text=&#39;zz&#39;}}  return ee&#34;  
local tb=assert(loadstring(script))()  
print(tb[0].text)  
</code></pre><p>下面是动态加载字符串，并执行，结果为方法</p>
<pre><code>local addscript=&#34;function dadd(a,b) return a+b  end&#34;  
assert(loadstring(addscript))()  
print(tostring(dadd(2,3)))  
</code></pre><pre><code>local f = load(&#34;a=1+2&#34;)
print(type(f))  --function
</code></pre><h1 id="loadfile"><a href="#loadfile" class="headerlink" title="loadfile"></a>loadfile</h1><p>loadfile 编译Lua外部代码块，但不会运行代码，将会以函数的形式返回编译结果.返回编译结果函数.</p>
<pre><code>local f = laodfile(&#34;a.lua&#34;)
print(type(f)) --function
</code></pre><h1 id="dofile"><a href="#dofile" class="headerlink" title="dofile"></a>dofile</h1><p>dofile 直接编译运行Lua外部代码块，并不返回任何结果。编译错误会返回nil.  </p>
<pre><code>function dofile(filename)
    local func = assert(loadfile(filename))
    func()
end
</code></pre><h1 id="load"><a href="#load" class="headerlink" title="load"></a>load</h1><p><code>load (chunk [, chunkname [, mode [, env]]])</code><br/>加载一个代码块。<br/>如果 chunk 是一个字符串，代码块指这个字符串。 如果 chunk 是一个函数， load 不断地调用它获取代码块的片断。 每次对 chunk 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。 当返回空串、nil、或是不返回值时，都表示代码块结束。</p>
<p>如果结果函数有上值， env 被设为第一个上值。 若不提供此参数，将全局环境替代它。<br/>chunkname 在错误消息和调试消息中，用于代码块的名字。<br/>字符串 mode 用于控制代码块是文本还是二进制（即预编译代码块）。 它可以是字符串 “b” （只能是二进制代码块）， “t” （只能是文本代码块）， 或 “bt” （可以是二进制也可以是文本）。 默认值为 “bt”。       </p>
<h1 id="ENV"><a href="#ENV" class="headerlink" title="_ENV"></a>_ENV</h1><p>引用一个叫 var 的自由名字在句法上都被翻译为 _ENV.var 。 此外，每个被编译的 Lua 代码块都会有一个外部的局部变量叫 _ENV。</p>
<p> 这里特别指出，你可以定义一个新变量或指定一个参数叫这个名字。    当编译器在转译自由名字时所用到的 _ENV ， 指的是你的程序在那个点上可见的那个名为 _ENV 的变量<br/>被 _ENV 用于值的那张表被称为 环境。   </p>
<p>Lua保有一个被称为 全局环境 特别环境。它被保存在 C 注册表的一个特别索引下。<br/>在 Lua 中，全局变量 _G 被初始化为这个值。 </p>
<p>当 Lua 加载一个代码块，_ENV 这个上值的默认值就是这个全局环境。         因此，在默认情况下，Lua 代码中提及的自由名字都指的全局环境中的相关项        （它们也被称为 全局变量 ）。<br/>此外，所有的标准库都被加载入全局环境，一些函数也针对这个环境做操作。 你可以用 load （或 loadfile）加载代码块，并赋予它们不同的环境。 （在 C 里，当你加载一个代码块后，可以通过改变它的第一个上值来改变它的环境。）    </p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>如果 index 是个数字， 那么返回参数中第 index 个之后的部分； 负的数字会从后向前索引（-1 指最后一个参数）。 否则，index 必须是字符串 “#”， 此时 select 返回参数的个数。 </p>
<pre><code>do  
    function foo(...)  
        for i = 1, select(&#39;#&#39;, ...) do //get the count of the params  
            local arg = select(i, ...);//select the param  
            print(&#34;arg&#34;, arg);  
        end  
    end  

    foo(1, 2, 3, 4);  
end
</code></pre><h1 id="next"><a href="#next" class="headerlink" title="next"></a>next</h1><p><code>next (table [, index])</code><br/>允许程序遍历表的所有字段。它的第一个参数是一个表，它的第二个参数是该表的索引。接下来返回表及其关联值的一个索引。</p>
<pre><code>local tee = {1, 3, 4, 6, 8}

t = {3,7,10,17, pi=3.14159, banana=&#34;yellow&#34;}
for key,value in next,t,nil do
 print(key,value)
end

function pairs (t)
    return next, t, nil
end

for k, v in pairs(t) do
    print(k, v)
end
</code></pre><h1 id="pcall"><a href="#pcall" class="headerlink" title="pcall"></a>pcall</h1><p><code>pcall (f [, arg1, ···])</code></p>
<p>传入参数，以 保护模式 调用函数 f 。 这意味着 f 中的任何错误不会抛出； 取而代之的是，pcall 会将错误捕获到，并返回一个状态码。 第一个返回值是状态码（一个布尔量）， 当没有错误时，其为真。 此时，pcall 同样会在状态码后返回所有调用的结果。 在有错误时，pcall 返回 false 加错误消息。</p>
<p><code>local ret, msg = pcall(function(i) print(i) end, 33)</code></p>
<h1 id="xpcall"><a href="#xpcall" class="headerlink" title="xpcall"></a>xpcall</h1><p><code>xpcall (f, msgh [, arg1, ···])</code><br/>这个函数和 pcall 类似。 不过它可以额外设置一个消息处理器 msgh。</p>
<pre><code>local function __TRACKBACK__(errmsg)
    local track_text = debug.traceback(tostring(errmsg), 6);
    print(track_text, &#34;LUA ERROR&#34;);
    return false;
end


local function trycall(func, ...)
    local args = { ... };
    return xpcall(function() func(unpack(args)) end, __TRACKBACK__);
end

local function test(aaa)
    print(&#34;#&#34;..aaa)
end

trycall(test, nil)
</code></pre><h1 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h1><p>使用[[ sun feng sunfeng ]]  定义多行文本。</p>