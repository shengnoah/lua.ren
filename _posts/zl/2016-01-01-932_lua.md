---
layout: post
title: lua 
tags: [lua文章]
categories: [topic]
---
<h3 id="元表-类似操作符重载">元表（类似操作符重载）</h3>

<p><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/" title="title text">OpenResty 最佳实践</a></p>

<h5 id="lua-提供的所有操作符都可以被重载">Lua 提供的所有操作符都可以被重载：</h5>

<p>元方法 含义
“<strong>add” + 操作
“</strong>sub” - 操作 其行为类似于 “add” 操作
“<strong>mul” * 操作 其行为类似于 “add” 操作
“</strong>div” / 操作 其行为类似于 “add” 操作
“<strong>mod” % 操作 其行为类似于 “add” 操作
“</strong>pow” ^ （幂）操作 其行为类似于 “add” 操作
“<strong>unm” 一元 - 操作
“</strong>concat”  .. （字符串连接）操作
“<strong>len” # 操作
“</strong>eq”  == 操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作 仅在两个对象类型相同且有对应操作相同的元方法时才起效
“<strong>lt”  &lt; 操作
“</strong>le”  &lt;= 操作</p>

<h5 id="除了操作符之外-如下元方法也可以被重载-下面会依次解释使用方法">除了操作符之外，如下元方法也可以被重载，下面会依次解释使用方法：</h5>

<p>元方法 含义
“<strong>index”   取下标操作用于访问 table[key]
“</strong>newindex”    赋值给指定下标 table[key] = value
“<strong>tostring”    转换成字符串
“</strong>call”    当 Lua 调用一个值时调用
“<strong>mode”    用于弱表(week table)
“</strong>metatable”   用于保护metatable不被访问</p>

<h5 id="index-元方法">__index 元方法</h5>

<p>下面的例子中，我们实现了在表中查找键不存在时转而在元表中查找该键的功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tbody><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></pre></td>
<td class="lntd">
<pre class="chroma">mytable = setmetatable({key1 = &#34;value1&#34;},   --原始表
  {__index = function(self, key)            --重载函数
    if key == &#34;key2&#34; then
      return &#34;metatablevalue&#34;
    end
  end
})

print(mytable.key1,mytable.key2)  --&gt; output：value1 metatablevalue
关于 __index 元方法，有很多比较高阶的技巧，例如：__index 的元方法不需要非是一个函数，他也可以是一个表。
t = setmetatable({[1] = &#34;hello&#34;}, {__index = {[2] = &#34;world&#34;}})
print(t[1], t[2])   --&gt;hello world</pre></td></tr></tbody></table>
</div>
</div>
<h5 id="call-元方法">__call 元方法</h5>

<p>__call 元方法的功能类似于 C++ 中的仿函数，使得普通的表也可以被调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tbody><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></pre></td>
<td class="lntd">
<pre class="chroma">functor = {}
function func1(self, arg)
  print (&#34;called from&#34;, arg)
end

setmetatable(functor, {__call = func1})

functor(&#34;functor&#34;)  --&gt; called from functor
print(functor)      --&gt; output：0x00076fc8 （后面这串数字可能不一样）</pre></td></tr></tbody></table>
</div>
</div>
<h3 id="面向对象编程">面向对象编程</h3>

<hr/>

<h5 id="类">类</h5>

<p>account.lua</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tbody><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></pre></td>
<td class="lntd">
<pre class="chroma">local _M = {}

local mt = { __index = _M }

function _M.deposit (self, v)
    self.balance = self.balance + v
end

function _M.withdraw (self, v)
    if self.balance &gt; v then
        self.balance = self.balance - v
    else
        error(&#34;insufficient funds&#34;)
    end
end

function _M.new (self, balance)
    balance = balance or 0
    return setmetatable({balance = balance}, mt)
end

return _M</pre></td></tr></tbody></table>
</div>
</div>
<p>引用代码示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tbody><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></pre></td>
<td class="lntd">
<pre class="chroma">local account = require(&#34;account&#34;)

local a = account:new()
a:deposit(100)

local b = account:new()
b:deposit(50)

print(a.balance)  --&gt; output: 100
print(b.balance)  --&gt; output: 50</pre></td></tr></tbody></table>
</div>
</div>
<h5 id="继承">继承</h5>

<h5 id="判断为空">判断为空</h5>

<p>因此，我们要判断一个 table 是否为 {}，不能采用 #table == 0 的方式来判断。可以用下面这样的方法来判断：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tbody><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma"> function isTableEmpty(t)
    return t == nil or next(t) == nil
end</pre></td></tr></tbody></table>
</div>
</div>