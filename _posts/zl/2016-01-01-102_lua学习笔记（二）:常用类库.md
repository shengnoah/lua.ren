---
layout: post
title: lua学习笔记（二）:常用类库 
tags: [lua文章]
categories: [topic]
---
<blockquote>
  <p>很久没有玩lua了，和上次的小打小闹不同，这次要写一个更复杂的部署到真实环境的lua脚本</p>
</blockquote>

<h4 id="背景">背景</h4>

<p>最近遇到一个需求，用户扫描我们提供的二维码，如果是已经绑定过的用户，那么直接跳转到目标页面target.html，
如果用户为注册，那么需要根据携带的信息，为他绑定，然后跳转到target.html。</p>

<p>最初的想法当然是，二维码指向一个中间页面temp.html，在temp.hmtl里发送ajax请求查询用户是否绑定，如果已经绑定那么直接跳转到target.html，如果没有再发送一个绑定的ajax，最后跳转到target.html。</p>

<p>如我在<a href="/blog/2017/02/19/lua-learning-note-1/">lua学习笔记一</a>里提到的一样，这样会造成页面的二次刷新，会有长时间的白屏，对用户很不友好。</p>

<p>这次决定用lua实现这个功能，将查询用户是否绑定、绑定用户这两个请求放在lua里去处理，处理完成后直接返回一个302重定向，这样用户端感受不到页面刷新的。</p>

<p>在我们系统内，获取用户信息也是封装成的一个lua，因此流程大致是：</p>

<blockquote>
  <p>二维码 -&gt; 获取用户信息的lua -&gt; 判断是否绑定的lua -&gt; target.html</p>
</blockquote>

<p>为了实现这个功能，首先需要写的就是在lua里发送请求的功能，这里引入第一个类库：lua-resty-http</p>

<h4 id="lua-resty-http">lua-resty-http</h4>

<p><a href="https://github.com/pintsized/lua-resty-http">lua-resty-http的主页</a></p>

<p>先看一个小demo：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">http</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">&#34;resty.http&#34;</span><span class="p">)</span>
<span class="kd">local</span> <span class="k">function</span> <span class="nf">get_relation</span><span class="p">(</span><span class="n">encrypt_id</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s2">&#34;GET&#34;</span><span class="p">,</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">auth</span> <span class="o">=</span> <span class="n">encrypt_id</span>
        <span class="p">},</span>
        <span class="n">ssl_verify</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="s2">&#34;Content-Type&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;application/x-www-form-urlencoded&#34;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">local</span> <span class="n">res</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">new</span><span class="p">():</span><span class="n">request_uri</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">get_relation_addr</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span> <span class="ow">or</span> <span class="n">err</span> <span class="ow">or</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">status</span><span class="p">)</span> <span class="o">~=</span> <span class="s2">&#34;200&#34;</span> <span class="k">then</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="n">err</span> <span class="ow">or</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">status</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="kd">local</span> <span class="n">resbody</span> <span class="o">=</span> <span class="n">cjson</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">resbody</span><span class="p">.</span><span class="n">code</span> <span class="o">~=</span> <span class="s2">&#34;0&#34;</span> <span class="k">then</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">body</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">body</span>
<span class="k">end</span>
</code></pre></div></div>

<p>http.new()构建一个http对象，之后可以进行一些设置，如设置超时时间（set_timeout）等</p>

<p>常用的发送请求的api有request、request_uri</p>

<p>他们都需要提前准备好一个请求参数table
接受这些选项：</p>

<ul>
  <li>version: http协议的版本号，目前支持1.0或者1.1</li>
  <li>method:  请求类型，如get post put等</li>
  <li>path:    路径</li>
  <li>query:   我的理解是在x-www-form-urlencoded形式下这个字段才起作用，传递的是键值对形式的请求参数</li>
  <li>headers: 请求头，注意是table类型</li>
  <li>body:    请求体，String类型</li>
  <li>ssl_verify: https相关配置</li>
</ul>

<blockquote>
  <p>local res, err = http.new():request_uri(config.get_relation_addr, param)</p>
</blockquote>

<p>request_uri如果请求成功，则返回结果res，如果失败则res为nil，err为失败信息。</p>

<p>在res中包含以下信息</p>

<ul>
  <li>status: http状态码，如能让后端头疼死的502、500</li>
  <li>headers: response的header</li>
  <li>body: response的body，注意是string形式</li>
</ul>

<p>在写好两个请求过程后，我的lua脚本大致长这个样子：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="nc">_M</span><span class="p">.</span><span class="nf">redirect</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">local</span> <span class="n">userid</span> <span class="o">=</span> <span class="n">ngx</span><span class="p">.</span><span class="n">var</span><span class="p">.</span><span class="n">arg_userid</span>
    <span class="kd">local</span> <span class="n">exist_relation</span> <span class="o">=</span> <span class="n">get_relation</span><span class="p">(</span><span class="n">encrypt_openid</span><span class="p">)</span>  <span class="c1">--发送查询是否绑定请求</span>
    <span class="k">if</span> <span class="n">exist_relation</span> <span class="k">then</span>
        <span class="k">return</span> <span class="n">ngx</span><span class="p">.</span><span class="n">redirect</span><span class="p">(</span><span class="n">target_html</span><span class="p">,</span> <span class="n">ngx</span><span class="p">.</span><span class="n">HTTP_MOVED_TEMPORARILY</span><span class="p">)</span> <span class="c1">-- 302重定向</span>
    <span class="k">end</span>
    <span class="c1">-- 若未绑定</span>
    <span class="kd">local</span> <span class="n">user_info</span> <span class="o">=</span> <span class="n">get_user_info</span><span class="p">()</span>
    <span class="kd">local</span> <span class="n">bind_success</span> <span class="o">=</span> <span class="n">bind_relation</span><span class="p">(</span><span class="n">userid</span><span class="p">,</span> <span class="n">user_info</span><span class="p">)</span>  <span class="c1">--发送绑定请求</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bind_success</span> <span class="k">then</span>
        <span class="n">ngx</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&#34;can&#39;t bind relation&#34;</span><span class="p">)</span>
        <span class="n">ngx</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">502</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">ngx</span><span class="p">.</span><span class="n">redirect</span><span class="p">(</span><span class="n">target_html</span><span class="p">,</span> <span class="n">ngx</span><span class="p">.</span><span class="n">HTTP_MOVED_TEMPORARILY</span><span class="p">)</span>
    <span class="k">end</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在写完上述代码后，部署到服务器，以为已经万事大吉。哪料在真实环境中出现了意想不到的状况</p>

<p>上文提到过，需要先获取用户信息，然后跳转到我写的lua，获取用户信息这一块是调用的微信授权流程，因为种种原因，需要将二维码上携带的参数放置在微信回调的state参数内，但是微信对state参数的长度做了限制，最大为128字节，我们的业务逻辑需要的参数远远超过了这个长度，因此</p>

<blockquote>
  <p>获取用户信息的lua -&gt; 判断是否绑定的lua</p>
</blockquote>

<p>这一步就无法通过，绝望了。</p>

<hr/>

<p>经历短暂的慌张，很快理清思路：将过长的参数先存下来，到第二个lua中再捞出来</p>

<p>这又涉及到第二个问题：选用哪种缓存中间件呢？</p>

<p>可以使用ngx_lua模块中的共享内存ngx shared dict cache，但这个cache是nginx所有worker之间共享的，内部使用的LRU算法（最近经常使用）来判断缓存是否在内存占满时被清除。</p>

<p>当然，也可以使用redis</p>

<h4 id="lua-resty-reids">lua-resty-reids</h4>

<p><a href="https://github.com/openresty/lua-resty-redis">lua-resty-redis的主页</a></p>

<h4 id="lua-resty-lrucache">lua-resty-lrucache</h4>

<p><a href="https://github.com/openresty/lua-resty-lrucache">lua-resty-lrucache</a></p>



                <hr/>