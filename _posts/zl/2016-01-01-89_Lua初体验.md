---
layout: post
title: Lua初体验 
tags: [lua文章]
categories: [topic]
---
<h2 id="背景">背景</h2>

<p>项目中后期需要支持热更新，因此只能把之前基于UGUI的C#外围逻辑全部修改为Lua，修改过程中的方案是做一个兼容处理，新逻辑用Lua，并在项目推进过程中逐步把外围都改为Lua编码。</p>

<h2 id="项目中的接入实践">项目中的接入实践</h2>

<h3 id="工程目录结构">工程目录结构</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XFramework/lua          -- C#端脚本根目录
------------------------------------------------------
luaScripts              -- Lua端脚本根目录
├── api                 -- 用于写代码时只能提示Api信息
├── cfg_sheet           -- 本地配置表对应的代码
├── common              -- 核心常用代码
├── libs                -- 第三方库 例如 protobuf,cjson...
├── proto               -- 协议对应代码
├── service             -- 数据层服务代码
├── ui                  -- UI代码
├── Global.lua          -- 集中管理和C#层交互的地方
└── LuaDebug.lua        -- 调试器
</code></pre></div></div>

<h3 id="核心代码库">核心代码库</h3>

<h4 id="c端">C#端</h4>
<ol>
  <li><code class="highlighter-rouge">LuaHelper.cs</code> Lua的启动脚本并传递各种游戏状态事件。</li>
  <li><code class="highlighter-rouge">LuaStrHelper.cs</code> Lua有部分字符串实现暂时没有找到Lua版本的，还包括C#的字符串格式化逻辑的转接，用以兼容现有配置。</li>
  <li><code class="highlighter-rouge">LuaMsgHelper.cs</code> 既然是兼容方案，那么socket只能直接获取现有的C#端实例来中转。这里有一个待解决的问题，是Lua到C#的传参过程，并没有找到方便的传输<code class="highlighter-rouge">byte[]</code>的方法。临时使用了tolua示例中的<code class="highlighter-rouge">LuaByteBuffer</code>。</li>
  <li><code class="highlighter-rouge">LuaResHelper.cs</code> 资源的操作中转类，目前只加了<code class="highlighter-rouge">PlayerPrefs</code>，用到再添加。</li>
  <li><code class="highlighter-rouge">LuaUIHelper.cs</code> UI中转类，打开关闭窗口等，因为之前的C#端用到了大量泛型，并不方便直接提供<code class="highlighter-rouge">UIManager</code>，所以这里短期内是会一直使用的。</li>
  <li><code class="highlighter-rouge">LuaObsoleteHelper.cs</code> 这是一个终将会废弃的类，把一些暂时没有办法处理的中转逻辑都集中到这个类中，以后逐个修改到Lua端实现，最终完全删除该类。
    <h4 id="lua端">Lua端</h4>
  </li>
  <li><code class="highlighter-rouge">Global.lua</code> Lua端的入口代码，与C#端直接交互（仅此一个）。</li>
  <li><code class="highlighter-rouge">Common/SandBox.lua</code> 利用子类沙盒模式，给<code class="highlighter-rouge">Service.lua</code>和<code class="highlighter-rouge">UIView.lua</code>提供一系列的基本操作，把代码中大量的全局变量调用集中到这个基类中，降低耦合度，同时方便维护。</li>
  <li><code class="highlighter-rouge">Common/Service.lua</code>, <code class="highlighter-rouge">Common/ServiceManager.lua</code> 这两个类就是UI框架设计中提到的数据层的两个基础类了。</li>
  <li><code class="highlighter-rouge">Common/UIView.lua</code> 是所有UI窗口和视图的基类。封装一系列简化操作的窗口API,分为获取组件、设置组件事件、属性绑定与自动解绑、窗口事件，以及一些常用的UI层操作。</li>
  <li><code class="highlighter-rouge">Common/UIPath.lua</code> 这里是UI的资源路径字典，规范应该保证的是资源和代码同名，这样会减少后续维护的麻烦。</li>
  <li><code class="highlighter-rouge">Common/XPlayerPrefs.lua</code> 本地的一个数据缓存。</li>
  <li><code class="highlighter-rouge">Common/XProperty.lua</code>,<code class="highlighter-rouge">Common/XListProperty.lua</code> mvp架构的核心思想，单项数据绑定。</li>
  <li><code class="highlighter-rouge">Common/ConfigReader.lua</code> 本地配置表的读取类，支持两种读取方式，数组和字典。</li>
  <li><code class="highlighter-rouge">Common/Collections/XList.lua</code> 一个基本的list实现，内部是一个数组，未采用链表的形式是处于性能考虑。</li>
</ol>

<h3 id="还未执行的工作">还未执行的工作</h3>
<ol>
  <li>生成获取组件的代码</li>
  <li>自动拦截替换现有的C#端实现</li>
  <li>代码模板</li>
</ol>

<h3 id="待探讨的做法">待探讨的做法</h3>
<ol>
  <li>class
目前大众一点的面向对象思路一共有三种。一种是metatable直接来（项目中目前就是如此，缺点是如果继承层级过多会有额外的metatable开销）。二是copy父类方法到子类中。三是执行时copy（参考云风的blog）。</li>
  <li>配置表
目前参考了一些市面上的项目方案，直接将配置表导出成对应的代码。需要讨论的有两个点，一是解析配置表好还是直接就是代码好。二是代码中的重复关键词如何消除，目前考虑可以使用数组+metatable实现，还没有动手。</li>
  <li>协议
目前协议使用了<code class="highlighter-rouge">tolua</code>自带的<code class="highlighter-rouge">proto-gen-lua</code>，缺陷是不支持<code class="highlighter-rouge">[packed=true]</code>字段，该字段可以减少列表长度n的字段 (n - 1) * 8bit的数据量。</li>
  <li>全局变量
全局变量是否有额外的开销，开销是多少目前我还不是很清楚。因此，<code class="highlighter-rouge">UIView</code>等是否使用全局变量还需要进一步了解。</li>
</ol>

<h3 id="经验技巧">经验技巧</h3>
<ol>
  <li>显示子视图时，需要判断该视图是一个全局的还是一个独立的实例
    <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">-- 显示顶部菜单中的货币视图 因为各个界面都有该类，那么其应该是一个单独的实例 所以需要调用 new() 方法</span>
 <span class="n">self</span><span class="p">:</span><span class="n">showView</span><span class="p">(</span><span class="n">CommonTopView_Coins</span><span class="p">:</span><span class="n">new</span><span class="p">(),</span> <span class="n">self</span><span class="p">.</span><span class="n">mContextCoin</span><span class="p">)</span>

 <span class="c1">-- 邮件详情界面这里就只有一个全局的实例了 并不需要也不应该去 new()</span>
 <span class="kd">local</span> <span class="n">content</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="n">UIPath</span><span class="p">.</span><span class="n">MailWindow_ContentView</span><span class="p">)</span>
 <span class="n">content</span><span class="p">.</span><span class="n">selectedMail</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">selectedMail</span> 
 <span class="n">self</span><span class="p">:</span><span class="n">showView</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">mUIContext_mail_content_not_empty_6</span><span class="p">)</span>

 <span class="c1">-- 列表的显示每个子视图都是独立的实例 这里需要注意的是传参的方式 列表会有一个特殊字段 prefab 需要赋值</span>
 <span class="kd">local</span> <span class="n">list</span> <span class="o">=</span> <span class="n">XList</span><span class="p">:</span><span class="n">new</span><span class="p">()</span>
 <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">item</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="k">do</span>
     <span class="c1">--@RefType [ui.Common.CommonItemView#CommonItemView]</span>
     <span class="kd">local</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">CommonItemViewPrefab</span><span class="p">:</span><span class="n">new</span><span class="p">()</span>
     <span class="n">cell</span><span class="p">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">item</span>
     <span class="n">cell</span><span class="p">.</span><span class="n">couldClick</span> <span class="o">=</span> <span class="kc">true</span>
     <span class="n">cell</span><span class="p">.</span><span class="n">prefab</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">lstCell</span>
     <span class="n">list</span><span class="p">:</span><span class="n">add</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
 <span class="k">end</span>

 <span class="n">self</span><span class="p">.</span><span class="n">lstContainer</span><span class="p">:</span><span class="n">setLuaDatas</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
 <span class="n">self</span><span class="p">.</span><span class="n">lstContainer</span><span class="p">:</span><span class="n">display</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>代码提示的功能添加
    <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">-- 最常用的应该这个引用标签了，这里直接声明了cfg变量的类型是对应配置表，方便写代码</span>
 <span class="c1">--@RefType [cfg_sheet.common_config.t_item_config#t_item_config]</span>
 <span class="n">Item</span><span class="p">.</span><span class="n">cfg</span> <span class="o">=</span> <span class="kc">nil</span>

 <span class="c1">-- 这里同时指定了参数类型和返回值类型，方便调用</span>
 <span class="c1">-- 获取指定id的道具信息</span>
 <span class="c1">--@itemId: 道具ID</span>
 <span class="c1">--@return [api.Item#Item]</span>
 <span class="k">function</span> <span class="nf">BagService</span><span class="p">:</span><span class="n">getItem</span><span class="p">(</span><span class="n">itemId</span><span class="p">)</span>
     <span class="kd">local</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">itemId</span><span class="p">]</span>
     <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="k">then</span>
         <span class="nb">print</span><span class="p">(</span><span class="nb">string.format</span><span class="p">(</span><span class="s2">&#34;道具错误 %d =&gt; 找玥祺&amp;海哥&#34;</span><span class="p">,</span> <span class="n">itemId</span><span class="p">))</span>
     <span class="k">end</span>
     <span class="k">return</span> <span class="n">ret</span>
 <span class="k">end</span>
</code></pre></div>    </div>
  </li>
  <li>Public or Private 函数
    <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">local</span> <span class="n">M</span> <span class="o">=</span> <span class="n">BagService</span>
 <span class="c1">-- 外部会调用的逻辑直接用全局名称,这样写代码会有智能提示</span>
 <span class="c1">-- 出售道具</span>
 <span class="k">function</span> <span class="nf">BagService</span><span class="p">:</span><span class="n">C2SSellItem</span><span class="p">(</span><span class="n">itemId</span><span class="p">,</span> <span class="n">itemNum</span><span class="p">)</span>
     <span class="kd">local</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">MsgStruct</span><span class="p">:</span><span class="n">C2SSellItem</span><span class="p">()</span>
     <span class="n">msg</span><span class="p">.</span><span class="n">itemID</span> <span class="o">=</span> <span class="n">itemId</span>
     <span class="n">msg</span><span class="p">.</span><span class="n">itemNum</span> <span class="o">=</span> <span class="n">itemNum</span>
     <span class="n">self</span><span class="p">:</span><span class="n">sendMain</span><span class="p">(</span><span class="n">NetMsgId</span><span class="p">.</span><span class="n">C2SSellItem</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
 <span class="k">end</span>

 <span class="c1">-- 内部函数就用M打头，外部没有提示</span>
 <span class="c1">-- 出售道具</span>
 <span class="k">function</span> <span class="nf">M</span><span class="p">:</span><span class="n">S2CSellItem</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
     <span class="n">self</span><span class="p">:</span><span class="n">showErrorCode</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">ret</span><span class="p">)</span>
 <span class="k">end</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="项目规范">项目规范</h3>
<ol>
  <li>所有的变量，添加详细的注释，可以是英文</li>
  <li>类型名称的每个单词首字母均大写</li>
  <li>变量名和函数名均小写字母开头</li>
  <li>常量名全大写或者k字母开头并在注释中声明</li>
  <li>窗口代码和资源名称要匹配</li>
  <li>窗口以<code class="highlighter-rouge">Window</code>,视图以<code class="highlighter-rouge">View</code>为后缀方便区分</li>
  <li>一些公共的数据结构，到<code class="highlighter-rouge">api</code>目录下创建对应的接口提示 like <code class="highlighter-rouge">Item</code></li>
  <li>一些常用的数据，和方法，要是用标签指定其对应参数和返回值类型，方便大家写代码</li>
  <li>方法一定要注意<code class="highlighter-rouge">:</code>和<code class="highlighter-rouge">.</code>的区别，尽量少用<code class="highlighter-rouge">.</code>减少全局变量的调用，并且保持一致的<code class="highlighter-rouge">:</code>风格</li>
</ol>