---
layout: post
title: 情迁QQ机器人新功能可使用lua脚本编写机器人插件啦 · 情迁美好时光追忆 
tags: [lua文章]
categories: [topic]
---
本文将详细介绍Lua机器人插件的使用方法，更详细的内容也可以参考简书哦!机器人1.9.0支持lua插件加载，支持手机端lua编写插件
机器人内置lua编辑器，可以测试，运行机器人功能，  
lua是一种脚本语言，解释运行，随意修改，无需编译，便于修改和分享，操作简单，开发成本低，传播更方便。

本文章转载自情迁简书 <https://www.jianshu.com/p/92c7bf329653>

### 说明

目前支持机器人lua插件在2018年11月17日发布了，各位记得先情迁下载QQ机器人哈

本文章会慢慢补充,lua机器人插件能力将在情迁QQ机器人 1.8.8以及以上版本体现.

### 安装目录

新建lua文件 也即是

    
    
    1  
    2  
    3  
    

|

    
    
    ### LUA语法介绍  
    不懂lua语法的可以百度一下,  这里大概介绍一下基本的lua语法也就是和其它语言不相同的地方。  
    字符串拼接用```..```  数字转文本用```tostring(要转换的变量)  
      
  
---|---  
  
**方法定义**  
参数名 没有类型,这是脚本语言的特点,简单的不能再简单，如js,python php

    
    
    1  
    2  
    3  
    

|

    
    
    function 方法名(参数名)  
      
    end  
      
  
---|---  
  
有返回值的方法

    
    
    1  
    2  
    3  
    

|

    
    
    function 方法名(参数名)  
    return true;  
    end  
      
  
---|---  
  
**调用对象方法**

这里使用```:```而java是用```.```

    
    
    1  
    2  
    3  
    4  
    

|

    
    
    **访问对象字段**  
    输入```log(robot.name))``` 这是本机器人支持的访问举例.  
    **注释**  
    lua的注释是用 ```--``` 而java是用```//``` 易语言则用```’```  或者某些语言用```#``` bat 批处理用 ```::  
      
  
---|---  
  
**类型转换**  
字符串转number

    
    
    1  
    2  
    3  
    

|

    
    
    str="333"  
    value=tonumber(str)  
    value=value+1    
      
  
---|---  
  
其他类型转字符串

    
    
    1  
    2  
    

|

    
    
    obj=333  
    value=tostring(obj)  
      
  
---|---  
  
**变量定义**

    
    
    1  
    2  
    

|

    
    
    global_var = 1 --全局变量  
    local temp_var = 2 --局部变量  
      
  
---|---  
  
**循环**

    
    
    1  
    2  
    3  
    4  
    

|

    
    
    while (temp < 5) do  
        temp = temp + 1  
        print("result:" .. tostring(temp)) --这里体现了类型转换的语法。  
    end  
      
  
---|---  
      
    
    1  
    2  
    3  
    

|

    
    
    for i = 1, 3 do  
        print("从1 到 3,当前:" .. tostring(i))  
    end  
      
  
---|---  
      
    
    1  
    2  
    3  
    

|

    
    
    for i = 1, 6, 2 do  
        print("高级用法 当前:" .. tostring(i) .. ",我每下次执行将跳动2次，如果当前为1那么为1,下次则为3，i>6跳出循环")  
    end  
      
  
---|---  
  
**逻辑分支**

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    

|

    
    
    if (value1 > 10) then  
        print("值大于10")  
        if (value1 == 80) then  
            print("内循环,等于80")  
        else  
            print("不是80，但是肯定>10")  
        end  
    elseif (value1 == 100) then  
        print("等于100")  
    else  
        print("不知道等于夺嫂了")  
    end  
      
  
---|---  
  
控制台输出

    
    
    1  
    2  
    

|

    
    
    print("ffff") --lua本身的语法，这个需要打开adb.exe查看过滤  
    System.out日志类型  
      
  
---|---  
  
### 情迁QQ机器人SDK独有api参数

 **第一步/必须导包**  
如果不导包，将无法正常使用下面这些方法。博客语法有冲突，勿怪。下面的这行

    
    
    require "cn.qssq666.robot.sdk"

日志提示

    
    
    log(""警告日志")--输出警告日志
    info("info日志")
    debug("debug日志")
    error("红色错误日志")
    toast("toast提示日志")``这个运行后直接弹出气泡提示

 _lua掌握这一点点你就完全可以操作机器人大部分功能了 关于api方面呢其实和java doc api一样的，所以呢本文没有说明的方法完全可以举一反三的
从java 插件开发文档里面找到_

**收到消息的回调**

    
    
    1  
    2  
    3  
    

|

    
    
    function onReceiveMsgIsNeedIntercept(msgitem, aiteList, hasAite, hasAiteMe)  
      
    end  
      
  
---|---  
  
**发送消息给指定人**  
这里的item是必须的，这个函数应该在

    
    
    1  
    2  
    3  
    4  
    5  
    

|

    
    
      
      
      
    ```   
    api. sendPrivateMsg(item, qq,message);  
      
  
---|---  
  
更多api,完全可以参考java api推算出来，我有空会写一个完整的demo,现在还在架构机器人中….

### 举例

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    

|

    
    
    require "cn.qssq666.robot.sdk"  
      
    --  msgitem 消息体  
    -- aitelist 艾特的用户列表（不会包含自己)  
    -- hasAite 是否艾特了用户  
    -- hasAiteMe  是否艾特了机器人  
      
    function onReceiveMsgIsNeedIntercept(msgitem, aiteList, hasAite, hasAiteMe)  
    	log("call onReceiveMsgIsNeedIntercept")  
    	text = msgitem:getMessage() --获取收到的消息内容  
    	log("receiveMsg:" .. text)  
    	qq = msgitem:getSenderuin() -- 哪个qq发的消息  
    	log("print toString[" .. msgitem:toString()) --这个方法可以打印昵称,qq,消息内容,发送时间,等等。  
      
    	info = ",aiteUser=," .. tostring(hasAite) .. ",aiteRobot:" .. tostring(hasAiteMe)  
    	 --见名知意  
    	log("state:" .. info)  
    	return true  
    end  
      
    --下面的代码无关紧要，自己酌情修改------------------------------  
    function onCreate(obj)  
    	log("onCreate call arg type: " .. type(obj))  
    end  
      
    function getPluginName()  
    	return "test plugin"  
    end  
      
    function onDestory()  
    	log("destory call")  
    end  
      
  
---|---  
  
再来一个能用的，发送消息`LUA`就会自动回复的机器人插件  
复制下面的内容另存为 任意名.lua文件然后放到内部存储的qssq666/robot_plugin_lua文件夹中，然后运行情迁QQ机器人1.9.0  
然后进入LUA插件管理就可以看到机器人了，记得进入机器人设置勾选启用机器人插件哦，不然发送消息`LUA`没有任何反应的哈  
还可以长按编辑这个插件修改逻辑，也可以点击模拟测试一些机器人方法是否定义的情况。

    
    
    -- 编写时间 2018.11
    -- 文件编码 必须是UTF-8 must UTF-8
    -- LUA插件的方法不受执行流程控制,因此测试这些代码的时候只能发送消息然后测试这些方法。
    --或者可以不写在主流程中，比如如下代码的测试专用可以解除注释，当机器人加载的时候会气泡提示的toast调试，
    
    
    require "cn.qssq666.robot.sdk" --必须调用，否则无法使用api,等方法，以及toast等，只能使用print了。
    --测试专用代码区开始 
    
    --可以直接运行 本文件放到内部存储 qssq666/robot_plugin_lua文件夹改后缀名 为.lua 然后在lua插件管理列表刷新然后长按运行或者编辑再运行。
    -- 直接输入 adb push plugin.lua /sdcard/qssq666/robot_plugin_lua/ 推送到手机上。
    
    
    
    
    --toast("插件被加载，插件名:"..getPluginName())
    --下面的调试代码需要通过日志查看软件或者电脑ADBConsole.exe查看。
    --info("插件加载了,")
    --warn("这是警告日志")
    --error("红色错误日志")
    --log("也是警告日志语法糖")
    --debug("调试信息，")
    
    --测试专用代码区结束
    
    --  ---------------------机器人插件加载区
    --  msgitem 消息体
    -- aitelist 艾特的用户列表（不会包含自己)
    -- hasAite 是否艾特了用户
    -- hasAiteMe  是否艾特了机器人
    --收到一条消息调用此方法，返回true表示 消息由插件处理
    --，否则交给机器人自身的逻辑，比如自身有点歌系统之类的。
    --本方法不定义将毫无意义。
    function onReceiveMsgIsNeedIntercept(msgitem, aiteList, hasAite, hasAiteMe)
        log("call onReceiveMsgIsNeedIntercept")
       local text = msgitem:getMessage() --获取收到的消息内容
        log("receiveMsg:" .. text)
        local qq = msgitem:getSenderuin() -- 哪个qq发的消息
        log("print toString[" .. msgitem:toString()) --这个方法可以打印昵称,qq,消息内容,发送时间,等等。
        if (text == "LUA") then
            -- chunkname:41 attempt to index ? (a nil value) zhaobu
            local str="Wellcome Use Lua Plugin! The is QssqRobot"
            msgitem:setMessage(str)
            print("item is nil?="..tostring(msgitem:getClass()==nil)..",className:"..tostring(msgitem:getClass()))
            print("api obj is nil?="..tostring(msgitem:getClass()==nil)..",className:"..tostring(api:getClass()))
            print(api:toString())
            api:showDebugToast("欢迎使用LUA机器人插件");
            -- print();
            -- print(msgitem:toString())
            api:sendMsg(msgitem) --是啥子消息我就回复啥消息 ，操作起来比较简单。
            return true
         --插件自身处理消息
        else
        end
        info = ",aiteUser=," .. tostring(hasAite) .. ",aiteRobot:" .. tostring(hasAiteMe)
        --见名知意
        log("state:" .. info)
        return false
    end
    
    --下面的代码无关紧要，自己酌情修改 ,可以不定义，------------------------------
    --插件被加载的时候出发
    function onCreate(obj)
        print("onCreate....[print]")
        log("onCreate call arg type: " .. type(obj))
    end
    --表示机器人最终处理的消息，即将发送的消息，是否拦截
    function onReceiveRobotFinalCallMsgIsNeedIntercept(item, list, aite, haisaiteme)
        debug("call onReceiveRobotFinalCallMsgIsNeedIntercept..");
        return false
    end
    --插件作者名字 
    function getAuthorName()
        return "情迁2018"
    end
    --返回插件名称，再插件管理列表可以显示
    function getPluginName()
        return "test plugin"
    end
    
    --返回本插件的版本号 
    function getVersionName()
        return "1.0" --返回机器人的版本号
    end
    --返回本插件的版本号 数字标识 整数
    function getVersionCode()
        return 1;
    end
    --返回编译时间字符串
    function getBuildTime( )
        -- body
        return "无"
    end
    
    
    --返回插件的描述信息
    function getDescript()
        return "这是一个DEMO"
    end
    -- 返回插件demo包名
    function getPackageName()
        return "cn.qssq666.lua.plugindemo"
    end
    --即将被销毁调用的方法。
    function onDestory()
        log("destory call")
    end