---
layout: post
title: lua 元表学习 
tags: [lua文章]
categories: [topic]
---
<p>Lua 中的每个值都有一个元表。table 和 userdata 可以有各自独立的原表，其他类型的值则共享其类型所属的单一元素。Lua 在创建新的 table 的时候不会创建元表。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = {}</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t)) </span><br></pre></td></tr></table></figure>
<p>可以使用 setmetatable 来修改或设置 table 的元表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = {}</span><br><span class="line"><span class="built_in">setmetatable</span>(t,t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(t)) </span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="http://renchunxiao.com/#%E4%BE%8B%E5%AD%90" class="headerlink" title="例子"></a>例子</h2><p>假设用 table 来表示集合，并且有一些函数来计算集合的交集和并集。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Set = {}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> set = {}</span><br><span class="line">    <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    	set[v] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span></span></span><br><span class="line">	<span class="keyword">local</span> res = Set.new{}</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    	res[v] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">pairs</span>(b) <span class="keyword">do</span></span><br><span class="line">    	res[v] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 集合的交集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.intersection</span><span class="params">(a, b)</span></span></span><br><span class="line">	<span class="keyword">local</span> res = Set.new{}</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    	res[k] = b[k] <span class="comment">-- 在 b 集合当中不存在会返回 nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.tostring</span><span class="params">(set)</span></span></span><br><span class="line">	<span class="keyword">local</span> t = {}</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">pairs</span>(set) <span class="keyword">do</span></span><br><span class="line">    	t[#t + <span class="number">1</span>] = v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"{"</span> .. <span class="built_in">table</span>.<span class="built_in">concat</span>(t, <span class="string">","</span>) .. <span class="string">"}"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.print</span><span class="params">(s)</span></span></span><br><span class="line">	<span class="built_in">print</span>(Set.<span class="built_in">tostring</span>(s))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果我们让 Set 可以使用 + 来进行集合的并集操作，那么我们需要把所有用于表示集合的 table 共享一个元表。代码修改如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = {}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.new</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> set = {}</span><br><span class="line">    <span class="built_in">setmetatable</span>(set, mt)</span><br><span class="line">    <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        set[v] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后给元表添加方法，元方法 __add 是用于描述如何完成加法的。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__add</span> = Set.union</span><br></pre></td></tr></table></figure>
<p>然后测试下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s1 = Set.new{<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>}</span><br><span class="line"><span class="keyword">local</span> s2 = Set.new{<span class="number">40</span>,<span class="number">20</span>,<span class="number">30</span>}</span><br><span class="line"><span class="keyword">local</span> s3 = s1 + s2</span><br><span class="line">Set.<span class="built_in">print</span>(s3) <span class="comment">--&gt; {30,10,20,40}</span></span><br></pre></td></tr></table></figure>
<p>还可以把 * 设置成交集：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__mul</span> = Set.intersection</span><br></pre></td></tr></table></figure>
<p>在元表当中还有其他的方法：</p>
<p>__sub：减法</p>
<p>__div：除法</p>
<p>__unm：相反数</p>
<p>__mod：取模</p>
<p>__pow：乘幂</p>
<p>当两个集合相加，可以使用任意一个集合的元表，然而，当一个表达式中混合了具有不同元表的表达式，例如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Set.new{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">s = s + <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>Lua 会按照如下步骤查找元表，如果第一个值有元表，并且元表中有 __add 字段，那么 Lua 就以这个字段为元方法，而与第二个值无关。如果第一个没有，而第二个有就以第二个为准。如果两个都没有元方法，Lua 就会报错。</p>
<h2 id="关系类的元方法"><a href="http://renchunxiao.com/#%E5%85%B3%E7%B3%BB%E7%B1%BB%E7%9A%84%E5%85%83%E6%96%B9%E6%B3%95" class="headerlink" title="关系类的元方法"></a>关系类的元方法</h2><p>元方法还有 <strong>eq（等于）、</strong>lt（小于）、__le（小于等于）。</p>
<p>与算术元方法不一样的是，关系类的元方法不能用在混合的类型当中。如果将一个字符串与一个数字作顺序比较，Lua 会报错。同样，如果试图比较两个具有不相同元方法的对象，那么 Lua 也报错。</p>
<p>等于比较不会引发错误。但是如果两个对象有不同的元方法，那么等于操作不会调用任何一个元方法，而是直接返回 false。</p>
<h2 id="库定义元方法"><a href="http://renchunxiao.com/#%E5%BA%93%E5%AE%9A%E4%B9%89%E5%85%83%E6%96%B9%E6%B3%95" class="headerlink" title="库定义元方法"></a>库定义元方法</h2><p>在进程库当中会定义自己的元表字段。函数 tostring 是一个例子，在 print 的时候，会默认调用 tostring 类格式化其输出。</p>
<p>所以上面的例子也可以修改：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__tostring</span> = Set.<span class="built_in">tostring</span></span><br><span class="line"><span class="keyword">local</span> s1 = Set.new{<span class="number">1</span>,<span class="number">4</span>, <span class="number">2</span>}</span><br><span class="line"><span class="built_in">print</span>(s1) <span class="comment">--&gt; {1,4,2}</span></span><br></pre></td></tr></table></figure>
<p>函数 setmetatable 和 getmetatable 也会用到元表当中的一个字段，用于保护元表。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt.<span class="built_in">__metatable</span> = <span class="string">'not your business'</span></span><br></pre></td></tr></table></figure>
<p>如上设置后就不可以 setmetatable，并且 getmetatable 会返回设置的字符串。</p>
<h2 id="table-访问的元方法"><a href="http://renchunxiao.com/#table-%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%83%E6%96%B9%E6%B3%95" class="headerlink" title="table 访问的元方法"></a>table 访问的元方法</h2><h3 id="index-元方法"><a href="http://renchunxiao.com/#index-%E5%85%83%E6%96%B9%E6%B3%95" class="headerlink" title="__index 元方法"></a>__index 元方法</h3><p>当访问一个 table 当中不存在的字段时候，会返回 nil。如果我们设置了 table 的元表的 __index 方法，那么就会由这个方法提供最终的结果。</p>
<p>例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Window = {}</span><br><span class="line">Window.prototype = {x=<span class="number">0</span>,y=<span class="number">0</span>,width=<span class="number">100</span>,height=<span class="number">100</span>}</span><br><span class="line">Window.mt = {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Window.new</span><span class="params">(o)</span></span></span><br><span class="line">	<span class="built_in">setmetatable</span>(o, Window.mt)</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Window.mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, key)</span></span></span><br><span class="line">	<span class="keyword">return</span> Window.prototype[key]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">w = Window.new{x=<span class="number">10</span>,y =<span class="number">20</span>}</span><br><span class="line"><span class="built_in">print</span>(w.width) <span class="comment">--&gt; 100</span></span><br></pre></td></tr></table></figure>
<p>当 Lua 检测到 w 中没有某个字段，并且在元表中有一个 <strong>index 字段，那么 Lua 就会以 w(table) 和 width(不存在的 key) 来调用这个 </strong>index 方法。</p>
<p>__index 元方法不一定是一个函数，也可以是一个 table，所以前面的例子可以修改成如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Window.mt.<span class="built_in">__index</span> = Window.prototype</span><br></pre></td></tr></table></figure>
<p>现在就是如果 Lua 查找到元表的 __index 是一个 table，那么 Lua 就会在这个 table 中继续查找。</p>
<h3 id="newindex-元方法"><a href="http://renchunxiao.com/#newindex-%E5%85%83%E6%96%B9%E6%B3%95" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h3><p><strong>newindex 元方法是用在赋值的，当对一个 table 当中不存在的索引赋值时，解释器会找到 </strong>newindex 方法，如果有就执行，而不执行赋值操作。如果这个元方法是个 table，那么解释器就在此 table 上赋值，而不是原来的 table。</p>
<h3 id="具有默认值的-table"><a href="http://renchunxiao.com/#%E5%85%B7%E6%9C%89%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84-table" class="headerlink" title="具有默认值的 table"></a>具有默认值的 table</h3><p>普通的 table 任何字段的默认值都是 nil。也可以通过元表来修改这个默认值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDefault</span><span class="params">(table, value)</span></span></span><br><span class="line">	<span class="keyword">local</span> mt = {<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> retuen value <span class="keyword">end</span>}</span><br><span class="line">    <span class="built_in">setmetatable</span>(<span class="built_in">table</span>, mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tab = {x=<span class="number">10</span>, y=<span class="number">20</span>}</span><br><span class="line"><span class="built_in">print</span>(tab.x, tab.z) <span class="comment">--&gt; 10   nil</span></span><br><span class="line">setDefault(tab, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(tab.x, tab.z) <span class="comment">--&gt; 10   0</span></span><br></pre></td></tr></table></figure>
<h3 id="只读-table-的实现"><a href="http://renchunxiao.com/#%E5%8F%AA%E8%AF%BB-table-%E7%9A%84%E5%AE%9E%E7%8E%B0" class="headerlink" title="只读 table 的实现"></a>只读 table 的实现</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readOnly</span><span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> proxy = {}</span><br><span class="line">    <span class="keyword">local</span> mt = {</span><br><span class="line">    	<span class="built_in">__index</span> = t,</span><br><span class="line">        <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t, k, v)</span></span></span><br><span class="line">        	<span class="built_in">error</span>(<span class="string">"this is a readonly table"</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">setmetatable</span>(proxy, mt)</span><br><span class="line">   	<span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>【参考资料】</p>
<ol>
<li><a href="http://book.douban.com/subject/3076942/" target="_blank" rel="noopener noreferrer">Lua进程设计</a></li>
</ol>
<p>—EOF—</p>