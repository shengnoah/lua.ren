---
layout: post
title: Lua源码阅读：基本数据类型String 
tags: [lua文章]
categories: [topic]
---
<p>Lua中对于String的实现。</p>

<p>Lua使用TString结构体代表一个字符串对象。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line"><span class="comment">** Header for string value; string bytes follow the end of this structure</span></span><br/><span class="line"><span class="comment">** (aligned according to &#39;UTString&#39;; see next).</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  {</span></span><br/><span class="line">  CommonHeader;</span><br/><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; &#34;has hash&#34; for longs */</span></span><br/><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;</span><br/><span class="line">  <span class="keyword">size_t</span> len;  <span class="comment">/* number of characters in string */</span></span><br/><span class="line">  <span class="class"><span class="keyword">struct</span>  *<span class="title">hnext</span>;</span>  <span class="comment">/* linked list for hash table */</span></span><br/><span class="line">} TString;</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="comment">** Ensures that address after this type is always fully aligned.</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> UTString {</span><br/><span class="line">  L_Umaxalign dummy;  <span class="comment">/* ensures maximum alignment for strings 用于最大字节对齐 */</span></span><br/><span class="line">  TString tsv;</span><br/><span class="line">} UTString;</span><br/></pre></td></tr></tbody></table></figure>
<p>hash用来记录字符串对应的哈希值，len用来记录字符串的长度。</p>
<p>在Lua中，分为长字符串和短字符串，长度大于40的是长字符串，小于40的是短字符串，这部分在luaconf.h中定义：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line"><span class="comment">@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,</span></span><br/><span class="line"><span class="comment">** strings that are internalized. (Cannot be smaller than reserved words</span></span><br/><span class="line"><span class="comment">** or tags for metamethods, as these strings must be internalized;</span></span><br/><span class="line"><span class="comment">** #(&#34;function&#34;) = 8, #(&#34;__newindex&#34;) = 10.)</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"></span><br/></pre></td></tr></tbody></table></figure>
<p>对于短字符串，在实际使用中一般用来作为索引或需要进行字符串比较，存放在global_State-&gt;strt中，这个字符串表（strt）是一个stringtable类型的全局唯一的哈希表，当需要创建一个短字符串对象时，会首先在这个表中查找已有对象。所有的短字符串都是全局唯一的，不会存在两个相同的短字符串对象，如果短字符串对象的extra&gt;0，表示这是一个系统保留的字符串；长字符串一般用来存放文本数据，很少需要比较或者索引，所以长字符串被挂接到allgc链表上当作普通的对象来处理。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line"><span class="comment">** new string (with explicit length) 生成新字符串的函数</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="function">TString *<span class="title">luaS_newlstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>{</span><br/><span class="line">  <span class="keyword">if</span> (l &lt;= LUAI_MAXSHORTLEN)  <span class="comment">/* short string? */</span></span><br/><span class="line">    <span class="keyword">return</span> internshrstr(L, str, l);</span><br/><span class="line">  <span class="keyword">else</span> {</span><br/><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt; (MAX_SIZE - <span class="keyword">sizeof</span>(TString))/<span class="keyword">sizeof</span>(<span class="keyword">char</span>))</span><br/><span class="line">      luaM_toobig(L);</span><br/><span class="line">    <span class="keyword">return</span> createstrobj(L, str, l, LUA_TLNGSTR, G(L)-&gt;seed);</span><br/><span class="line">  }</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">/* 在global_State中存储的哈希表结构体 */</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringtable</span> {</span></span><br/><span class="line">  TString **hash;</span><br/><span class="line">  <span class="keyword">int</span> nuse;  <span class="comment">/* number of elements  已装元素的个数 */</span></span><br/><span class="line">  <span class="keyword">int</span> size;	<span class="comment">/* 实际hash桶的大小 */</span></span><br/><span class="line">} stringtable;</span><br/></pre></td></tr></tbody></table></figure>
<p>对于短字符串，在创建的时候，首先计算str的哈希值。计算时会得到一个随机种子，这个种子就是global_State-&gt;seed，然后通过LUAI_HASHLIMIT控制步长，每一个步长范围内取字符串中的一个字符，和上次hash的结果相加，得到新的hash结果，计算出hash后，开始找是否存在这个字符串，方法是遍历global_State-&gt;strt-&gt;hash，短字符串表申请内存的大小和实际使用大小由后两个字段表示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line"><span class="comment">** checks whether short string exists and reuses it or creates a new one</span></span><br/><span class="line"><span class="comment">** 检查短字符串的存在性，根据结果重用已存在的字符串或创建一个新的字符串</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="function"><span class="keyword">static</span> TString *<span class="title">internshrstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>{</span><br/><span class="line">  TString *ts;</span><br/><span class="line">  global_State *g = G(L);</span><br/><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br/><span class="line">  TString **<span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];</span><br/><span class="line">  <span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;hnext) {</span><br/><span class="line">    <span class="keyword">if</span> (l == ts-&gt;len &amp;&amp;</span><br/><span class="line">        (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)) == <span class="number">0</span>)) {</span><br/><span class="line">      <span class="comment">/* found! */</span></span><br/><span class="line">      <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br/><span class="line">        changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br/><span class="line">      <span class="keyword">return</span> ts;</span><br/><span class="line">    }</span><br/><span class="line">  }</span><br/><span class="line">  <span class="keyword">if</span> (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/<span class="number">2</span>) {</span><br/><span class="line">    luaS_resize(L, g-&gt;strt.size * <span class="number">2</span>);</span><br/><span class="line">    <span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];  <span class="comment">/* recompute with new size */</span></span><br/><span class="line">  }</span><br/><span class="line">  ts = createstrobj(L, str, l, LUA_TSHRSTR, h);</span><br/><span class="line">  ts-&gt;hnext = *<span class="built_in">list</span>;</span><br/><span class="line">  *<span class="built_in">list</span> = ts;</span><br/><span class="line">  g-&gt;strt.nuse++;</span><br/><span class="line">  <span class="keyword">return</span> ts;</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">/* 对字符串按步长hash的函数 */</span></span><br/><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">luaS_hash</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l, <span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span> </span>{</span><br/><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = seed ^ cast(<span class="keyword">unsigned</span> <span class="keyword">int</span>, l);</span><br/><span class="line">  <span class="keyword">size_t</span> l1;</span><br/><span class="line">  <span class="keyword">size_t</span> step = (l &gt;&gt; LUAI_HASHLIMIT) + <span class="number">1</span>;</span><br/><span class="line">  <span class="keyword">for</span> (l1 = l; l1 &gt;= step; l1 -= step)</span><br/><span class="line">    h = h ^ ((h&lt;&lt;<span class="number">5</span>) + (h&gt;&gt;<span class="number">2</span>) + cast_byte(str[l1 - <span class="number">1</span>]));</span><br/><span class="line">  <span class="keyword">return</span> h;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>