---
layout: post
title: Lua 的标准输出与缓存  
tags: [lua文章]
categories: [topic]
---
<p>最近我遇到了个奇怪的问题，我的一个Lua脚本需要通过shell的重定向将输出追加到一个日志文件中。但是那个Lua脚本的输出在日志文件里看来却不是实时的，输出的文本直到脚本结束时才能看到。</p>

<p>在shell下运行这个程序，是可以看到实时输出的：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- buffer_test.lua</span>
<span class="kd">local</span> <span class="n">socket</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&#34;socket&#34;</span>

<span class="kd">local</span> <span class="n">const</span> <span class="o">=</span> <span class="mi">100</span>

<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">socket</span><span class="p">.</span><span class="n">select</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>但是当通过重定向时，只有脚本结束后才能看到文件：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># lua buffer_test.lua &gt;&gt;log.txt 2&gt;&amp;1 &amp;</span>
<span class="c"># tail -f log.txt</span>
</code></pre></div></div>

<p>看来当Lua的标准输出stdout连接的是终端时，采用了行缓存模式，而重定向到文件时则变成了完全缓存。翻遍了Lua的官方文档也没有找到这样的说明。但是在查看stdio的手册页时发现了下面的一段话：</p>

<blockquote>
  <p>The stdio library is a part of the library libc and routines are auto-matically loaded as needed by the compilers cc(1) and pc(1).
<br/><br/>
At program startup, three text streams are predefined and need not be opened explicitly — standard input (for reading conventional input), — standard output (for writing conventional input), and standard error (for writing diagnostic output). These streams are abbreviated stdin,stdout and stderr. <span style="background-color: #FFFB00;">When opened, the standard error stream is not fully buffered; the standard input and output streams are fully buffered if and only if the streams do not to refer to an interactive device.</span>
<br/><br/>
Output streams that refer to terminal devices are always line buffered by default;</p>
</blockquote>

<p>原来stdio都是由libc提供，而我在<code class="highlighter-rouge">ldd lua</code>时发现Lua确实也依赖于libc。这下就可以解释了：Lua在连接是终端的时候采用的是行缓存，而连接的是非活跃的设备时是采用的是完全缓存。</p>

<p>但是假如我们中途终止脚本，查看日志：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nl log.txt</span>
 1	lua: io.lua:9: interrupted!
 2	stack traceback:
 3		<span class="o">[</span>C]: <span class="k">in function</span> <span class="s1">&#39;select&#39;</span>
 4		io.lua:9: <span class="k">in </span>main chunk
 5		<span class="o">[</span>C]: ?
 6	1
 7	2
 8	3
</code></pre></div></div>

<p>可以发现异常的日志难道不应该在最后面吗？其实上面的引用已经帮我们回答了：stderr并不是完全缓存，当发生异常时，stderr首先被写入日志，接着缓存区的stdout才会被刷入文件。</p>

<p><strong>回顾这个问题，给我们留下的经验是Lua的很多库的实现原理其实在libc与系统调用那儿，不要只把目光局限在Lua的文档上。其实在其他的语言中，我估计也差不多。我们在查找问题的时候，一定要跳出自己的固有思维，有时候自己非常有把握的知识恰恰是不准确的。</strong></p>


                <hr style="visibility: hidden;"/>