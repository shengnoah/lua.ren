---
layout: post
title: Lua中的值及其类型 
tags: [lua文章]
categories: [topic]
---
<p>　　Lua是一门动态类型的语言，这意味着Lua中的变量没有类型，而值才有类型。一个变量可以在不同时刻指向不同类型的值。下面将对Lua中的值及其类型做一些总结。</p>
<h2 id="基本数据类型及其子类型"><a href="#基本数据类型及其子类型" class="headerlink" title="基本数据类型及其子类型"></a>基本数据类型及其子类型</h2><p>　　在lua-5.3.5版本中，有9中基本的数据类型，其定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line">#define LUA_TNIL		0		// 空类型</span><br/><span class="line">#define LUA_TBOOLEAN		1		// 布尔类型</span><br/><span class="line">#define LUA_TLIGHTUSERDATA	2		// 指针类型(void *)</span><br/><span class="line">#define LUA_TNUMBER		3		// 数字类型</span><br/><span class="line">#define LUA_TSTRING		4		// 字符串类型</span><br/><span class="line">#define LUA_TTABLE		5		// 表类型</span><br/><span class="line">#define LUA_TFUNCTION		6		// 函数类型</span><br/><span class="line">#define LUA_TUSERDATA		7		// 指针类型(void *)</span><br/><span class="line">#define LUA_TTHREAD		8		// Lua虚拟机、协程</span><br/><span class="line"></span><br/><span class="line">#define LUA_NUMTAGS		9</span><br/></pre></td></tr></tbody></table></figure>

<p>　　其中需要说明的是LUA_TLIGHTUSERDATA和LUA_TUSERDATA的区别是：前者的所有对象共享一个元表，且其内部所指向的内存的申请及释放不需要由Lua来完成；后者的每个对象都有自己的元表，需要进行垃圾回收，并且其内部所指向的内存的申请和释放需要由Lua来完成。除此之外，上述的一些基本类型有子类型（变种类型），一些基本类型需要GC，例如LUA_TNUMBER类型可以进一步分为整数类型和实数类型，现将这些子类型及GC标记的定义一并罗列如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line">#define LUA_TLCL	(LUA_TFUNCTION | (0 &lt;&lt; 4))  /* Lua closure */</span><br/><span class="line">#define LUA_TLCF	(LUA_TFUNCTION | (1 &lt;&lt; 4))  /* light C function */</span><br/><span class="line">#define LUA_TCCL	(LUA_TFUNCTION | (2 &lt;&lt; 4))  /* C closure */</span><br/><span class="line"></span><br/><span class="line">#define LUA_TSHRSTR	(LUA_TSTRING | (0 &lt;&lt; 4))  /* short strings */</span><br/><span class="line">#define LUA_TLNGSTR	(LUA_TSTRING | (1 &lt;&lt; 4))  /* long strings */</span><br/><span class="line"></span><br/><span class="line">#define LUA_TNUMFLT	(LUA_TNUMBER | (0 &lt;&lt; 4))  /* float numbers */</span><br/><span class="line">#define LUA_TNUMINT	(LUA_TNUMBER | (1 &lt;&lt; 4))  /* integer numbers *</span><br/><span class="line"></span><br/><span class="line">/* Bit mark for collectable types */</span><br/><span class="line">#define BIT_ISCOLLECTABLE	(1 &lt;&lt; 6)</span><br/><span class="line"></span><br/><span class="line">/* mark a tag as collectable */</span><br/><span class="line">#define ctb(t)			((t) | BIT_ISCOLLECTABLE)</span><br/></pre></td></tr></tbody></table></figure>

<p>　　Lua中是如何实现对基本类型、子类型、是否需要GC等的表示的呢？其实从子类型的定义我们也可以大概了解到，具体如下：</p>
<ul>
<li>基本类型有9种，因此可以用低四位，即bits 0-3来表示；</li>
<li>每种基本类型的子类型不超过4种，因此可以用中间两位，即bits 4-5来表示；</li>
<li>用于标记某种类型是否需要进行GC，只需要一个位，因此可以用bit 6来表示；</li>
</ul>
<h2 id="值表示的统一数据结构"><a href="#值表示的统一数据结构" class="headerlink" title="值表示的统一数据结构"></a>值表示的统一数据结构</h2><p>　　Lua中所有的值都是第一类值，即所有的值都可以存储在变量中，也可以作为参数传递给函数，也可以作为函数的返回值。为了更好地管理Lua中的值，Lua使用了一个通用的数据结构TValue来存储Lua中可能出现的任何值及其类型，其定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line">typedef union Value {</span><br/><span class="line">  GCObject *gc;    /* collectable objects */</span><br/><span class="line">  void *p;         /* light userdata */</span><br/><span class="line">  int b;           /* booleans */</span><br/><span class="line">  lua_CFunction f; /* light C functions */</span><br/><span class="line">  lua_Integer i;   /* integer numbers */</span><br/><span class="line">  lua_Number n;    /* float numbers */</span><br/><span class="line">} Value;</span><br/><span class="line"></span><br/><span class="line">#define TValuefields	Value value_; int tt_</span><br/><span class="line"></span><br/><span class="line">typedef struct lua_TValue {</span><br/><span class="line">  TValuefields;</span><br/><span class="line">} TValue;</span><br/></pre></td></tr></tbody></table></figure>

<p>　　联合体Value将Lua中所有可能的值都囊括了进来，比如通过包含GCObject *类型的成员gc，可以将所有需要GC的值都包含进来。结构体TValue包含了两个成员，一个是联合体类型Value的对象value_，用于表示Lua中所有可能出现的值，另一个是int类型的tt_，用来表示Value具体表示哪种类型的值。这样通过TValue就是可以表示Lua中所有的值及其类型了。<br/>　　那如何将TValue与某种具体类型的值之间做转换呢？其主要的逻辑是将TValue中的value_及tt_与具体的数据及其类型对应起来做转换。以TValue和LUA_TNUMFLT之间的转换为例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line">/* Macro to test type */</span><br/><span class="line">#define ttisfloat(o)		checktag((o), LUA_TNUMFLT)</span><br/><span class="line"></span><br/><span class="line">/* Macro to access values */</span><br/><span class="line">#define fltvalue(o)	check_exp(ttisfloat(o), val_(o).n)</span><br/><span class="line"></span><br/><span class="line">#define val_(o)		((o)-&gt;value_)</span><br/><span class="line">#define settt_(o,t)	((o)-&gt;tt_=(t))</span><br/><span class="line"></span><br/><span class="line">/* Macro to set value */</span><br/><span class="line">#define setfltvalue(obj,x) </span><br/><span class="line">  { TValue *io=(obj); val_(io).n=(x); settt_(io, LUA_TNUMFLT); }</span><br/></pre></td></tr></tbody></table></figure>

<p>　　我们可以通过宏fltvalue()从TValue对象中取出其中存放的实数，通过宏setfltvalue()将实数存放到TValue对象中，并将其内部类型设置为LUA_TNUMFLT。</p>
<h2 id="垃圾回收类型及其“继承”"><a href="#垃圾回收类型及其“继承”" class="headerlink" title="垃圾回收类型及其“继承”"></a>垃圾回收类型及其“继承”</h2><p>　　上面说到，Value将Lua中所有可能的值都包含了进来，从它的定义中我们不难看出，它确实将布尔类型、整数类型、实数类型、轻量级函数类型等类型的值包含了进来，只要给Value类型的对象赋其中某一个类型的值就行，但是为什么说通过包含GCObject *类型的gc成员就将所有需要GC的类型的值也包含进来了呢？我们先来看下GCObject的定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/></pre></td><td class="code"><pre><span class="line">/* Common type for all collectable objects */</span><br/><span class="line">typedef struct GCObject GCObject;</span><br/><span class="line"></span><br/><span class="line">/* Common Header for all collectable objects (in macro form, to be included in other objects) */</span><br/><span class="line">#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked</span><br/><span class="line"></span><br/><span class="line">/* Common type has only the common header */</span><br/><span class="line">struct GCObject {</span><br/><span class="line">  CommonHeader;</span><br/><span class="line">};</span><br/><span class="line"></span><br/><span class="line">typedef struct TString {</span><br/><span class="line">  CommonHeader;		</span><br/><span class="line">  </span><br/><span class="line">  lu_byte extra;  /* reserved words for short strings; &#34;has hash&#34; for longs */</span><br/><span class="line">  lu_byte shrlen;  /* length for short strings */ </span><br/><span class="line">  unsigned int hash;	</span><br/><span class="line">  union {</span><br/><span class="line">    size_t lnglen;  /* length for long strings */</span><br/><span class="line">    struct TString *hnext;  /* linked list for hash table */</span><br/><span class="line">  } u;</span><br/><span class="line">} TString;</span><br/></pre></td></tr></tbody></table></figure>

<p>　　为了更好地说明上面提出来的问题，我们通过一个需要进行GC的类型TString（即lua中的字符串类型）来进行辅助说明。从上面GCObject类型和TString类型的定义中可以看出，两者均在开头包含了一个宏CommonHeader。这就使得这两个类型所对应的对象的内存布局的头部是相同的，两者的内存布局如图1所示，而TString类型的对象中多出来的内容则是其私有数据，因而所有需要GCObject类型的对象地方就都可以将TString类型的对象传进去，当然需要做一个强制类型转换(毕竟是伪继承)，将TString类型强转伪GCObject类型，在实际使用的时候，我们再将其强转回TString类型即可。所有其他需要进行GC的类型都和TString一样，会在定义的开头加上CommonHeader，从而实现类似的功能。从另外一方面看，我们可以将GCObject看成TString、Table等的父类，这也很好地体现了在C中如何实现继承等面向对象编程的方法。</p>
<div align="center"> <img src="https://tqr.ink//2019/06/03/value-and-its-type-in-lua/GCObject和TString的内存布局.png" title="图1 GCObject和TString的内存布局"/> </div>
　　从上面的分析我们可以知道，GCObject类型可以说是所有需要进行垃圾回收的类型的代表。在一些接口方面，都是以GCObject类型进行呈现的。例如在Lua中，进程要创建一个需要进行垃圾回收类型的对象时，都是申请一个GCObject对象，同时将具体的类型和所需要的内存大小通过参数传递进去。申请GCObject对象成功后，在函数外层再根据上下文环境将GCObject对象转换为具体类型的对象，再进行类型私有数据的初始化等操作。还是以TString为例，假设要创建一个TString类型的对象，lua源码中有如下例程：
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/></pre></td><td class="code"><pre><span class="line">/* 创建一个新的字符串对象，未填入具体的字符串内容，只是申请了内存空间 */</span><br/><span class="line">static TString *createstrobj (lua_State *L, size_t l, int tag, unsigned int h) {</span><br/><span class="line">  TString *ts;</span><br/><span class="line">  GCObject *o;</span><br/><span class="line">  size_t totalsize;  /* total size of TString object */</span><br/><span class="line"></span><br/><span class="line">  /* 计算字符串对应需要的内存大小，包括头部和内容，内容紧跟在头部之后 */</span><br/><span class="line">  totalsize = sizelstring(l);</span><br/><span class="line"></span><br/><span class="line">  /* 根据存放字符串所需的内存大小和类型标记创建一个新的GCObject对象 */</span><br/><span class="line">  o = luaC_newobj(L, tag, totalsize);</span><br/><span class="line"></span><br/><span class="line">  /* 将GCObject类型转换为具体的TString类型 */</span><br/><span class="line">  ts = gco2ts(o);</span><br/><span class="line"></span><br/><span class="line">  /* 保存字符串对应的hash值 */</span><br/><span class="line">  ts-&gt;hash = h;</span><br/><span class="line">  ts-&gt;extra = 0;</span><br/><span class="line"></span><br/><span class="line">  /* 字符串以&#39;