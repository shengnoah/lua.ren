---
layout: post
title: 2.2 lua 基础数据类型 
tags: [lua文章]
categories: [topic]
---
<p>lua 是一门极其精简的语言，内置类型只要<code>nil</code>,<code>boolean</code>,<code>number</code>等三种基本类型，以及<code>string</code>,<code>table</code>等二种组合类型。没有C/C++ 等语言中的<code>class</code>、<code>struct</code>等复杂类型，这些类型可以通过<code>table</code>来实现。同时，不同于其他语言（如C/C++和java），<code>function</code>在lua中也作为一个一级类型。</p>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p><code>nil</code> 是一种类型，Lua 将 <code>nil</code> 用于表示“无效值”。</p>
<ol>
<li>一个变量在第一次赋值前的默认值是 <code>nil</code></li>
<li>将<code>nil</code> 赋予给一个全局变量就等同于删除它.</li>
<li>openresty 中提供了另一种表示空值的类型<code>ngx.null</code>.</li>
</ol>
<p><code>nil</code>在lua中有其特殊意义，如果一个变量被设置为<code>nil</code>，就等于说该变量<strong>未定义</strong>，与无穷无尽的其他未定义的变量一样。那么，如果把redis查询为空的结果设置为<code>nil</code>，就无法把”查询为空”和“未定义”区分开来了，例如在一个table中，一个key对应一个value，如果将该value设置为<code>nil</code>，则相当让key凭空消失，这显然是不合理的。所以必须用一个userdata类型的独特的值来表示这种查询为空，但又不等同于未定义的变量，例如<code>ngx.null</code>。同样的情况想必在sql的lua模块中也会出现，用来处理记录中键值查询为空的情况。<br/>lua中神奇的<code>nil</code>了。<code>nil</code>是一种类型，该类型只有一个值，这个值就是<code>nil</code>。该值的作用只有一个，表示一个变量不存在。跟CC++等常规语言不同，”不存在“跟空、0完全是两个概念。在C语言中，一个字符串如果为空，那么它就只有一个为<code>0</code>的<code>nul</code>结束符，如果对齐进行逻辑判断，则是假。但lua中，只要一个变量不是<code>nil</code>类型或者是boolean类型中的<code>false</code>,则对它进行逻辑判断，结果是真，即使该值是一个数字0，或者是一个空字符串。</p>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>布尔类型，可选值 true/false；<strong>Lua 中 nil 和 false 为“假”</strong>，其它所有值均为“真”。比如 0 和空字符串就是“真”；C 或者 Perl 程序员或许会对此感到惊讶。</p>
<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>Number 类型用于表示实数，和 C/C++ 里面的 <code>double</code> 类型很类似。可以使用数学函数<code>math.floor</code>（ 向下取整） 和 <code>math.ceil</code>（ 向上取整） 进行取整操作。</p>
<p>一般地，Lua 的 number 类型就是用双精度浮点数来实现的。值得一提的是，LuaJIT 支持所谓的“dual-number”（ 双数） 模式，即 LuaJIT 会根据上下文用整型来存储整数，而用双精度浮点数来存放浮点数。另外，LuaJIT 还支持“长长整型”的大整数（ 在 x86_64 体系结构上则是 64 位整数） 。例如</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">print(9223372036854775807LL - 1)</span><br/><span class="line">9223372036854775806LL</span><br/></pre></td></tr></tbody></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>Lua 中有三种方式表示字符串:</p>
<ol>
<li>使用一对匹配的单引号。例：’hello’。</li>
<li>使用一对匹配的双引号。例：”hello”。</li>
<li>字符串还可以用一种长括号（ 即[[ ]]） 括起来的方式定义。我们把两个正的方括号（ 即[[）间插入 n 个等号定义为第 n 级正长括号。就是说，0 级正的长括号写作 [[ ，一级正的长括号写作 [=[，如此等等。反的长括号也作类似定义；举个例子，4 级反的长括号写作]====]。一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束。整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。这种方式描述的字符串可以包含任何东西，当然本级别的反长括号除外。例：[[abcnbc]]，里面的 “n” 不会被转义。</li>
</ol>
<p><strong>特别注意：</strong>Lua 的字符串是<em>不可改变</em>的值，不能像在 c 语言中那样直接修改字符串的某个字符，而是根据修改要求来创建一个新的字符串。Lua 也<em>不能</em>通过下标来访问字符串的某个字符。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/></pre></td><td class="code"><pre><span class="line">local str1 = &#39;hello world&#39;</span><br/><span class="line">local str2 = &#34;hello world&#34;</span><br/><span class="line">local str3 = [[&#34;addname&#34;,&#39;hello&#39;]]</span><br/><span class="line">local str4 = [=[string have a [[]].]=]</span><br/><span class="line"><span class="meta">&gt;</span>local str5 = &#39;hellonworld&#39;</span><br/><span class="line"><span class="meta">&gt;</span>local str6 = &#34;hellonworld&#34;</span><br/><span class="line"></span><br/><span class="line"><span class="meta">&gt;</span>print(str1)</span><br/><span class="line">hello world</span><br/><span class="line"><span class="meta">&gt;</span>print(str2)</span><br/><span class="line">hello world</span><br/><span class="line"><span class="meta">&gt;</span>print(str3)</span><br/><span class="line">&#34;addname&#34;,&#39;hello&#39;</span><br/><span class="line"><span class="meta">&gt;</span>print(str4)</span><br/><span class="line">string have a [[]]</span><br/><span class="line"><span class="meta">&gt;</span>print(str5)</span><br/><span class="line">hello</span><br/><span class="line">world</span><br/><span class="line"><span class="meta">&gt;</span>print(str6)</span><br/><span class="line">hello</span><br/><span class="line">world</span><br/></pre></td></tr></tbody></table></figure>

<p><strong>特别注意：</strong> 从上面实例<code>str5</code>和<code>str6</code>可以看出<code>&#39;</code>和<code>&#34;</code>在lua中作用是一致的，二者中的<code>n</code>这类转义字符都会被转义，这一点要区别一下shell中<code>&#39;</code>和<code>&#34;</code>。</p>
<p>在 Lua 实现中，Lua 字符串一般都会经历一个“内化”（ intern） 的过程，即两个完全一样的Lua 字符串在 Lua 虚拟机中只会存储一份。每一个 Lua 字符串在创建时都会插入到 Lua 虚拟机内部的一个全局的哈希表中。 这意味着</p>
<ol>
<li>创建相同的 Lua 字符串并不会引入新的动态内存分配操作，所以相对便宜（ 但仍有全局哈希表查询的开销。</li>
<li>内容相同的 Lua 字符串不会占用多份存储空间。</li>
<li>已经创建好的 Lua 字符串之间进行相等性比较时是 O(1) 时间度的开销，而不是通常见到的 O(n)，比较索引就可以了。</li>
</ol>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，索引通常是字符串（ string） 或者 number 类型，但也可以是除 nil 以外的任意类型的值。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> corp = {</span><br/><span class="line">web = <span class="string">&#34;www.google.com&#34;</span>, </span><br/><span class="line"><span class="comment">-- value = &#34;www.google.com&#34;</span></span><br/><span class="line">telephone = <span class="string">&#34;12345678&#34;</span>, <span class="comment">--索引为字符串</span></span><br/><span class="line">staff = {<span class="string">&#34;Jack&#34;</span>, <span class="string">&#34;Scott&#34;</span>, <span class="string">&#34;Gary&#34;</span>}, <span class="comment">--索引为字符串，值也是一个表</span></span><br/><span class="line"><span class="number">100876</span>, <span class="comment">--相当于 [1] = 100876，此时索引为数字</span></span><br/><span class="line"><span class="comment">-- key = 1, value = 100876</span></span><br/><span class="line"><span class="number">100191</span>, <span class="comment">--相当于 [2] = 100191，此时索引为数字</span></span><br/><span class="line">[<span class="number">10</span>] = <span class="number">360</span>, <span class="comment">--直接把数字索引给出</span></span><br/><span class="line">[<span class="string">&#34;city&#34;</span>] = <span class="string">&#34;Beijing&#34;</span> <span class="comment">--索引为字符串</span></span><br/><span class="line">} p</span><br/><span class="line">rint(corp.web) <span class="comment">--&gt;output:www.google.com</span></span><br/><span class="line"><span class="built_in">print</span>(corp[<span class="string">&#34;telephone&#34;</span>]) <span class="comment">--&gt;output:12345678</span></span><br/><span class="line"><span class="built_in">print</span>(corp[<span class="number">2</span>]) <span class="comment">--&gt;output:100191</span></span><br/><span class="line"><span class="built_in">print</span>(corp[<span class="string">&#34;city&#34;</span>]) <span class="comment">--&gt;output:&#34;Beijing&#34;</span></span><br/><span class="line"><span class="built_in">print</span>(corp.staff[<span class="number">1</span>]) <span class="comment">--&gt;output:Jack</span></span><br/><span class="line"><span class="built_in">print</span>(corp[<span class="number">10</span>]) <span class="comment">--&gt;output:360</span></span><br/></pre></td></tr></tbody></table></figure>

<p>在内部实现上，table 通常实现为一个哈希表、一个数组、或者两者的混合。具体的实现为何种形式，动态依赖于具体的 table 的键分布特点。</p>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>在 Lua 中，函数:</p>
<ol>
<li>也是一种数据类型,</li>
<li>函数可以存储在变量中，</li>
<li>可以通过参数传递给其他函数，</li>
<li>还可以作为其他函数的返回值</li>
</ol>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line"><span class="built_in">print</span>(<span class="string">&#34;in the function&#34;</span>)</span><br/><span class="line"><span class="comment">--dosomething()</span></span><br/><span class="line"><span class="keyword">local</span> x = <span class="number">10</span></span><br/><span class="line"><span class="keyword">local</span> y = <span class="number">20</span></span><br/><span class="line"><span class="keyword">return</span> x + y</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"><span class="keyword">local</span> a = foo <span class="comment">--把函数赋给变量</span></span><br/><span class="line"><span class="built_in">print</span>(a())</span><br/><span class="line"><span class="comment">--output:</span></span><br/><span class="line"><span class="keyword">in</span> the <span class="function"><span class="keyword">function</span></span></span><br/><span class="line"><span class="function">30</span></span><br/></pre></td></tr></tbody></table></figure>

<p>有名函数的定义可以理解为是匿名函数对变量的赋值。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>

<p>可以写成如下形式：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>

<p>类似地，</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>

<p>等价于</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>