---
layout: post
title: Lua中的封装 
tags: [lua文章]
categories: [topic]
---
`Lua`中没有`private`，`table`中的`key/value`可以随意访问，利用`metatable`虽然可以施加一些限制，但是实际上有各种方法可以绕过这些限制。  
下面介绍一种方法，实现真正的封装。

    
    
    local LuaClass = require "LuaClass"
    local TestClass = LuaClass("TestClass")
    local PrivateDataMap = LuaClass:PrivateDataMap{
        "MemberA",
        "MemberB",
    }
    
    function TestClass:GetMemberA()
        return PrivateDataMap:Get(self, "MemberA")
    end
    
    function TestClass:SetMemberA(Value)
        local ExistValue = PrivateDataMap:Get(self, "MemberA")
        if ExistValue ~= Value then -- 比较差异
            PrivateDataMap:Set(self, "MemberA", Value)
            DispatchXXX -- 触发事件 
        end
    end
    
    function TestClass:GetMemberB()
        return PrivateDataMap:Get(self, "MemberB")
    end

上面这段代码中，每个`object`对应两个成员`MemberA`、`MemberB`，因为`PrivateDataMap`是局部变量，所以外部的代码无法直接访问，只能通过`TestClass`提供的接口访问这些成员。  
`PrivateDataMap`的实现方法如下：

    
    
    function LuaClass:PrivateDataMap(MemberNameList)
        local DataMap = {}
        function DataMap:Set(Owner, MemberName, Value)
            local Owner2ValueMap = DataMap[MemberName]
            if Owner2ValueMap then
                Owner2ValueMap[Owner] = Value
            end
        end
    
        function DataMap:Get(Owner, MemberName)
            local Owner2ValueMap = DataMap[MemberName]
            return Owner2ValueMap and Owner2ValueMap[Owner]
        end
    
        local CommonFunction = require "CommonFunction"
        for _, MemberName in pairs(MemberNameList) do
            DataMap[MemberName] = CommonFunction:CreateWeakTable()
        end
        return DataMap
    end

其中，`object`与`member`的对应关系存储在`weaktable`中，不会影响`object`的释放。