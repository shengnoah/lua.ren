---
layout: post
title: lua错误跟踪 
tags: [lua文章]
categories: [lua文章]
---
pcall() xpcall() debug.traceback() debug.debug() assert()

错误

Errare humanum
est（拉丁谚语：犯错是人的本性）。所以我们要尽可能的防止错误的发生，Lua经常作为扩展语言嵌入在别的应用中，所以不能当错误发生时简单的崩溃或者退出。相反，当错误发生时Lua结束当前的chunk并返回到应用中。

当Lua遇到不期望的情况时就会抛出错误，比如：两个非数字进行相加；调用一个非函数的变量；访问表中不存在的值等（可以通过metatables修改这种行为，后面介绍）。你也可以通过调用error函数显式地抛出错误，error的参数是要抛出的错误信息。

print “enter a number:”

n = io.read(“*number”)

if not n then error(“invalid input”) end

Lua提供了专门的内置函数assert来完成上面类似的功能：

print “enter a number:”

n = assert(io.read(“*number”), “invalid input”)

assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。第二个参数是可选的。注意，assert会首先处理两个参数，然后才调用函数，所以下面代码，无论n是否为数字，字符串连接操作总会执行：

n = io.read()

assert(tonumber(n), “invalid input: “ .. n .. “ is not a number”)

当函数遇到异常有两个基本的动作：返回错误代码或者抛出错误。选择哪一种方式，没有固定的规则，不过基本的原则是：对于程序逻辑上能够避免的异常，以抛出错误的方式处理之，否则返回错误代码。

例如sin函数，假定我们让sin碰到错误时返回错误代码，则使用sin的代码可能变为：

local res = math.sin(x)

if not res then – error

​ …

当然，我们也可以在调用sin前检查x是否为数字：

if not tonumber(x) then – error: x is not a number

​ …

而事实上，我们既不是检查参数也不是检查返回结果，因为参数错误可能意味着我们的程序某个地方存在问题，这种情况下，处理异常最简单最实际的方式是抛出错误并且终止代码的运行。

再来看一个例子。io.open函数用于打开文件，如果文件不存在，结果会如何？很多系统中，我们通过“试着去打开文件”来判断文件是否存在。所以如果io.open不能打开文件（由于文件不存在或者没有权限），函数返回nil和错误信息。依据这种方式，我们可以通过与用户交互（比如：是否要打开另一个文件）合理地处理问题：

    
    
    local file, msg
    
    repeat
    
        print "enter a file name:"
    
        local name = io.read()
    
        if not name then return end     -- no input
    
        file, msg = io.open(name, "r")
    
        if not file then print(msg) end
    
    until file
    

如果你想偷懒不想处理这些情况，又想代码安全的运行，可以使用assert：

file = assert(io.open(name, “r”))

Lua中有一个习惯：如果io.open失败，assert将抛出错误。

file = assert(io.open(“no-file”, “r”))

​ –> stdin:1: no-file: No such file or directory

注意：io.open返回的第二个结果（错误信息）会作为assert的第二个参数。

虽然你可以使用任何类型的值作为错误信息，通常情况下，我们使用字符串来描述遇到的错误。如果遇到内部错误（比如对一个非table的值使用索引下标访问）Lua将自己产生错误信息，否则Lua使用传递给error函数的参数作为错误信息。不管在什么情况下，Lua都尽可能清楚的描述问题发生的缘由。

local status, err = pcall(function () a = ‘a’+1 end)

print(err)

–> stdin:1: attempt to perform arithmetic on a string value

local status, err = pcall(function () error(“my error”) end)

print(err)

–> stdin:1: my error

例子中错误信息给出了文件名（stdin）与行号。

函数error还可以有第二个参数，表示错误发生的层级。比如，你写了一个函数用来检查“error是否被正确调用”：

    
    
    function foo (str)
    
        if type(str) ~= "string" then
    
           error("string expected")
    
        end
    
        ...
    
    end
    

可有人这样调用此函数：

foo({x=1})

Lua会指出发生错误的是foo而不是error，实际上，错误是调用error时产生的。为了纠正这个问题，修改前面的代码让error报告错误发生在第二级（你自己的函数是第一级）如下：

    
    
    function foo (str)
    
        if type(str) ~= "string" then
    
           error("string expected", 2)
    
        end
    
        ...
    
    end
    

当错误发生的时候，我们常常希望了解详细的信息，而不仅是错误发生的位置。若能了解到“错误发生时的栈信息”就好了，但pcall返回错误信息时，已经释放了保存错误发生情况的栈信息。因此，若想得到tracebacks，我们必须在pcall返回以前获取。Lua提供了xpcall来实现这个功能，xpcall接受两个参数：调用函数、错误处理函数。当错误发生时，Lua会在栈释放以前调用错误处理函数，因此可以使用debug库收集错误相关信息。有两个常用的debug处理函数：debug.debug和debug.traceback，前者给出Lua的提示符，你可以自己动手察看错误发生时的情况；后者通过traceback创建更多的错误信息，也是控制台解释器用来构建错误信息的函数。你可以在任何时候调用debug.traceback获取当前运行的traceback信息：

print(debug.traceback())