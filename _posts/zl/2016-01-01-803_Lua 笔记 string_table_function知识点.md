---
layout: post
title: Lua 笔记 string_table_function知识点 
tags: [lua文章]
categories: [topic]
---
<p>本文涉及到一些关于<code>string</code>、<code>table</code>和<code>function</code>的细碎知识点，一些常用操作的背后逻辑。本文是用于记录一次技术分享，部分内容与<a href="../2018-09-13-lua-notes-03">之前的一篇Lua的笔记</a>有重叠。</p>
<p>本文参考和使用的lua源码基于Lua 5.3.5，编写的lua脚本运行于OSX系统，使用的是64位的lua运行库。</p>

<h3 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h3><p>纯lua侧的对于代码执行耗时的评估和执行过程中产生的堆内存的分析。</p>
<h4 id="时间分析"><a href="#时间分析" class="headerlink" title="时间分析"></a>时间分析</h4><p>对应于cpu负载，借助<code>os.clock()</code>函数，以下是一个示例：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a, b</span><br/><span class="line">a = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br/><span class="line"></span><br/><span class="line">b = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br/><span class="line"><span class="built_in">print</span>(b-a)</span><br/></pre></td></tr></tbody></table></figure>
<h4 id="空间分析"><a href="#空间分析" class="headerlink" title="空间分析"></a>空间分析</h4><p>对应于内存占用，借助<code>collectgarbage()</code>函数，这个函数传入不同的参数可以对lua的gc机制进行不同的操作控制，具体不再展开，这里主要是对堆内存的占用进行评估，用到的是以下的一套组合三连，即先强制一轮完整的gc（<code>collect</code>），然后禁用gc（<code>stop</code>），在执行完一些待测试的代码之后获取对内存占用的千字节数（<code>count</code>）：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&#34;collect&#34;</span>)</span><br/><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&#34;stop&#34;</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">&#34;count&#34;</span>))</span><br/></pre></td></tr></tbody></table></figure>
<p>来一个简单的gc演示，三次获取堆内存，分配前、分配后、gc后：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&#34;collect&#34;</span>)</span><br/><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&#34;stop&#34;</span>)</span><br/><span class="line"><span class="keyword">local</span> a = <span class="built_in">collectgarbage</span>(<span class="string">&#34;count&#34;</span>) * <span class="number">1024</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> t = {}</span><br/><span class="line">t = <span class="literal">nil</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> b = <span class="built_in">collectgarbage</span>(<span class="string">&#34;count&#34;</span>) * <span class="number">1024</span></span><br/><span class="line"></span><br/><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&#34;collect&#34;</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> c = <span class="built_in">collectgarbage</span>(<span class="string">&#34;count&#34;</span>) * <span class="number">1024</span></span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(<span class="string">&#34;before alloc &#34;</span> .. a)</span><br/><span class="line"><span class="built_in">print</span>(<span class="string">&#34;after alloc &#34;</span> .. b)</span><br/><span class="line"><span class="built_in">print</span>(<span class="string">&#34;after collect &#34;</span> .. c)</span><br/></pre></td></tr></tbody></table></figure>
<p>上边输出的内容，a和c是相等的，b会多出来56个字节（这是一个空表的内存占用）。</p>
<h3 id="通用的lua类型"><a href="#通用的lua类型" class="headerlink" title="通用的lua类型"></a>通用的lua类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>Lua中通用的值类型，<code>TValue</code>，使用一个联合体保存数据，和一个枚举值区分该值的类型，定义在<code>lobject.h</code>第100行：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br/><span class="line"><span class="comment">** Union of all Lua values</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Value {</span><br/><span class="line">  GCObject *gc;    <span class="comment">/* collectable objects */</span></span><br/><span class="line">  <span class="keyword">void</span> *p;         <span class="comment">/* light userdata */</span></span><br/><span class="line">  <span class="keyword">int</span> b;           <span class="comment">/* booleans */</span></span><br/><span class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></span><br/><span class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br/><span class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></span><br/><span class="line">} Value;</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  {</span></span><br/><span class="line">  TValuefields;</span><br/><span class="line">} TValue;</span><br/></pre></td></tr></tbody></table></figure>
<h4 id="GC信息"><a href="#GC信息" class="headerlink" title="GC信息"></a>GC信息</h4><p>gc相关的通用数据，table、string和function都是受gc管理的类型，它们的结构中都是以一个<code>CommonHeader</code>开始，其定义如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br/><span class="line"><span class="comment">** Common type for all collectable objects</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> <span class="title">GCObject</span>;</span></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="comment">/*</span></span><br/><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br/><span class="line"><span class="comment">** included in other objects)</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CommonHeader  GCObject *next; lu_byte tt; lu_byte marked</span></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="comment">/*</span></span><br/><span class="line"><span class="comment">** Common type has only the common header</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> {</span></span><br/><span class="line">  CommonHeader;</span><br/><span class="line">};</span><br/></pre></td></tr></tbody></table></figure>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>先从一段简单短Lua代码开始，尝试得到一个空字符串<code>&#34;&#34;</code>所占用的堆内存：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&#34;collect&#34;</span>)</span><br/><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&#34;stop&#34;</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- -------------------------------------------------------</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> before = <span class="built_in">collectgarbage</span>(<span class="string">&#34;count&#34;</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> s = <span class="built_in">table</span>.<span class="built_in">concat</span>({})</span><br/><span class="line"><span class="built_in">collectgarbage</span>(<span class="string">&#34;collect&#34;</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- -------------------------------------------------------</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> after = <span class="built_in">collectgarbage</span>(<span class="string">&#34;count&#34;</span>)</span><br/><span class="line"><span class="built_in">print</span>(<span class="number">1024</span> * (after - before))</span><br/></pre></td></tr></tbody></table></figure>
<p>输出25，即一个空字符串会产生25字节的堆内存。此处之所以使用<code>table.concat({})</code>而不是直接使用<code>&#34;&#34;</code>，是因为代码中直接存在的字面字符串不会再单独分配堆内存。</p>
<p>来看一看一个空字符串的25个字节分别是什么内容，并以此为基础计算任意一个字符串占用的内存。</p>
<h4 id="结构和定义"><a href="#结构和定义" class="headerlink" title="结构和定义"></a>结构和定义</h4><p>字符串的类型的定义在lobject.h第303行。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br/><span class="line"><span class="comment">** Header for string value; string bytes follow the end of this structure</span></span><br/><span class="line"><span class="comment">** (aligned according to &#39;UTString&#39;; see next).</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> {</span></span><br/><span class="line">  CommonHeader;</span><br/><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; &#34;has hash&#34; for longs */</span></span><br/><span class="line">  lu_byte shrlen;  <span class="comment">/* length for short strings */</span></span><br/><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;</span><br/><span class="line">  <span class="keyword">union</span> {</span><br/><span class="line">    <span class="keyword">size_t</span> lnglen;  <span class="comment">/* length for long strings */</span></span><br/><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">/* linked list for hash table */</span></span><br/><span class="line">  } u;</span><br/><span class="line">} TString;</span><br/></pre></td></tr></tbody></table></figure>
<p>为确保内存对齐使用结构体<code>UTString</code>又套了一层：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br/><span class="line"><span class="comment">** Ensures that address after this type is always fully aligned.</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> UTString {</span><br/><span class="line">  L_Umaxalign dummy;  <span class="comment">/* ensures maximum alignment for strings */</span></span><br/><span class="line">  TString tsv;</span><br/><span class="line">} UTString;</span><br/></pre></td></tr></tbody></table></figure>
<p>在<code>lstring.c</code>中有创建字符串的函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br/><span class="line"><span class="comment">** creates a new string object</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="function"><span class="keyword">static</span> TString *<span class="title">createstrobj</span> <span class="params">(lua_State *L, <span class="keyword">size_t</span> l, <span class="keyword">int</span> tag, <span class="keyword">unsigned</span> <span class="keyword">int</span> h)</span> </span>{</span><br/><span class="line">  TString *ts;</span><br/><span class="line">  GCObject *o;</span><br/><span class="line">  <span class="keyword">size_t</span> totalsize;  <span class="comment">/* total size of TString object */</span></span><br/><span class="line">  totalsize = sizelstring(l);</span><br/><span class="line">  o = luaC_newobj(L, tag, totalsize);</span><br/><span class="line">  ts = gco2ts(o);</span><br/><span class="line">  ts-&gt;hash = h;</span><br/><span class="line">  ts-&gt;extra = <span class="number">0</span>;</span><br/><span class="line">  getstr(ts)[l] = <span class="string">&#39;