---
layout: post
title: Lua之面向对象个人总结 
tags: [lua文章]
categories: [topic]
---
<hr/>
<blockquote>
<p>面向对象的三个特征：封装、继承和多态。Lua并没有类，没有直接实现<strong>面向对象</strong>的方法。不过Lua的Table，有内部对象和内部方法。Lua的面向对象主要是通过Table来模拟面向对象。</p>
</blockquote>
<hr/>

<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在<a href="Lua之Table学习.md">Lua之Table学习</a>中，曾以Computer为例子，介绍了Table 也是可以有自己内部的属性和方法。</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line">local CPU = { name = &#39;CPU&#39;, cost = 400 }</span><br/><span class="line">local Monitor = { name = &#39;bird&#39;, cost = 200 }</span><br/><span class="line">local Memory = { name = &#39;memory&#39;, cost = 100 }</span><br/><span class="line">local Computer = {</span><br/><span class="line">  description = &#34;this is a computer&#34;,</span><br/><span class="line">  cpu = CPU,</span><br/><span class="line">  monitor = Monitor,   </span><br/><span class="line">  memory = Memory</span><br/><span class="line">}</span><br/><span class="line">function Computer.getDescription()</span><br/><span class="line">    return Computer.description</span><br/><span class="line">end</span><br/><span class="line">print(Computer.getDescription())</span><br/><span class="line">&gt;</span><br/></pre></td></tr></tbody></table></figure>
</blockquote>
<p>上面的代码有几个问题<br/>1、没有构造函数，没办法实例化对象<br/>2、内部的方法更像Java中的静态方法，不需要有具体对象都能够调用。内部的成员更像静态成员。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/></pre></td><td class="code"><pre><span class="line">local Computer={}</span><br/><span class="line">Computer.cpu = { name = &#39;cpu&#39;,cost = 400 }</span><br/><span class="line">Computer.memory = {name = &#39;memory&#39;,cost = 200 }</span><br/><span class="line">Computer.monitor = {name = &#39;monitor&#39;,cost = 100 }</span><br/><span class="line">Computer.description = &#39;this is a computer&#39;</span><br/><span class="line">function Computer:getDescription()  --内部方法</span><br/><span class="line">    print(self.description)</span><br/><span class="line">end</span><br/><span class="line">function Computer:new ()  --构造函数</span><br/><span class="line">    t = {}</span><br/><span class="line">    setmetatable(t, { __index = self })</span><br/><span class="line">    return t</span><br/><span class="line">end</span><br/><span class="line">function Computer:getCost()   --内部方法</span><br/><span class="line">    cost =  self.cpu.cost + self.memory.cost + self.monitor.cost</span><br/><span class="line">    print(self.description..&#39;:cost &#39;.. cost)</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">c1=Computer:new()</span><br/><span class="line">c1.description = &#39;this is c1&#39;  --改变Computer实例化对象内部的description</span><br/><span class="line">c1:getDescription()</span><br/><span class="line">c1:getCost()</span><br/><span class="line"></span><br/><span class="line">c2=Computer:new()</span><br/><span class="line">c2.memory.cost = 900      --改变Computer实例化对象内部的memory.cost</span><br/><span class="line">c2:getDescription()</span><br/><span class="line">c2:getCost()</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>输出<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">this is c1  </span><br/><span class="line">this is c1:cost 700   --c2的memory.cost改变，c1不受影响</span><br/><span class="line">this is a computer    --c1的description改变，c2不受影响</span><br/><span class="line">this is a computer:cost 1400</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>改良后的代码，有了构造函数，能够实例化对象。上面实例化了两个对象c1和c2，内部成员相互独立，无法相互影响。</p>
<h4 id="访问成员"><a href="#访问成员" class="headerlink" title="访问成员"></a>访问成员</h4><p>使用点访问类内成员<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">c1.description = &#39;this is c1&#39;</span><br/></pre></td></tr></tbody></table></figure><p></p>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line">function getCost()  --普通函数</span><br/><span class="line">  --do something</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">function Computer:getCost() --成员函数，</span><br/><span class="line">  cost =  self.cpu.cost + self.memory.cost + self.monitor.cost</span><br/><span class="line">  print(self.description..&#39;:cost &#39;.. cost)</span><br/><span class="line">end</span><br/></pre></td></tr></tbody></table></figure>
<p>普通函数只需要function修饰就可以了，成员函数除了function 关键字还需要声明属于某个类。前面的Computer 表示这个是Computer 类的成员函数。之间需要用冒号(:)来连接。<br/>成员函数内部的self相当于Java 的this，表示实例对象自身。<br/>如果用普通函数声明为成员函数，调用自身成员需要传入self<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">function Computer.getDescription(self) --成员函数</span><br/><span class="line">    print(self.description)</span><br/><span class="line">end</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>实例对象访问成员函数通过冒号(:)访问，也可以通过点号(.)访问，后者访问时候需要传入self，即自身<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line">function Computer.getDescription(self)</span><br/><span class="line">    print(self.description)</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">function Computer:getCost()</span><br/><span class="line">    cost =  self.cpu.cost + self.memory.cost + self.monitor.cost</span><br/><span class="line">    print(self.description .. &#39;:cost &#39; .. cost)</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">c1:getCost() </span><br/><span class="line">c1.getCost(c1)</span><br/><span class="line">c1:getDescription()</span><br/><span class="line">c1.getDescription(c1)</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>输出<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">this is c1:cost 700 </span><br/><span class="line">this is c1:cost 700  --只用冒号(:)式声明getCost()，用点式(.)传入自身也能访问</span><br/><span class="line">this is c1   --只用点式(.)式声明getCost()，用冒号(:)式不传参也能访问</span><br/><span class="line">this is c1</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>可以看到两种成员函数声明方式是等价的，使用也是等价的。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>使用构造函数来为类的实例分配内存，每个类都有属于自己的内存并共享公共数据。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">function Computer:new ()  --构造函数</span><br/><span class="line">    t = {}</span><br/><span class="line">    setmetatable(t, { __index = self })</span><br/><span class="line">    return t</span><br/><span class="line">end</span><br/></pre></td></tr></tbody></table></figure><p></p>
<h5 id="构造函数本质上也是成员函数，同时需要使用关键字new-来说明这是一个构造函数。"><a href="#构造函数本质上也是成员函数，同时需要使用关键字new-来说明这是一个构造函数。" class="headerlink" title="构造函数本质上也是成员函数，同时需要使用关键字new 来说明这是一个构造函数。"></a>构造函数本质上也是成员函数，同时需要使用关键字new 来说明这是一个构造函数。</h5><p>为什么要用元表来构造呢，不能直接<code>return self</code>呢，下面举个例子，构造函数直接返回self<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/></pre></td><td class="code"><pre><span class="line">local Computer = {}</span><br/><span class="line">Computer.description = &#39;this is a computer&#39;</span><br/><span class="line"></span><br/><span class="line">function Computer:getDescription()</span><br/><span class="line">    print(self.description)</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">function Computer:new()</span><br/><span class="line">    return self</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">c1 = Computer:new()</span><br/><span class="line">c1.description = &#39;this is c1&#39;</span><br/><span class="line">c1:getDescription()</span><br/><span class="line">c2 = Computer:new()</span><br/><span class="line">c2:getDescription()</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>输出<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">this is c1</span><br/><span class="line">this is c1</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>按照思维，只改变了c1的description，c1和c2是独立的对象，c2应该不受影响才对。编译过程也没有报错，但是c2的description也被改变了。<br/>如果我们把self本身也看做一块独立的内存，实例化c1的时候，构造函数返回self，c1 -&gt; self,对象c1指向self的内存位置。在实例化c2的时候，构造函数也返回了self，c2也指向了self。改变c1的description，实质改变了self的description，这样c2读取的description，也受到了改变。</p>
<h5 id="如何正确地构造对象呢"><a href="#如何正确地构造对象呢" class="headerlink" title="如何正确地构造对象呢"></a>如何正确地构造对象呢</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">function Computer:new()</span><br/><span class="line">    t = {}</span><br/><span class="line">    setmetatable(t, { __index = self })</span><br/><span class="line">    return t</span><br/><span class="line">end</span><br/></pre></td></tr></tbody></table></figure>
<p>这个构造函数，先是构造了一个空表t，然后把self传入到__index元方法，作为元表。最后返回t对象。</p>
<blockquote>
<p>Lua查找一个表元素时的规则，其实就是如下3个步骤:<br/>1.在表中查找，如果找到，返回该元素，找不到则继续<br/>2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续。<br/>3.判断元表有没有__index 方法，如果__index 方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。  </p>
</blockquote>
<p>Lua的“面向对象”，实质上是利用表和元表制造的一层层“嵌套关系”。<code>c1.description = &#39;this is c1&#39;</code>这行函数，本质上没有改变self的值，而是在c1对象中增加了description这一属性，因为在表中已经找到了，所以就不会访问元表中的description属性，造成‘改写’这现象。而如果访问的是cpu这个属性，因为c1中找不到，会访问元表，然后直到找到为止。如果访问gpu这个不存在的属性，会一直找下去，直到元方法__index为nil时退出。<br/>下面的代码应该可以验证这一猜想。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line">c1 = Computer:new()</span><br/><span class="line">print(&#39;before init description&#39;)</span><br/><span class="line">for k, v in pairs(c1) do</span><br/><span class="line">    print(k, v)       </span><br/><span class="line">end</span><br/><span class="line">print(c1.description)</span><br/><span class="line">c1.description = &#39;this is c1&#39;</span><br/><span class="line">print(&#39;after init description&#39;)</span><br/><span class="line">for k, v in pairs(c1) do</span><br/><span class="line">    print(k, v)</span><br/><span class="line">end</span><br/><span class="line">print(c1.description)</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>输出：在<code>c1.description = &#39;this is c1&#39;</code>前key-value是没有任何输出的，说明c1没有这些东西（不包括元表的部分）,但是又确确实实能输出（因为找不到就会访问元表）。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">before init description</span><br/><span class="line">this is a computer</span><br/><span class="line">after init description</span><br/><span class="line">description	this is c1</span><br/><span class="line">this is c1</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>上面是无参的构造函数，如果是有参的，需要在构造函数中同时改变self中的值。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line">function Computer:new(description)</span><br/><span class="line">    local o = {}</span><br/><span class="line">    setmetatable(o, self)</span><br/><span class="line">    self.__index = self</span><br/><span class="line">    self.description = description</span><br/><span class="line">    return o</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">c1 = Computer:new(&#39;init description&#39;)</span><br/><span class="line">print(&#39;c1 before&#39;, c1.description)   --c1 before	init description</span><br/><span class="line">c1.description = &#39;this is c1&#39;</span><br/><span class="line">print(&#39;c1 after&#39;, c1.description)   --c1 after	this is c1</span><br/><span class="line">c2 = Computer:new()</span><br/><span class="line">print(&#39;c2&#39;, c2.description)         --c2	nil</span><br/></pre></td></tr></tbody></table></figure><p></p>
<hr/>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在介绍Lua封装的时候，说过封装利用的是表与元表之间的‘层层嵌套’关系。这不多不少也体验了继承的思想。Lua的继承正是基于这种‘层层嵌套’的思想。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/></pre></td><td class="code"><pre><span class="line">local Shape = {} --定义基类</span><br/><span class="line">Shape.area = 0   --基类的成员area</span><br/><span class="line">function Shape:new()</span><br/><span class="line">    local s = {}</span><br/><span class="line">    setmetatable(s, self)</span><br/><span class="line">    self.__index = self</span><br/><span class="line">    return s</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">function Shape:getArea()    --父类方法，可见子类也能访问</span><br/><span class="line">    return self.area</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">local Square = Shape:new()   --关键语句，Square继承Shape</span><br/><span class="line">function Square:new(side)    --Square的构造函数</span><br/><span class="line">    local s = {}</span><br/><span class="line">    setmetatable(s, self)</span><br/><span class="line">    self.__index = self       --关键语句，元方法__index为空时候不会向元表查找area值</span><br/><span class="line">    s.side = side or 0        --Square自身定义了成员变量side</span><br/><span class="line">    self.area = side * side   --改变基类的area的值</span><br/><span class="line">    return s</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">local square = Square:new(10)</span><br/><span class="line">print(&#39;square side&#39;, square.side)  --square side	10</span><br/><span class="line">print(&#39;square area&#39;, square:getArea())  --square area	100</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>这个例子，定义了一个基类图像Share，拥有成员area，然后正方形Square继承了Share，增加成员变量side，并重写构造函数。派生类拥有父类的方法和属性。<br/>对比下Java的实现<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line">class Share {</span><br/><span class="line">    double area = 0;</span><br/><span class="line">    double getArea(){</span><br/><span class="line">        return area;</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/><span class="line">class Square extends Share {</span><br/><span class="line">    double size;</span><br/><span class="line">    Square(double size) {</span><br/><span class="line">        this.size = size;</span><br/><span class="line">        area = size * size;</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>上面例子中，面积的计算放在了构造函数中，总有一点不妥。假装我们对面向对象思想很熟悉了，写出的Java代码应该是这样的<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/></pre></td><td class="code"><pre><span class="line">abstract class Share {</span><br/><span class="line">    double area = 0;</span><br/><span class="line">    abstract void calcArea();</span><br/><span class="line">}</span><br/><span class="line">class Square extends Share {</span><br/><span class="line">    double size;</span><br/><span class="line">    Square(double size) {</span><br/><span class="line">        this.size = size;</span><br/><span class="line">    }</span><br/><span class="line">    @Override</span><br/><span class="line">    void calcArea() {</span><br/><span class="line">        area = size * size;</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line">class Circle extends Share {</span><br/><span class="line">    double radius;</span><br/><span class="line">    Circle(double radius) {</span><br/><span class="line">        this.radius = radius;</span><br/><span class="line">    }</span><br/><span class="line">    @Override</span><br/><span class="line">    void calcArea() {</span><br/><span class="line">        area = 3.14 * radius * radius;</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>通过对calcArea的不同实现，在不同的子类完成不同的计算。这是多态的体现。Lua也可以，子类通过重写父类的方法实现不同的实现。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/></pre></td><td class="code"><pre><span class="line">local Shape = {}</span><br/><span class="line">Shape.area = 0</span><br/><span class="line">function Shape:new()</span><br/><span class="line">    local s = {}</span><br/><span class="line">    setmetatable(s, self)</span><br/><span class="line">    self.__index = self</span><br/><span class="line">    return s</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">function Shape:getArea()</span><br/><span class="line">    return self.area</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">local Square = Shape:new()</span><br/><span class="line">function Square:new(side)</span><br/><span class="line">    local s = {}</span><br/><span class="line">    setmetatable(s, self)</span><br/><span class="line">    self.__index = self</span><br/><span class="line">    s.side = side or 0</span><br/><span class="line">    return s</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">function Square:getArea()</span><br/><span class="line">    return &#39;I am Square s function&#39;, self.side * self.side</span><br/><span class="line">end</span><br/><span class="line"></span><br/><span class="line">local square = Square:new(10)</span><br/><span class="line">print(&#39;square side&#39;, square.side)</span><br/><span class="line">print(&#39;square area&#39;, square:getArea())</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>上面的代码有两个getArea函数，其中子类Square复写了父类Share的getArea，并按新内容输出。<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">square side	10</span><br/><span class="line">square area	I am Square s function	100</span><br/></pre></td></tr></tbody></table></figure><p></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/yyxt/p/4224784.html" target="_blank" rel="noopener noreferrer">lua中类的实现原理和实践</a><br/><a href="http://www.runoob.com/lua/lua-object-oriented.html" target="_blank" rel="noopener noreferrer">Lua 面向对象</a><br/><a href="https://www.jianshu.com/p/467840d7ad13" target="_blank" rel="noopener noreferrer">Lua面向对象编程详解</a>  </p>