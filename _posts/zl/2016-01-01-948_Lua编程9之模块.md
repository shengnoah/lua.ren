---
layout: post
title: Lua编程9之模块 
tags: [lua文章]
categories: [topic]
---
<p>思考并回答以下问题：<br/>1.如何创建一个模块？<br/>2.私有函数如何声明？<br/>3.return tab1必须和模块同一名称吗？<br/>4.如何引用一个模块？别名如何使用？<br/>5.原生lua文件加载路径如何查看？<br/>6.xLua加载方式是怎样的？建议的加载Lua脚本方式是什么？<br/>7.什么是自定义Loader？如何自定义Loader？</p>

<p>用Lua写代码不可能把所有代码都写一个文件里，不同文件之间如何引用呢？Lua中也有模块的机制，类似C#中封装的命名空间。</p>
<p>模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p>
<p>Lua 的模块是由变量、函数等已知元素组成的 table，因此<span style="color:red">创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行</span>。以下为创建自定义模块 module.lua，文件代码格式如下：<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br/><span class="line">module = {}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 定义一个常量</span></span><br/><span class="line">module.constant = <span class="string">&#34;这是一个常量&#34;</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 定义一个函数</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&#34;这是一个公有函数！n&#34;</span>)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;这是一个私有函数！&#34;</span>)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br/><span class="line">    func2()</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">return</span> module</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。</p>
<p>上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.</p>
<h2 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a><span style="color:#EF7060;">require 函数</span></h2><p>Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#34;&lt;模块名&gt;&#34;</span>)</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>或者<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">&#34;&lt;模块名&gt;&#34;</span></span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module.lua 文件</span></span><br/><span class="line"><span class="comment">-- module 模块为上文提到到 module.lua</span></span><br/><span class="line"><span class="built_in">require</span>(<span class="string">&#34;module&#34;</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(module.constant)</span><br/><span class="line"></span><br/><span class="line">module.func3()</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>以上代码执行结果为：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">这是一个常量</span><br/><span class="line">这是一个私有函数！</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>或者给加载的模块定义一个别名变量，方便调用：<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module2.lua 文件</span></span><br/><span class="line"><span class="comment">-- module 模块为上文提到到 module.lua</span></span><br/><span class="line"><span class="comment">-- 别名变量 m</span></span><br/><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">&#34;module&#34;</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(m.constant)</span><br/><span class="line"></span><br/><span class="line">m.func3()</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>以上代码执行结果为：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">这是一个常量</span><br/><span class="line">这是一个私有函数！</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p><strong> <span style="color:red">标准Lua中的加载机制</span> </strong></p>
<p>对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。</p>
<p>require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。</p>
<p>在lua中可以使用<span style="color:red">print (package.path)</span>来查看当前的搜索路径。</p>
<p>我的打印出来是这样的：<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line">C:Program FilesUnityHubEditor<span class="number">2018.3</span><span class="number">.6</span>f1Editorlua?.lua;</span><br/><span class="line">C:Program FilesUnityHubEditor<span class="number">2018.3</span><span class="number">.6</span>f1Editorlua?init.lua;</span><br/><span class="line">C:Program FilesUnityHubEditor<span class="number">2018.3</span><span class="number">.6</span>f1Editor?.lua;</span><br/><span class="line">C:Program FilesUnityHubEditor<span class="number">2018.3</span><span class="number">.6</span>f1Editor?init.lua;</span><br/><span class="line">C:Program FilesUnityHubEditor<span class="number">2018.3</span><span class="number">.6</span>f1Editor..sharelua<span class="number">5.3</span>?.lua;</span><br/><span class="line">C:Program FilesUnityHubEditor<span class="number">2018.3</span><span class="number">.6</span>f1Editor..sharelua<span class="number">5.3</span>?init.lua;</span><br/><span class="line">.?.lua;</span><br/><span class="line">.?init.lua</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>那么调用 require(“module”) 时就会尝试从搜索路径中从前到后的顺序去搜索lua文件。</p>
<p>如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。</p>
<p>C 程序库搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。</p>
<p>搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。</p>
<h2 id="xLua中的模块加载"><a href="#xLua中的模块加载" class="headerlink" title="xLua中的模块加载"></a><span style="color:#EF7060;">xLua中的模块加载</span></h2><p>xLua中require实际上是调一个个的loader去加载，有一个成功就不再往下尝试，全失败则报文件找不到。</p>
<p>在xLua中，模块加载在Unity有些因地制宜的loader。目前xLua除了原生的loader外，还添加了从Resource和StreamingAssets（从StreamingAssets加载已被标记弃用，不建议使用）加载的loader，需要注意的是因为Resource只支持有限的后缀，放Resources下的lua文件得加上txt后缀，比如文件名需要命名成<span style="color:red">module.lua.txt</span>。</p>
<p>可以从xLua的LuaEnv.cs的第108行看到：<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">AddSearcher(StaticLuaCallbacks.LoadFromResource, <span class="number">4</span>);</span><br/><span class="line">AddSearcher(StaticLuaCallbacks.LoadFromStreamingAssetsPath, <span class="number">-1</span>);</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>建议的加载Lua脚本方式是：整个程序就一个DoString(“require ‘main’”)，然后在main.lua中require加载其它脚本。</p>
<p>要是我的Lua文件是下载回来的，或者某个自定义的文件格式里头解压出来，或者需要解密等等，怎么办？<br/>xLua的自定义Loader可以满足这些需求。</p>
<p><strong> <span style="color:red">自定义Loader</span> </strong></p>
<p>在xLua加自定义loader是很简单的，只涉及到一个接口：<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">public delegate <span class="built_in">byte</span>[] CustomLoader(ref <span class="built_in">string</span> filepath);</span><br/><span class="line">public void LuaEnv.AddLoader(CustomLoader loader)</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>通过AddLoader可以注册个回调，该回调参数是字符串，lua代码里头调用require时，参数将会透传给回调，回调中就可以根据这个参数去加载指定文件，如果需要支持调试，需要把filepath修改为真实路径传出。</p>
<p>该回调返回值是一个byte数组，如果为空表示该loader找不到，否则则为lua文件的内容。 有了这个就简单了，所有你自己的流程都可以处理。比如：<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line">luaenv.AddLoader((ref <span class="built_in">string</span> filename) =&gt; {</span><br/><span class="line">     <span class="keyword">if</span> (filename == <span class="string">&#34;InMemory&#34;</span>)</span><br/><span class="line">     {</span><br/><span class="line">         <span class="built_in">string</span> script = <span class="string">&#34;return {ccc = 9999}&#34;</span>;</span><br/><span class="line">         <span class="keyword">return</span> System.Text.Encoding.UTF8.GetBytes(script);</span><br/><span class="line">     }</span><br/><span class="line">     <span class="keyword">return</span> null;</span><br/><span class="line"> });</span><br/><span class="line">luaenv.DoString(<span class="string">&#34;print(&#39;InMemory.ccc=&#39;, require(&#39;InMemory&#39;).ccc)&#34;</span>);</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>完整示例见XLuaTutorialLoadLuaScriptLoader</p>