---
layout: post
title: lua脚本操作redis数据库介绍 
tags: [lua文章]
categories: [topic]
---
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 为什么要用lua脚本操作redis数据库?<br/>1.减少开销—减少向redis服务器的请求次数<br/>2.原子操作—redis将lua脚本作为一个原子执行<br/>3.可复用—其他客户端可以使用已经执行过的lua脚本<br/>4.增加redis灵活性—lua脚本可以帮助redis做更多的事情</p>
<p>lua脚本本身体积小,启动速度快.</p>
<p>因此,从redis 2.6.0开始,redis在服务器端内置lua解释器<br/></p>
<h2 id="EVAL命令语法"><a href="#EVAL命令语法" class="headerlink" title="EVAL命令语法"></a>EVAL命令语法</h2><p>EVAL script numkeys key [key …] arg [arg …]</p>
<p>EVAL  —-lua程序的运行环境上下文<br/>script   —-lua脚本<br/>numkeys —-参数的个数(key的个数)<br/>key  —-redis键   访问下标从1开始,例如:KEYS[1]<br/>arg  —-redis键的附加参数</p>
<h3 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h3><p>EVAL和EVALSHA用redis内置的lua编译器执行脚本<br/>举例说明:<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; eval &#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&#34; 2 username password test 123456</div><div class="line">1) &#34;username&#34;</div><div class="line">2) &#34;password&#34;</div><div class="line">3) &#34;test&#34;</div><div class="line">4) &#34;123456&#34;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></tbody></table></figure><p></p>
<p>上面lua脚本的意思是返回以lua数组的形式返回key1,key2和value1,value2,2是key的个数.</p>
<h3 id="lua函数"><a href="#lua函数" class="headerlink" title="lua函数"></a>lua函数</h3><p>主要有两个函数来执行redis命令<br/>redis.call()   —  出错时返回具体错误信息,并且终止脚本执行<br/>redis.pcall()  —出错时返回lua  table的包装错误,但不引发错误<br/>举例说明:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; eval &#34;return redis.call(&#39;set&#39;,KEYS[1],ARGV[1])&#34; 1 name  redis</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></tbody></table></figure>
<p>该脚本中的函数作用是类似于执行  set  name redis   的redis命令.并返回执行结果,ok</p>
<p>redis.call()出错时:<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; eval &#34;return redis.call(&#39;get&#39;,KEYS[1],ARGV[1])&#34; 1 name  redis</div><div class="line">(error) ERR Error running script (call to f_b943d620b079a29d99eccaaa7317e05f8eb8ce88): @user_script:1: @user_script: 1: Wrong number of args calling Redis command From Lua script </div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></tbody></table></figure><p></p>
<p>redis.pcall()出错时:<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; eval &#34;return redis.pcall(&#39;get&#39;,KEYS[1],ARGV[1])&#34; 1 name  redis</div><div class="line">(error) @user_script: 1: Wrong number of args calling Redis command From Lua script</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></tbody></table></figure><p></p>
<h2 id="lua与redis数据类型转换"><a href="#lua与redis数据类型转换" class="headerlink" title="lua与redis数据类型转换"></a>lua与redis数据类型转换</h2><p>lua通过redis.call()或者redis.pcall()函数执行redis命令的返回值被转换成了lua数据结构,当然了,当lua脚本在redis的内置解释器里运行时,lua脚本的返回值也会被转换成redis数据结构,然后由EVAL将值返回给客户端.</p>
<p>那么lua和redis数据类型之间时如何转换的呢?对应关系又是怎样的呢?</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>redis数据类型</th>
<th>lua数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>integer</td>
<td>number</td>
</tr>
<tr>
<td>bulk</td>
<td>string</td>
</tr>
<tr>
<td>multi bulk</td>
<td>table</td>
</tr>
<tr>
<td>status</td>
<td>包含ok域的table</td>
</tr>
<tr>
<td>error</td>
<td>包含err域的table</td>
</tr>
<tr>
<td>nil bulk</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>
<p>从redis数据类型到lua数据类型或者从lua数据类型到redis数据类型,都有以上对应规则,但是从</p>
<p><em>从lua转换到redis有一条额外的对应规则</em></p>
<ul>
<li>lua boolean  true   —&gt;   redis   1<br/>即,lua的true对应redis 的整型1.</li>
</ul>
<h2 id="EVAL和EVALSHA"><a href="#EVAL和EVALSHA" class="headerlink" title="EVAL和EVALSHA"></a>EVAL和EVALSHA</h2><p>EVAL命令在每次执行脚本时,都发送一次脚本主体,而EVALSHA并非如此,它的第一个参数时脚本的sha1校验和.</p>
<p>EVALSHA命令的机制如下:</p>
<ul>
<li>如果服务器记得SHA1校验和指定的脚本,那么执行该脚本</li>
<li>如果服务器不记得SHA1校验和指定的脚本,那么它返回一个错误,提醒用户使用EVAl代替EVALSHA</li>
</ul>
<p>因此在脚本主体不变的情况下使用EVALSHA,可以使脚本复用,而<strong>节省带宽</strong></p>
<h2 id="lua脚本要求"><a href="#lua脚本要求" class="headerlink" title="lua脚本要求"></a>lua脚本要求</h2><p><strong>脚本需要被写成纯函数</strong></p>
<p> 对于同样的数据输入,给定相同的参数,脚本执行的redis写命令的结果总是相同的.<br/>为此,redis做了以下事情:</p>
<ul>
<li>lua没有访问系统时间或者其他内部状态的命令</li>
<li>redis阻止上面所提到的脚本执行</li>
<li>lua脚本调用返回序命令的返回数据会被排序(字典序.)</li>
<li>对 Lua 的伪随机数生成函数 math.random 和 math.randomseed 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值.</li>
</ul>
<p><strong>不允许创建全局变量</strong></p>
<p>为了防止数据泄露进lua环境,redis脚本不循序创建全局变量.</p>
<p>访问一个全局变量(无论是否存在)都会引起脚本停止</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用lua操作redis数据库能够带来很多便利,后续将提供实例展示lua脚本是如何操作redis数据库的.</p>