---
layout: post
title: Lua Key 
tags: [lua文章]
categories: [topic]
---

    1
    
    2
    
    3
    
    4
    
    5
    
    6
    
    7
    
    8
    
    9
    
    10
    
    11
    
    12
    
    13
    
    14
    
    15
    
    16
    
    17
    
    18
    
    19
    
    20
    
    21
    
    22
    
    23
    
    24
    
    25
    
    26
    
    27
    
    28
    
    29
    
    30
    
    31
    
    32
    
    33
    
    34
    
    35
    
    36
    
    37
    
    38
    
    39
    
    40

|

    
    
    -- 查询读取按键
    
    KEY = 3
    
    LEDB = 5 
    
    LEDR = 6
    
    LEDG = 7
    
    gpio.mode(KEY,gpio.INPUT)
    
    gpio.mode(LEDB,gpio.OUTPUT)
    
    gpio.mode(LEDR,gpio.OUTPUT)
    
    gpio.mode(LEDG,gpio.OUTPUT)
    
    gpio.write(LEDB,gpio.LOW)
    
    gpio.write(LEDR,gpio.LOW)
    
    gpio.write(LEDG,gpio.LOW)
    
    function checkKey()
    
    	if gpio.read(KEY) == 0 then
    
    		keyCnt = keyCnt + 1
    
    		gpio.write(LEDR,gpio.HIGH)
    
    		print("pressing")
    
    	else
    
    		if keyCnt >= 50 then
    
    			print("---long pressed(ms):"..(keyCnt*100))
    
    		end
    
    		
    
    		if keyCnt >= 2 and keyCnt < 50 then
    
    			print("short pressed(ms):"..(keyCnt*100))
    
    		end
    
    		
    
    		keyCnt = 0
    
    		gpio.write(LEDR,gpio.LOW)
    
    	end
    
    end
    
    function gpioInit()
    
    	keyCnt = 0
    
    	tmr.alarm(0,100,tmr.ALARM_AUTO,checkKey)
    
    end
    
    gpioInit()  
  
---|---  
  
按键为3 pin，所以设置KEY = 3。接着设置按键的gpio模式为输入模式，初始化三色LED的状态。  
按键 **按下时为低电平，不按时为高电平**
。因此使用定时器创建一个任务定时查询KEY的状态，如果按键按下了那么就输出按下的信息，点亮LED并使计数器keyCnt自增。松开按键时，通过计数器数值的大小判断是长按还是短按。
最后将计数器置零，并关闭LED。

    
    
    1
    
    2
    
    3
    
    4
    
    5
    
    6
    
    7
    
    8
    
    9
    
    10
    
    11
    
    12
    
    13
    
    14
    
    15
    
    16
    
    17
    
    18
    
    19
    
    20
    
    21
    
    22
    
    23
    
    24
    
    25
    
    26
    
    27
    
    28
    
    29
    
    30
    
    31
    
    32
    
    33
    
    34
    
    35

|

    
    
    --中断方式
    
    KEY = 3
    
    LEDB = 5 
    
    LEDR = 6
    
    LEDG = 7
    
    gpio.mode(KEY,gpio.INT)
    
    gpio.mode(LEDB,gpio.OUTPUT)
    
    gpio.mode(LEDR,gpio.OUTPUT)
    
    gpio.mode(LEDG,gpio.OUTPUT)
    
    gpio.write(LEDB,gpio.LOW)
    
    gpio.write(LEDR,gpio.LOW)
    
    gpio.write(LEDG,gpio.LOW)
    
    down = 0
    
    up = 0 
    
    press = 0
    
    count = 0
    
    gpio.trig(KEY,"down",
    
    function()
    
    	count=count+1
    
    	gpio.write(LEDG,gpio.HIGH)
    
    	if(count%2==1) then
    
    		down = tmr.now()/1000000
    
    	else
    
    		up = tmr.now()/1000000
    
    		press = up - down
    
    		print("pressed time(s):"..press)
    
    		gpio.write(LEDG,gpio.LOW)
    
    	end
    
    end
    
    )  
  
---|---  
  
[gpio.trig()](https://nodemcu.readthedocs.io/en/master/en/modules/gpio/)  
原型： gpio.trig(pin, type, function())  
作用： 设置管脚中断模式的回调函数  
参数：

  1. 管脚号
  2. 取值方式，”up”, “down”, “both”, “low”, “high”, 分别代表上升沿、下降沿、双边沿、低电平、高电平触发方式
  3. 中断时执行的函数

tmr.now()  
原型： tmr.now()  
作用： 获取系统计数器的当前值，单位微秒us

首先设置KEY管脚为中断模式，接着通过 **gpio.trig( )** 设置中断产生时要执行的动作。由于 **按下时为低电平，不按时为高电平**
，所以当按键按下时会产生一个下降沿，松开时会产生一个上升沿。这里设置有下降沿时运行回调函数，函数运行时让count自增，用于记录按下按钮的次数，然后点亮LED。当奇数次按下KEY时，通过
**tmr.now()** 获取一个时间，当偶数次按下KEY时输出两次的时间间隔并熄灭LED。  
这里采用了 **down** 下降沿触发，所以按下KEY后LED会一直常亮，如果想要第一个程序的效果，即按键按下时LED亮，松开时LED灭，可以采用
**both** 双边沿触发方式。