---
layout: post
title: Lua学习笔记(6)table.sort 
tags: [lua文章]
categories: [topic]
---
<p>[TOC]</p>


<p>简单来说就是table.sort的第二个参数支持自定义比较函数，这类似于c++的容器支持自定义比较函数一样，代码如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local tbTest = {
	{1, 3},
	{3, 5},
	{5, 4},
	{2, 3},
}

-- 比较函数
function cmp(a, b)
	return a[2] &lt; b[2]
end

-- 通常用法
table.sort(tbTest, cmp)
</code></pre></div></div>

<h1 id="深入学习">深入学习</h1>
<p>在自己工作过程中，遇到过下面两个问题</p>

<h2 id="1自定义排序算法的问题">1.自定义排序算法的问题</h2>
<p>第一个问题是：当自定义比较函数出现比较两个参数时，无法严格给出一个结果，就会出现错误。用官方的说法是比较函数需要满足非对称和传递性质。对于这两个性质，可以回忆一下中学时候学的不等式相关性质，也可以看看《c++标准程序库》中介绍的比较函数排序准则[1]。官网文档说明如下：</p>

<blockquote>
  <p>Note that the comp function must define a strict partial order over the elements in the list; that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.</p>
</blockquote>

<p>拿上面的代码举例，当把比较函数改为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- 比较函数
function cmp(a, b)
	return a[2] &lt;= b[2]
end
</code></pre></div></div>

<p>这个时候就会出现下面的错误：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> attempt to index local &#39;b&#39; (a nil value)
</code></pre></div></div>

<p>因为，这个时候元素a={1, 3}和b={2, 3}的a[2] == b[2]，a[2] &lt;= b[2]和b[2] &lt;= a[2]都成立。所以这个是比较函数是symmetric的。</p>

<h2 id="2面向对象方式的问题">2.面向对象方式的问题</h2>
<p>在工作中，写比较大的功能的时候，会经常用到lua的面向对象的方式编码。一开始无知的时候，会写下面的代码，结果后面的苦头自己吃了。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local tbSort = {25, 18, 15}
--面向对象隐藏self
function tbSort:fCompWrap(a, b)
	print(&#34;fCompWrap(self, a, b)&#34;, self, a, b)
	return a &lt; b;
end
-- 比较
table.sort(tbSort, tbSort.fCompWrap)
</code></pre></div></div>

<p>结果，往往是比较函数报错，第二个参数为nil</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>attempt to compare number with nil
</code></pre></div></div>

<p>只要理解’.’和’:’的区别就可以了，后面的’:’会使得函数的第一个参数为self。所以下面的一种写法可以解决问题：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--面向对象
function tbSort.fComp(a, b)
	return a &lt; b;
end
</code></pre></div></div>

<p>当然，最好可以用闭包的比较函数，就省掉了这许多麻烦。一点点的总结：</p>

<ul>
  <li>table.sort的比较函数在面向对象编程时候要注意了</li>
  <li>lua面向对象中的self要理解：table:func(param) 等价于table.func(self, param)</li>
  <li>table:func定义式在作为参数(table.func)传递之后使用，默认就是table:func的调用形式，也就是第一个参数为self</li>
  <li>应该理解function table:func(param)的定义形式等价于function table.func(self, param)，这样更容易分的清楚</li>
</ul>

<h2 id="源码的简单分学习">源码的简单分学习</h2>
<p>关于问题1中的报错，可以看一下源码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (;;) {  /* invariant: a[l..i] &lt;= P &lt;= a[j..u] */
  /* repeat ++i until a[i] &gt;= P */
  while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
    if (i&gt;u) luaL_error(L, &#34;invalid order function for sorting&#34;);
    lua_pop(L, 1);  /* remove a[i] */
  }
  /* repeat --j until a[j] &lt;= P */
  while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
    if (j&lt;l) luaL_error(L, &#34;invalid order function for sorting&#34;);
    lua_pop(L, 1);  /* remove a[j] */
  }
  if (j&lt;i) {
    lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
    break;
  }
  set2(L, i, j);
}
</code></pre></div></div>

<p>有几点不一样的地方</p>

<ul>
  <li>lua源码中的快速排序，是用大循环代替了pivot的另外一部分排序。一般我们自己写快排的时候，会递归调两次，小于pivot的一部分和大于pivot的一部分</li>
  <li>递归++i和++j的while，一般自己在写的时候会同时检查比较函数的结果和i、j的大小，防止越界</li>
</ul>

<h1 id="参考补充">参考补充</h1>
<ul>
  <li>[1]《c++标准程序库》</li>
</ul>

<p>所谓的“排序准则”，必须定义strict weak ordering，其意义如下：</p>

<ol>
  <li>必须是“反对称的(antisymmetric)”
对operator&lt;而言，如果x&lt;y为真，则y&lt;x为假。</li>
  <li>必须是“可传递的（transitive）”
对operator&lt;而言，如果x&lt;y为真且y&lt;z为真，则x&lt;z为真。</li>
  <li>必须是“非自反的（irreflexive）”
对operator&lt;而言，x&lt;x永远为假。</li>
</ol>