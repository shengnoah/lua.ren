---
layout: post
title: lua 
tags: [lua文章]
categories: [topic]
---
<h2 id="lua-resty-lrucache深入解析"><a href="#lua-resty-lrucache深入解析" class="headerlink" title="lua-resty-lrucache深入解析"></a>lua-resty-lrucache深入解析</h2><p>lua-resty-lrucache是openresty里常用的缓存，是一个worker级别的缓存，也是一个最近最少使用的缓存，下面我们来具体分析它的实现过程。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> _M = {}</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> lrucache = <span class="built_in">require</span> <span class="string">&#34;resty.lrucache.pureffi&#34;</span></span><br/><span class="line"><span class="keyword">local</span> c, err = lrucache.new(<span class="number">200</span>)  </span><br/><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> c <span class="keyword">then</span></span><br/><span class="line">    <span class="built_in">error</span>(<span class="string">&#34;failed to create the cache: &#34;</span> .. (err <span class="keyword">or</span> <span class="string">&#34;unknown&#34;</span>))</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> _M.go<span class="params">()</span></span></span><br/><span class="line">    c:set(<span class="string">&#34;dog&#34;</span>, <span class="number">32</span>)</span><br/><span class="line">    c:set(<span class="string">&#34;cat&#34;</span>, <span class="number">56</span>)</span><br/><span class="line">    ngx.say(<span class="string">&#34;dog: &#34;</span>, c:get(<span class="string">&#34;dog&#34;</span>))</span><br/><span class="line">    ngx.say(<span class="string">&#34;cat: &#34;</span>, c:get(<span class="string">&#34;cat&#34;</span>))</span><br/><span class="line"></span><br/><span class="line">    c:set(<span class="string">&#34;dog&#34;</span>, { age = <span class="number">10</span> }, <span class="number">0.1</span>)  <span class="comment">-- expire in 0.1 sec</span></span><br/><span class="line">    c:delete(<span class="string">&#34;dog&#34;</span>)</span><br/><span class="line"></span><br/><span class="line">    c:flush_all()  <span class="comment">-- flush all the cached data</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">return</span> _M</span><br/></pre></td></tr></tbody></table></figure>
<p>可以看到lua-resty-lrucache的使用过程很简单，首先初始化，调用new方法，设值用set，取值用get，和我们平常使用的缓存组件基本上都是一样的。</p>
<h3 id="lua-resty-lrucache初始化"><a href="#lua-resty-lrucache初始化" class="headerlink" title="lua-resty-lrucache初始化"></a>lua-resty-lrucache初始化</h3><p>首先看一下lua-resty-lrucache的初始化过程，这里我们按size为4来进行初始化，初始化后的数据结构如下：</p>
<p><img src="http://chenmutian.com//2019/08/27/lua-resty-lrucache/lua-resty-lrucache-one.jpg" alt="lua-resty-lrucache-one"/></p>
<p>我们看一下代码的实现过程：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/><span class="line">60</span><br/><span class="line">61</span><br/><span class="line">62</span><br/><span class="line">63</span><br/><span class="line">64</span><br/><span class="line">65</span><br/><span class="line">66</span><br/><span class="line">67</span><br/><span class="line">68</span><br/><span class="line">69</span><br/><span class="line">70</span><br/><span class="line">71</span><br/><span class="line">72</span><br/><span class="line">73</span><br/><span class="line">74</span><br/><span class="line">75</span><br/><span class="line">76</span><br/><span class="line">77</span><br/><span class="line">78</span><br/><span class="line">79</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据size来初始化cache,</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> _M.new<span class="params">(size, load_factor)</span></span></span><br/><span class="line">    <span class="keyword">if</span> size &lt; <span class="number">1</span> <span class="keyword">then</span></span><br/><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&#34;size too small&#34;</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">    <span class="comment">-- Determine bucket size, which must be power of two.</span></span><br/><span class="line">    <span class="keyword">local</span> load_f = load_factor</span><br/><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> load_factor <span class="keyword">then</span></span><br/><span class="line">        load_f = <span class="number">0.5</span></span><br/><span class="line">    <span class="keyword">elseif</span> load_factor &gt; <span class="number">1</span> <span class="keyword">then</span></span><br/><span class="line">        load_f = <span class="number">1</span></span><br/><span class="line">    <span class="keyword">elseif</span> load_factor &lt; <span class="number">0.1</span> <span class="keyword">then</span></span><br/><span class="line">        load_f = <span class="number">0.1</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">    <span class="comment">-- bucket_sz的值为最小的大于bs_min的2的倍数</span></span><br/><span class="line">    <span class="keyword">local</span> bs_min = size / load_f</span><br/><span class="line">    <span class="comment">-- The bucket_sz *MUST* be a power-of-two. See the hash_string().</span></span><br/><span class="line">    <span class="keyword">local</span> bucket_sz = <span class="number">1</span></span><br/><span class="line">    <span class="keyword">repeat</span></span><br/><span class="line">        bucket_sz = bucket_sz * <span class="number">2</span></span><br/><span class="line">    <span class="keyword">until</span> bucket_sz &gt;= bs_min</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">local</span> self = {</span><br/><span class="line">        size = size,</span><br/><span class="line">        bucket_sz = bucket_sz,</span><br/><span class="line">        free_queue = queue_init(size),</span><br/><span class="line">        cache_queue = queue_init(<span class="number">0</span>),</span><br/><span class="line">        node_v = <span class="literal">nil</span>,</span><br/><span class="line">        key_v = new_tab(size, <span class="number">0</span>),</span><br/><span class="line">        val_v = new_tab(size, <span class="number">0</span>),</span><br/><span class="line">        bucket_v = ffi_new(int_array_t, bucket_sz),</span><br/><span class="line">        num_items = <span class="number">0</span>,</span><br/><span class="line">    }</span><br/><span class="line">    <span class="comment">-- &#34;note_v&#34; is an array of all the nodes used in the LRU queue. Exprpession</span></span><br/><span class="line">    <span class="comment">-- node_v[i] evaluates to the element of ID &#34;i&#34;.</span></span><br/><span class="line">    self.node_v = self.free_queue</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">-- Allocate the array-part of the key_v, val_v, bucket_v.</span></span><br/><span class="line">    <span class="comment">--local key_v = self.key_v</span></span><br/><span class="line">    <span class="comment">--local val_v = self.val_v</span></span><br/><span class="line">    <span class="comment">--local bucket_v = self.bucket_v</span></span><br/><span class="line">    ffi_fill(self.bucket_v, ffi_sizeof(int_t, bucket_sz), <span class="number">0</span>)</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(self, mt)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="params">(size)</span></span></span><br/><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> size <span class="keyword">then</span></span><br/><span class="line">        size = <span class="number">0</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    <span class="comment">-- 调用ffi.new开辟一块内存空间</span></span><br/><span class="line">    <span class="keyword">local</span> q = ffi_new(queue_arr_type, size + <span class="number">1</span>)</span><br/><span class="line">    <span class="comment">-- 填充lrucache_pureffi_queue_t数组数据</span></span><br/><span class="line">    ffi_fill(q, ffi_sizeof(queue_type, size + <span class="number">1</span>), <span class="number">0</span>)</span><br/><span class="line">    <span class="comment">-- 如果size=0，则q是一个只有一个node双向链表</span></span><br/><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">then</span></span><br/><span class="line">        q[<span class="number">0</span>].prev = q</span><br/><span class="line">        q[<span class="number">0</span>].<span class="built_in">next</span> = q</span><br/><span class="line">    <span class="comment">-- 构造双向链表</span></span><br/><span class="line">    <span class="keyword">else</span></span><br/><span class="line">        <span class="keyword">local</span> prev = q[<span class="number">0</span>]</span><br/><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, size <span class="keyword">do</span></span><br/><span class="line">          <span class="keyword">local</span> e = q[i]</span><br/><span class="line">          e.id = i</span><br/><span class="line">          e.user_flags = <span class="number">0</span></span><br/><span class="line">          prev.<span class="built_in">next</span> = e</span><br/><span class="line">          e.prev = prev</span><br/><span class="line">          prev = e</span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">        <span class="keyword">local</span> last = q[size]</span><br/><span class="line">        last.<span class="built_in">next</span> = q</span><br/><span class="line">        q[<span class="number">0</span>].prev = last</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">return</span> q</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<h3 id="lua-resty-lrucache-set"><a href="#lua-resty-lrucache-set" class="headerlink" title="lua-resty-lrucache set"></a>lua-resty-lrucache set</h3><p>下面我们看一下初次set之后，数据结构的变化，根据key1算出来的bucket索引为3，下图可以看出来，free_queue里会拿到node_id为1的node，cache_queue里会从后开始往前插入这个node。<img src="http://chenmutian.com//2019/08/27/lua-resty-lrucache/lua-resty-lrucache-two.jpg" alt="lua-resty-lrucache-two"/></p>
<p>再看第二次set，如果Hash冲突，是怎么处理的，根据key2算出来的bucket索引也为3，这个时候free_queue里会拿到node_id为2的node，且该node的conflict为上一个node的id值即1，然后将node插入到cache_queue里。</p>
<p><img src="http://chenmutian.com//2019/08/27/lua-resty-lrucache/lua-resty-lrucache-three.jpg" alt="lua-resty-lrucache-three"/></p>
<p>接下来我们看一下具体的代码实现</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/><span class="line">60</span><br/><span class="line">61</span><br/><span class="line">62</span><br/><span class="line">63</span><br/><span class="line">64</span><br/><span class="line">65</span><br/><span class="line">66</span><br/><span class="line">67</span><br/><span class="line">68</span><br/><span class="line">69</span><br/><span class="line">70</span><br/><span class="line">71</span><br/><span class="line">72</span><br/><span class="line">73</span><br/><span class="line">74</span><br/><span class="line">75</span><br/><span class="line">76</span><br/><span class="line">77</span><br/><span class="line">78</span><br/><span class="line">79</span><br/><span class="line">80</span><br/><span class="line">81</span><br/><span class="line">82</span><br/><span class="line">83</span><br/><span class="line">84</span><br/><span class="line">85</span><br/><span class="line">86</span><br/><span class="line">87</span><br/><span class="line">88</span><br/><span class="line">89</span><br/><span class="line">90</span><br/><span class="line">91</span><br/><span class="line">92</span><br/><span class="line">93</span><br/><span class="line">94</span><br/><span class="line">95</span><br/><span class="line">96</span><br/><span class="line">97</span><br/><span class="line">98</span><br/><span class="line">99</span><br/><span class="line">100</span><br/><span class="line">101</span><br/><span class="line">102</span><br/><span class="line">103</span><br/><span class="line">104</span><br/><span class="line">105</span><br/><span class="line">106</span><br/><span class="line">107</span><br/><span class="line">108</span><br/><span class="line">109</span><br/><span class="line">110</span><br/><span class="line">111</span><br/><span class="line">112</span><br/><span class="line">113</span><br/><span class="line">114</span><br/><span class="line">115</span><br/><span class="line">116</span><br/><span class="line">117</span><br/><span class="line">118</span><br/><span class="line">119</span><br/><span class="line">120</span><br/><span class="line">121</span><br/><span class="line">122</span><br/><span class="line">123</span><br/><span class="line">124</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> _M.set<span class="params">(self, key, value, ttl, flags)</span></span></span><br/><span class="line">    <span class="comment">-- 判断key是否是string类型</span></span><br/><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(key) ~= <span class="string">&#34;string&#34;</span> <span class="keyword">then</span></span><br/><span class="line">        key = <span class="built_in">tostring</span>(key)</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    <span class="comment">-- 获取node_id</span></span><br/><span class="line">    <span class="keyword">local</span> node_id = find_key(self, key)</span><br/><span class="line">    <span class="keyword">local</span> node</span><br/><span class="line">    <span class="comment">-- 如果没有获取到，说明之前这个key没有存，获取到了，则更新value值</span></span><br/><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node_id <span class="keyword">then</span></span><br/><span class="line">        <span class="keyword">local</span> free_queue = self.free_queue</span><br/><span class="line">        <span class="comment">-- 判断缓存queue是否已经满了</span></span><br/><span class="line">        <span class="keyword">if</span> queue_is_empty(free_queue) <span class="keyword">then</span></span><br/><span class="line">            <span class="comment">-- 如果缓存queue已经满了，则从cache_queue中取最后一个(cache_queue会在每次set，get时都会从头开始插入)，这里是实现lru的精髓</span></span><br/><span class="line">            node = queue_last(self.cache_queue)</span><br/><span class="line">            <span class="comment">-- 清除node_id</span></span><br/><span class="line">            remove_key(self, self.key_v[node.id])</span><br/><span class="line">        <span class="keyword">else</span></span><br/><span class="line">            <span class="comment">-- 如果queue没有存满，则获取free_queue的第一个node</span></span><br/><span class="line">            node = queue_head(free_queue)</span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">        <span class="comment">-- 将key插入key_v, value插入val_v，node的conflict进行赋值</span></span><br/><span class="line">        insert_key(self, key, value, node)</span><br/><span class="line">    <span class="keyword">else</span></span><br/><span class="line">        node = self.node_v + node_id</span><br/><span class="line">        self.val_v[node_id] = value</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">    <span class="comment">--从queue中清除node</span></span><br/><span class="line">    queue_remove(node)</span><br/><span class="line">    <span class="comment">--将node插入到cachequeue的头部</span></span><br/><span class="line">    queue_insert_head(self.cache_queue, node)</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">-- 如果有ttl参数，则将node的expire设置为距离当前时间+ttl，否则则设置为-1(不过期)</span></span><br/><span class="line">    <span class="keyword">if</span> ttl <span class="keyword">then</span></span><br/><span class="line">        node.expire = ngx_now() + ttl</span><br/><span class="line">    <span class="keyword">else</span></span><br/><span class="line">        node.expire = <span class="number">-1</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    <span class="comment">--如果flags为数字，且大于0，则设置node的user_flags为flags，否则设置为0</span></span><br/><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(flags) == <span class="string">&#34;number&#34;</span> <span class="keyword">and</span> flags &gt;= <span class="number">0</span> <span class="keyword">then</span></span><br/><span class="line">        node.user_flags = flags</span><br/><span class="line">    <span class="keyword">else</span></span><br/><span class="line">        node.user_flags = <span class="number">0</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">find_key</span><span class="params">(self, key)</span></span></span><br/><span class="line">    <span class="comment">-- 获取key的hash值，并计算key在bucket_v的哪个索引上</span></span><br/><span class="line">    <span class="keyword">local</span> key_hash = hash_string(self, key)</span><br/><span class="line">    <span class="comment">-- 获取bucket_v中存储的node_id值</span></span><br/><span class="line">    <span class="keyword">return</span> _find_node_in_bucket(key, self.key_v, self.node_v,</span><br/><span class="line">                                self.bucket_v[key_hash])</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> _find_node_in_bucket<span class="params">(key, key_v, node_v, bucket_hdr_id)</span></span></span><br/><span class="line">    <span class="comment">-- 获取bucket_v中存的node_id值(bucket_v存的是node的id)，</span></span><br/><span class="line">    <span class="comment">-- 如果id不等于0，则代表key已经存在了</span></span><br/><span class="line">    <span class="comment">-- 如果id等于0，则代表key不存在</span></span><br/><span class="line">    <span class="keyword">if</span> bucket_hdr_id ~= <span class="number">0</span> <span class="keyword">then</span></span><br/><span class="line">        <span class="keyword">local</span> prev = <span class="number">0</span></span><br/><span class="line">        <span class="keyword">local</span> cur = bucket_hdr_id</span><br/><span class="line">        <span class="comment">-- 1. 如果key相同，则返回node的id，</span></span><br/><span class="line">        <span class="comment">-- 2. 如果key不相同，说明hash冲突了，一直往下找，直到key相同或者node_id等于0</span></span><br/><span class="line">        <span class="keyword">while</span> cur ~= <span class="number">0</span> <span class="keyword">and</span> key_v[cur] ~= key <span class="keyword">do</span></span><br/><span class="line">            prev = cur</span><br/><span class="line">            <span class="comment">-- confilict记录的是上一个node的id值</span></span><br/><span class="line">            cur = node_v[cur].conflict</span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">        <span class="comment">-- 如果node_id不等于0，则返回node_id</span></span><br/><span class="line">        <span class="keyword">if</span> cur ~= <span class="number">0</span> <span class="keyword">then</span></span><br/><span class="line">            <span class="keyword">return</span> cur, prev</span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">remove_key</span><span class="params">(self, key)</span></span></span><br/><span class="line">    <span class="keyword">local</span> key_v = self.key_v</span><br/><span class="line">    <span class="keyword">local</span> val_v = self.val_v</span><br/><span class="line">    <span class="keyword">local</span> node_v = self.node_v</span><br/><span class="line">    <span class="keyword">local</span> bucket_v = self.bucket_v</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">local</span> key_hash = hash_string(self, key)</span><br/><span class="line">    <span class="comment">-- 找到要清除的node_id</span></span><br/><span class="line">    <span class="keyword">local</span> cur, prev =</span><br/><span class="line">        _find_node_in_bucket(key, key_v, node_v, bucket_v[key_hash])</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">if</span> cur <span class="keyword">then</span></span><br/><span class="line">        <span class="comment">-- 清除key和value</span></span><br/><span class="line">        key_v[cur] = <span class="literal">nil</span></span><br/><span class="line">        val_v[cur] = <span class="literal">nil</span></span><br/><span class="line">        self.num_items = self.num_items - <span class="number">1</span></span><br/><span class="line"></span><br/><span class="line">        <span class="comment">-- Remove the node from the hash table</span></span><br/><span class="line">        <span class="comment">-- 获取要清除的node的conflict(也即上一个node的node_id)</span></span><br/><span class="line">        <span class="keyword">local</span> next_node = node_v[cur].conflict</span><br/><span class="line">        <span class="keyword">if</span> prev ~= <span class="number">0</span> <span class="keyword">then</span></span><br/><span class="line">            node_v[prev].conflict = next_node</span><br/><span class="line">        <span class="keyword">else</span></span><br/><span class="line">            bucket_v[key_hash] = next_node</span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">        node_v[cur].conflict = <span class="number">0</span></span><br/><span class="line"></span><br/><span class="line">        <span class="keyword">return</span> cur</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">insert_key</span><span class="params">(self, key, val, node)</span></span></span><br/><span class="line">    <span class="comment">-- Bind the key/val with the node</span></span><br/><span class="line">    <span class="keyword">local</span> node_id = node.id</span><br/><span class="line">    <span class="comment">-- key_v val_v相应位置进行赋值</span></span><br/><span class="line">    self.key_v[node_id] = key</span><br/><span class="line">    self.val_v[node_id] = val</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">-- Insert the node into the hash-table</span></span><br/><span class="line">    <span class="keyword">local</span> key_hash = hash_string(self, key)</span><br/><span class="line">    <span class="keyword">local</span> bucket_v = self.bucket_v</span><br/><span class="line">    <span class="comment">-- 第一次node.conflict = 0</span></span><br/><span class="line">    node.conflict = bucket_v[key_hash]</span><br/><span class="line">    <span class="comment">-- 将node_id存到bucket_v中</span></span><br/><span class="line">    bucket_v[key_hash] = node_id</span><br/><span class="line">    self.num_items = self.num_items + <span class="number">1</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>以上就是set的整个过程，将代码和图结合起来看效果会更好。这里有几点做一下说明：</p>
<ul>
<li>lua-resty-lrucache是怎么实现lru的呢。<ul>
<li>每次set或者get之后，都会将node放在cache_queue的头部，而当free_queue里没有node之后，就会从cache_queue的尾部取一个node进行赋值。</li>
</ul>
</li>
<li>lua-resty-lrucache是怎么实现过期的<ul>
<li>每次set的时候，如果有配置ttl，则会给node的expire字段进行赋值，然后在get操作的时候会判断expire值是否已经超过配置的ttl </li>
</ul>
</li>
</ul>
<p>搞清楚set的过程以后，get的过程就很简单了，就不进行具体的分析了。</p>