---
layout: post
title: lua迭代器 
tags: [lua文章]
categories: [topic]
---
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>迭代器就是一种可以遍历一种集合中所有元素的机制，在Lua中，通常将迭代器表示为函数。每调用一次函数，就返回集合中的“下一个”元素。每个迭代器都需要在每次成功调用之后保存一些状态，这样才能知道它所在的位置及如何走到下一个位置，通过之前博文的总结，闭包对于这样的任务提供了极佳的支持。现在我们就用代码来实现一个简单的迭代器。</p>
<pre><code>function values(tb)
     local i = 0
     return function ()
          i = i + 1
          return tb[i]
     end
end

local testTb = {10, 20, 30}
for value in values(testTb) do
     print(value)
end
</code></pre><p>这就是一个最简单的迭代器，使用闭包来完成整个任务；这只是一个简单的例子，接下来，再看看泛型for的语义。</p>
<h4 id="泛型for的语义"><a href="#泛型for的语义" class="headerlink" title="泛型for的语义"></a>泛型for的语义</h4><p>泛型for比较复杂，它在循环过程内保存了迭代器函数。它实际上保存着3个值：一个迭代器函数、一个恒定状态和一个控制变量。接下来，分别进行总结。<br/>泛型for的语法如下：</p>
<pre><code>for &lt;var-list&gt; in &lt;exp-list&gt; do
     &lt;body&gt;
end
</code></pre><p>其中，<var-list>是一个或多个变量名的列表，以逗号分隔；<exp-list>是一个或多个表达式的列表，同样以逗号分隔。通常表达式列表只有一个元素，即一句对迭代器函数的调用。例如：</exp-list></var-list></p>
<p>for k, v in pairs(t) do print(k, v) end<br/>for做的第一件事就是对in后面的表达式求值，这些表达式应该返回3个值供for保存：迭代器函数、恒定状态和控制变量的初值。这里和多重赋值是一样的，只有最后一个表达式才会产生多个结果，并且只会保留前3个值，多余的值会被丢弃；而不够的话，就以nil补足。</p>
<p>在初始化完成以后，for会以恒定状态和控制变量来调用迭代器函数。然后for将迭代器函数的返回值赋予变量列表中的变量。如果第一个返回值为nil，那么循环就终止，否则，for执行它的循环体，随后再次调用迭代器函数，并重复这个过程。在前言部分的代码中，只是返回了迭代器函数，并没有返回恒定状态和控制变量。下面通过代码来说明这个问题，比如：</p>
<pre><code>for var_1, ..., var_n in &lt;explist&gt; do &lt;block&gt; end -- 就等价于以下代码：
do
     local _f, _s, _var = &lt;explist&gt;    -- 返回迭代器函数、恒定状态和控制变量的初值
     while true do
          local var_1, ..., var_n = _f(_s, _var)
          _var = var_1
          if _var == nil then break end
          &lt;block&gt;
          end
     end
end
</code></pre><h4 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h4><p>所谓“无状态的迭代器”，就是一种自身不保存任何状态的迭代器。因此，我们可以在多个循环中使用同一个无状态的迭代器，避免创建新的闭包的开销。</p>
<p>在每次迭代中，for循环都会用恒定状态和控制变量来调用迭代器函数。一个无状态的迭代器可以根据这两个值来为下次迭代生成下一个元素。这类迭代器的代表就是ipairs。它可以用来迭代一个数组的所有元素。如下述演示代码：</p>
<pre><code>local aTb = {&#34;One&#34;, &#34;Two&#34;, &#34;Three&#34;}
for i, v in ipairs(aTb) do
     print(i, v)
end
</code></pre><p>在这里，迭代器状态就是需要遍历的table（一个恒定状态，它不会在循环中改变）及当前的索引值（控制变量）。我们可以使用Lua代码来实现ipairs，大概就如下代码：</p>
<pre><code>local function iter(a, i)
     i = i + 1
     local v = a[i]
     if v then
          return i, v
     end
end

function ipairs(a)
     return iter, a, 0
end
</code></pre><p>函数pairs与ipairs类似，也是用于遍历一个table中的所有元素。不同的是，它的迭代器函数是Lua中的一个基本函next。</p>
<pre><code>function pairs(a)
     return next, t, nil
end
</code></pre><p>在调用next(t, k)时，k是table t的一个key。此调用会以table中的任意次序返回一组值：此table的下一个key，及这个key所对应的值。而调用next(t, nil)时，返回table的第一组值。若没有下一组值时，next返回nil。所以，我们也可以使用next来判断一个table是否为空。</p>
<p>对于大家经常迷惑的ipairs和pairs的区别，在这里就能看的一清二楚了，ipairs只能用于遍历index是整型的table，同时，由于ipairs返回的控制变量初值为0，这就决定了，ipairs只能访问index从1开始的key和value；ipairs不能返回nil，当key对应的值为nil时，就直接终止遍历；而pairs则没有要求。关于ipairs和pairs的具体差异，请参考这篇博文：点这里。</p>
<p>当然了，有了无状态的迭代器，就有了有状态的迭代器了，有状态的迭代器就是专门用一个table来保存状态；在无状态的迭代器中，我们每一次都是迭代一个table，这个table就是一个无状态的table，它不会再遍历的过程中发生变化，而有状态的迭代器，则会在遍历的过程中对迭代的table进行变更，迭代的table的状态也随之发生了变化。这里不做详细的总结。</p>