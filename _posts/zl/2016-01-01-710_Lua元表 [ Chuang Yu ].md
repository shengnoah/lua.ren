---
layout: post
title: Lua元表 [ Chuang Yu ] 
tags: [lua文章]
categories: [topic]
---
<p>javascript语言本身不支持面向对象，ES2015中增加了class关键字，却不过是prototype语法糖而已，本质上prototype形式的面向对象只能算是一种“模拟”，这其中很重要的原因之一是js从来没有一套完美的深拷贝方案，子类只能借助原型链获取父类方法的引用，这不能算是严格意义的继承，当然也就算不上面向对象。</p>
<p>和js一样，lua的面向对象需要通过table来模拟，有些行为很像js中的原型，比如下面的例子。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line">Animal = {name = <span class="string">&#34;Animal&#34;</span>}</span><br/><span class="line">Animal.<span class="built_in">__index</span>= Animal</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line">  <span class="keyword">local</span> re = {}</span><br/><span class="line">  <span class="built_in">setmetatable</span>(re, self)</span><br/><span class="line">  <span class="keyword">return</span> re</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal:GetName</span><span class="params">()</span></span></span><br/><span class="line">  <span class="keyword">return</span> self.name</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">x = Animal:new()</span><br/></pre></td></tr></tbody></table></figure>
<p>在lua中，<strong>元表</strong>是个很有意思的存在。上面Animal是实例出的对象x的元表，元表在某种意义上相当于js中的构造函数，而<code>__index</code>则类似<code>prototype</code>（这里<code>__index</code>我设置为指向自身）。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.name) </span><br/><span class="line"><span class="built_in">print</span>(x:GetName()) </span><br/><span class="line">Animal.name = <span class="string">&#34;Animal2&#34;</span></span><br/><span class="line"><span class="built_in">print</span>(x.name) <span class="comment">-- Animal2</span></span><br/><span class="line"><span class="built_in">print</span>(x:GetName()) <span class="comment">-- Animal2</span></span><br/></pre></td></tr></tbody></table></figure>
<p>如果在x中不存在name键，对<code>x.name</code>的访问实际上会从x的元表中的<code>__index</code>键寻找，如果仍然找不到，则会在Animal的元表中继续找，若既没有元表也找不到该键，返回nil，这和js原型链如出一辙。</p>
<p>借助元表，我们很容易模拟面向对象中的继承和多态，比如我们来实现一个继承自Animal的Dog类。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line">Dog = {}</span><br/><span class="line"><span class="built_in">setmetatable</span>(Dog, Animal)</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog:new</span><span class="params">()</span></span></span><br/><span class="line">  <span class="keyword">local</span> re = {}</span><br/><span class="line">  <span class="built_in">setmetatable</span>(re, self)</span><br/><span class="line">  self.<span class="built_in">__index</span> = self</span><br/><span class="line">  <span class="keyword">return</span> re</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>效果如下。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line">y = Dog:new()</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(y:GetName()) </span><br/><span class="line">Animal.name = <span class="string">&#34;Hello&#34;</span></span><br/><span class="line"><span class="built_in">print</span>(y.GetName()) <span class="comment">-- Hello</span></span><br/><span class="line">Dog.name = <span class="string">&#34;Dog&#34;</span></span><br/><span class="line"><span class="built_in">print</span>(y.GetName()) <span class="comment">-- Dog</span></span><br/></pre></td></tr></tbody></table></figure>
<p>实际上，lua中的元表比js中的原型机制强大的多。</p>
<p>上述的例子是Lua中最常见的实现OO的方法，除了关键的<code>setmetatable</code>函数，<code>__index</code>键也很重要，它不仅可以是另一个table的引用，也可以是一个函数，当实例对象试着从<code>__index</code>寻找时便会调用这个函数，可以想象，这为多重继承的实现提供了可能，而js做不到这一点（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model#No_multiple_inheritance" target="_blank" rel="noopener noreferrer">参考</a>）。</p>
<p>举个简单的例子。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义两个相似的类A和B</span></span><br/><span class="line">A = {foo1 = <span class="number">123</span>, name = <span class="string">&#34;A&#34;</span>}</span><br/><span class="line">A.<span class="built_in">__index</span> = A</span><br/><span class="line">B = {foo2 = <span class="number">456</span>, name = <span class="string">&#34;B&#34;</span>}</span><br/><span class="line">B.<span class="built_in">__index</span> = B</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A:new</span><span class="params">()</span></span></span><br/><span class="line">  <span class="keyword">local</span> re = {}</span><br/><span class="line">  <span class="built_in">setmetatable</span>(re, self)</span><br/><span class="line">  <span class="keyword">return</span> re</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A:GetName</span><span class="params">()</span></span></span><br/><span class="line">  <span class="built_in">print</span>(self.name)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B:new</span><span class="params">()</span></span></span><br/><span class="line">  <span class="keyword">local</span> re = {}</span><br/><span class="line">  <span class="built_in">setmetatable</span>(re, self)</span><br/><span class="line">  <span class="keyword">return</span> re</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B:GetName</span><span class="params">()</span></span></span><br/><span class="line">  <span class="built_in">print</span>(self.name)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B:MethodOnB</span><span class="params">()</span></span></span><br/><span class="line">  <span class="built_in">print</span>(<span class="string">&#34;method on B&#34;</span>)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 定义类C，继承自A和B</span></span><br/><span class="line">C = {}</span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C:new</span><span class="params">()</span></span></span><br/><span class="line">  <span class="keyword">local</span> childA = A:new()</span><br/><span class="line">  <span class="keyword">local</span> childB = B:new()</span><br/><span class="line">  <span class="keyword">local</span> re = {}</span><br/><span class="line">  <span class="built_in">setmetatable</span>(re, {</span><br/><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(table, key)</span></span></span><br/><span class="line">      <span class="keyword">if</span> childA[key] <span class="keyword">then</span></span><br/><span class="line">        <span class="keyword">return</span> childA[key]</span><br/><span class="line">      <span class="keyword">elseif</span> childB[key] <span class="keyword">then</span></span><br/><span class="line">        <span class="keyword">return</span> childB[key]</span><br/><span class="line">      <span class="keyword">else</span> </span><br/><span class="line">        <span class="keyword">return</span> <span class="string">&#34;not found&#34;</span></span><br/><span class="line">      <span class="keyword">end</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">  })</span><br/><span class="line">  <span class="keyword">return</span> re</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">x = C:new()</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">print</span>(x.foo1) <span class="comment">-- 123</span></span><br/><span class="line"><span class="built_in">print</span>(x.foo2) <span class="comment">-- 456</span></span><br/><span class="line"></span><br/><span class="line">x:GetName() <span class="comment">-- A</span></span><br/><span class="line">x:MethodOnB() <span class="comment">-- method on B</span></span><br/></pre></td></tr></tbody></table></figure>
<p>C类继承了来自A和B的方法。</p>
<p>注意到上面的例子中A和B都拥有GetName方法，我们可以进一步假设A和B都继承自另外一个对象，而他们各自的GetName方法其实都继承自这个对象，这就产生了经典的钻石问题（也叫菱形继承问题），即：C继承到的GetName方法到底来自A还是B？一些原生支持面向对象和多重继承的语言为了解决钻石问题，往往会采用特定的遍历算法，如Python采用的是从左到右广度优先原则，使用的是名叫“C3”的算法。而在上面这里例子里我只是简单的指定了先从A中寻找，再从B中寻找，所以C继承了A的GetName方法。</p>
<p>在lua中，元表除了用来模拟面向对象，还有一些不可思议的作用：自定义table间运算的行为。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义加法行为</span></span><br/><span class="line">meta = {<span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(A, B)</span></span></span><br/><span class="line">  <span class="keyword">local</span> re = {}</span><br/><span class="line">  <span class="keyword">for</span> _, val <span class="keyword">in</span> <span class="built_in">ipairs</span>(A) <span class="keyword">do</span></span><br/><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(re, val)</span><br/><span class="line">  <span class="keyword">end</span></span><br/><span class="line">  <span class="keyword">for</span> _, val <span class="keyword">in</span> <span class="built_in">ipairs</span>(B) <span class="keyword">do</span></span><br/><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(re, val)</span><br/><span class="line">  <span class="keyword">end</span></span><br/><span class="line">  <span class="keyword">return</span> re</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line">}</span><br/><span class="line">a = <span class="built_in">setmetatable</span>({<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, meta)</span><br/><span class="line">b = <span class="built_in">setmetatable</span>({<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}, meta)</span><br/><span class="line"></span><br/><span class="line">c = a + b <span class="comment">-- {1, 2, 3, 4, 5, 6}</span></span><br/></pre></td></tr></tbody></table></figure>
<p>除了<code>__add</code>，元表上可自定义的运算行为包括如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line">__add		对应的运算符 &#39;+&#39;.</span><br/><span class="line">__sub		对应的运算符 &#39;-&#39;.</span><br/><span class="line">__mul		对应的运算符 &#39;*&#39;.</span><br/><span class="line">__div		对应的运算符 &#39;/&#39;.</span><br/><span class="line">__mod		对应的运算符 &#39;%&#39;.</span><br/><span class="line">__unm		对应的运算符 &#39;-&#39;.</span><br/><span class="line">__concat	对应的运算符 &#39;..&#39;.</span><br/><span class="line">__eq		对应的运算符 &#39;==&#39;.</span><br/><span class="line">__lt		对应的运算符 &#39;&lt;&#39;.</span><br/><span class="line">__le		对应的运算符 &#39;&lt;=&#39;.</span><br/></pre></td></tr></tbody></table></figure>
<p>而除了运算，元表甚至可以让table像函数一样调用，使用<code>__call</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">a = setmetatable({}, {__call = function(mytable, params)</span><br/><span class="line">  print(&#34;123&#34;..params)</span><br/><span class="line">end})</span><br/><span class="line"></span><br/><span class="line">a(456) -- 123456</span><br/></pre></td></tr></tbody></table></figure>
<p>所有上述提到的在元表上以<code>__</code>开头的方法统称为<strong><a href="https://www.lua.org/pil/13.html" target="_blank" rel="noopener noreferrer">元方法</a></strong>。</p>
<p>元表有这么多有意思的设计，也难怪lua程序员说js中的原型只能算实现了元表功能的十分之一。</p>
<p>话说回来，在lua中使用面向对象和在js中的感觉差不多，过去基于prototype模拟OO，很多人有不同的实现，如今js在语法层面统一了写法，而在lua中仍然有很多人尝试对上面这些例子的写法进行封装，试图让代码更容易维护和扩展，这样的折腾其实没什么意义，因为面向对象本身就不易维护。以小而精致著称的lua也不太可能提供语言层面支持，毕竟连社区都没几个，也没看到有人表达这样的诉求，函数式语言就写函数式，多好。</p>