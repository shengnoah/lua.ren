---
layout: post
title: lua c api  
tags: [lua文章]
categories: [topic]
---
<h2 id="一-概述">一 概述</h2> <p>《lua c api》系列文章描述的是 <code class="highlighter-rouge">C</code> 语言作为宿主语言，与 <code class="highlighter-rouge">Lua</code> 程序通讯的 <code class="highlighter-rouge">API</code> 接口。</p> <h2 id="二-stack">二 stack</h2> <p><code class="highlighter-rouge">Lua</code> 使用虚拟的栈与宿主 <code class="highlighter-rouge">C</code> 语言进行通讯，在栈中的每个元素都是 <code class="highlighter-rouge">Lua</code> 识别的数据类型。<strong>每当 <code class="highlighter-rouge">Lua</code> 调用 <code class="highlighter-rouge">C</code> 时，被调用的 <code class="highlighter-rouge">C</code> 函数都会得到一个新的栈，该栈独立于以前的栈和仍处于活跃状态的 <code class="highlighter-rouge">C</code> 函数栈</strong>。在此堆栈包含 <code class="highlighter-rouge">lua</code> 调用 <code class="highlighter-rouge">C</code> 函数的所有参数，<code class="highlighter-rouge">C</code> 函数应该将需要返回的结果压入此堆栈中（<strong>是否需要清空栈</strong>）。</p> <p>为了方便，在 <code class="highlighter-rouge">C</code> 中操作栈时并未严格遵守栈操作语义，可以使用“索引”来查询栈中的元素。正数索引从栈底开始计数，栈底索引为 <code class="highlighter-rouge">1</code>；负数索引从栈顶开始计数，栈顶索引为 <code class="highlighter-rouge">-1</code>。示例结构：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---------------------------------------
| 正数索引 |  数据   | 负数索引 | 栈中位置 |
---------------------------------------
|    3    |   nil  |   -1    |  栈顶   |
|    2    |   2    |   -2    |  中间   |
|    1    |  &#34;hi&#34;  |   -3    |  栈底   |
</code></pre></div></div> <p>注意，使用 <code class="highlighter-rouge">0</code> 作为索引会出错。</p> <h2 id="三-示例">三 示例</h2> <p><em>使用 <code class="highlighter-rouge">lua5.1.5</code> 版本</em></p> <h3 id="1-程序">1. 程序</h3> <p>在示例中 <code class="highlighter-rouge">echo</code> 函数会返回所有调用参数，在返回时栈底元素作为第一个返回值，栈顶元素作为最后一个返回值；<code class="highlighter-rouge">sayhi</code> 会清空栈顶并返回一个 “hi” 字符串。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// gcc -fPIC -I/usr/local/lua5.1.5/include -g -c stack.c
// gcc -shared -I/usr/local/lua5.1.5/include  -L/usr/local/lua5.1.5/lib -llua -o stack.so stack.o
</span><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="cp">#include &#34;lua.h&#34;
#include &#34;lauxlib.h&#34;
#include &#34;lualib.h&#34;
</span>
<span class="cm">/******************************************************************************
 * sayhi 函数
 * 清空栈，并将 hi 字符串压入栈顶
 ******************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span> 
<span class="nf">sayhi</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lua_settop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************
 * echo 函数会返回所有输入参数
 ******************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">echo</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">lua_gettop</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> 
<span class="k">struct</span> <span class="n">luaL_reg</span> <span class="n">stack_lib</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&#34;sayhi&#34;</span><span class="p">,</span> <span class="n">sayhi</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;echo&#34;</span><span class="p">,</span> <span class="n">echo</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/******************************************************************************
 * 注册函数
 * 注意 luaopen_xxx 中 xxx 为 lua 中 require 库名称
 ******************************************************************************/</span>
<span class="kt">int</span> 
<span class="nf">luaopen_stack</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">luaL_openlib</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="s">&#34;stack&#34;</span><span class="p">,</span> <span class="n">stack_lib</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><em>编译命令在代码开始处</em></p> <h3 id="2-调用">2. 调用</h3> <p>在解释器中可以调用测试：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lua 5.1.5  Copyright <span class="o">(</span>C<span class="o">)</span> 1994-2012 Lua.org, PUC-Rio
<span class="o">&gt;</span> require <span class="s2">&#34;stack&#34;</span>
<span class="o">&gt;</span> r1,r2 <span class="o">=</span> stack.echo<span class="o">(</span><span class="s2">&#34;a&#34;</span>,<span class="s2">&#34;b&#34;</span><span class="o">)</span>
<span class="o">&gt;</span> print<span class="o">(</span>r1,r2<span class="o">)</span>
a	b
<span class="o">&gt;</span> r <span class="o">=</span> stack.sayhi<span class="o">()</span>
<span class="o">&gt;</span> print<span class="o">(</span>r<span class="o">)</span>
hi
</code></pre></div></div> <h2 id="四-函数说明">四 函数说明</h2> <h3 id="1-栈顶索引操作">1. 栈顶索引操作</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">lua_settop</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
</code></pre></div></div> <p>函数功能： 将 <code class="highlighter-rouge">L</code> 的栈顶设置到 <code class="highlighter-rouge">index</code> 指定的索引处。 如果 <code class="highlighter-rouge">index</code> 比现有的栈顶高，会扩充栈，扩充的栈中值为 <code class="highlighter-rouge">nil</code>。 如果 <code class="highlighter-rouge">index</code> 比现有的栈顶低，那么 <code class="highlighter-rouge">index</code> 到历史栈顶之间的元素会被删除。 如果 <code class="highlighter-rouge">index</code> 为 <code class="highlighter-rouge">0</code>，那么栈中所有元素都将被删掉。</p> <h3 id="2-字符串压入栈">2. 字符串压入栈</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">lua_pushstring</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div> <p>将 <code class="highlighter-rouge">s</code> 指向的字符串压入 <code class="highlighter-rouge">L</code> 的栈顶。字符串会以 “