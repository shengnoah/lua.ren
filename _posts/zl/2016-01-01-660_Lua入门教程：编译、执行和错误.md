---
layout: post
title: Lua入门教程：编译、执行和错误 
tags: [lua文章]
categories: [topic]
---
<h2 id="dofile-与-loadfile-函数"><a href="#dofile-与-loadfile-函数" class="headerlink" title="dofile 与 loadfile 函数"></a>dofile 与 loadfile 函数</h2><p>dofile 是一个辅助函数，函数 loadfile 才完成了真正的核心工作。 两个函数都是从文件中加载 Lua 代码，但它不会运行，只是编译代码，然后把编译后的代码作为函数返回。<br/>与 dofile 不同，loadfile 不会抛出异常，只会返回错误码。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(filename)</span></span></span><br/><span class="line">    <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(filename))</span><br/><span class="line">    <span class="keyword">return</span> f()</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<h2 id="load-函数"><a href="#load-函数" class="headerlink" title="load 函数"></a>load 函数</h2><p>与 loadfile 类似，但该函数是从一个字符串中读取代码。</p>
<p>编写用后即弃的代码：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br/><span class="line">s = <span class="string">&#34;i = i + 1&#34;</span></span><br/><span class="line"><span class="built_in">load</span>(s)() </span><br/></pre></td></tr></tbody></table></figure>

<p>该函数加载的代码如果有语法错误，load 会返回 nil 和 错误信息，所以最好使用 assert：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(<span class="built_in">load</span>(s))()</span><br/></pre></td></tr></tbody></table></figure>
<p>laod 加载编译时不会设计词法定界，该函数总是在全局环境中编译代码：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line">i = <span class="number">32</span></span><br/><span class="line"><span class="keyword">local</span> i = <span class="number">0</span></span><br/><span class="line">f = <span class="built_in">load</span>(<span class="string">&#34;i = i + 1; print(i)&#34;</span>)</span><br/><span class="line">g = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> i = i + <span class="number">1</span>; <span class="built_in">print</span>(i) <span class="keyword">end</span></span><br/><span class="line">f() <span class="comment">--&gt; 33</span></span><br/><span class="line">g() </span><br/></pre></td></tr></tbody></table></figure>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Lua 会在遇到非预期的情绪时引发错误，如将非数值类型相加，对不是函数的值进行调用等。</p>
<p>也可以调用函数 error 并传入一个错误信息来作为参数引发一个错误：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&#34;n&#34;</span>)</span><br/><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="built_in">error</span>(<span class="string">&#34;invalid input&#34;</span>) <span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>当然上面这种情况更简单的代码结构是使用 assert 函数来完成，assert 函数检查第一个参数是否为真，如果为真则返回该参数，否则引发一个错误，并用第二个参数作为错误提示信息：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&#34;n&#34;</span>), <span class="string">&#34;invalid input&#34;</span>)</span><br/></pre></td></tr></tbody></table></figure>
<p>Lua 中要给函数发现某个错误是，在进行异常处理时有两种选择：</p>
<ul>
<li>返回错误代码（nil 或是 false）</li>
<li>通过函数 error 引发一个错误。</li>
</ul>
<p>通常容易避免的错误应该引发错误，否则应该返回错误码。</p>
<h2 id="错误处理和异常"><a href="#错误处理和异常" class="headerlink" title="错误处理和异常"></a>错误处理和异常</h2><p>要执行一段代码并捕获一段错误(try-catch)可以使用pcall函数，该函数以一种保护模式调用它的第一个参数，如果没有发生错误会返回true和调用函数的返回参数，否则返回false和错误信息。<br/>我们可以通过 error(throw an exception) 来抛出异常，并通过 pcall 来捕获 (catch) 异常。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ok, msg = <span class="built_in">pcall</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">    some code</span><br/><span class="line">    <span class="keyword">if</span> unexpected_condition <span class="keyword">then</span> <span class="built_in">error</span>() <span class="keyword">end</span></span><br/><span class="line">    some code</span><br/><span class="line"><span class="keyword">end</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">if</span> ok <span class="keyword">then</span></span><br/><span class="line">    regular code</span><br/><span class="line"><span class="keyword">else</span></span><br/><span class="line">    <span class="built_in">error</span>-handing code</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>另外，error 函数还有第2个可选参数 level，用于只想函数调用层次中的哪层函数报告错误，以说明谁应该为错误负责。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(str)</span></span></span><br/><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(str) ~= <span class="string">&#34;string&#34;</span> <span class="keyword">then</span></span><br/><span class="line">        <span class="built_in">error</span>(<span class="string">&#34;string expected&#34;</span>, <span class="number">2</span>)</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    regualr code</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>最后，我们如果希望错误发生时获得更多的调试信息，比如发生错误时一个完整的函数调用栈信息。<br/>pcall 如果发生错误时，部分的调用栈已经被破坏了（从pcall到出错部分），如果希望得到一个完整的有意义的栈回溯，则必须在函数 pcall 返回前先将调用栈构好。<br/>为了实现上面的需求，我们可以使用 xpcall 函数，该函数第二个参数是一个消息处理函数，当错误发生时，Lua 会在调用栈展开前调用这个消息处理函数，我们可以使用 debug.traceback 来获取更多错误信息。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">error_handler</span><span class="params">(msg)</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>(<span class="built_in">tostring</span>(msg), <span class="number">2</span>))</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="built_in">xpcall</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">    some code</span><br/><span class="line">    <span class="keyword">if</span> unexpected_c  ondition <span class="keyword">then</span> <span class="built_in">error</span>() <span class="keyword">end</span></span><br/><span class="line">    some code</span><br/><span class="line"><span class="keyword">end</span>, error_handler)</span><br/></pre></td></tr></tbody></table></figure>