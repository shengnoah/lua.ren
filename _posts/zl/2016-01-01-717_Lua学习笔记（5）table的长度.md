---
layout: post
title: Lua学习笔记（5）table的长度 
tags: [lua文章]
categories: [topic]
---
<p>lua-5.1.5</p>

<h1 id="疑问">疑问</h1>
<p>lua获取table长度的接口有很多：</p>

<ul>
  <li>table.getn()</li>
  <li>table.maxn()</li>
  <li>’#’操作符</li>
</ul>

<blockquote>
  <p>推荐一篇文章：<a href="http://rangercyh.blog.51cto.com/1444712/1032925/">浅析Lua中table的遍历</a></p>
</blockquote>

<p>但是也会出现神奇的情况，请看下面一小段代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local t = {111, x = 222, nil, 333, [10] = 555, {}, nil, nil}
print(table.getn(t))    -- 4
print(#t)               -- 4
print(table.maxn(t))    -- 10
--local t = {111, nil, x = 222, nil, 333, [10] = 555, {}, nil, nil}
--local t = {111, x = 222, nil, 333, [10] = 555, nil, {}, nil, nil}
</code></pre></div></div>

<p>如果随机在t中插入nil，结果会让你大吃一惊，丈二和尚摸不着头脑。比如:</p>

<ul>
  <li>在111后面插入一个nil，结果是: 1, 1, 10</li>
  <li>在555后面插入一个nil，结果却是：5, 5, 10</li>
</ul>

<p><em>这是为什么呢？有没有规律呢？</em></p>

<h1 id="table的操作符">table的#操作符</h1>
<p>这里原因我先简单介绍一下，想弄更清楚的请自己看完之后看源代码，算是抛砖引玉^_^！上面的结果千奇百怪主要是和#操作符有关，#操作符最终获取table长度的函数是(文件ltable.c中)：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
** Try to find a boundary in table `t&#39;. A `boundary&#39; is an integer index
** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
*/
int luaH_getn (Table *t) {
  unsigned int j = t-&gt;sizearray;
  if (j &gt; 0 &amp;&amp; ttisnil(&amp;t-&gt;array[j - 1])) {
    /* there is a boundary in the array part: (binary) search for it */
    unsigned int i = 0;
    while (j - i &gt; 1) {
      unsigned int m = (i+j)/2;
      if (ttisnil(&amp;t-&gt;array[m - 1])) j = m;
      else i = m;
    }
    return i;
  }
  /* else must find a boundary in hash part */
  else if (t-&gt;node == dummynode)  /* hash part is empty? */
    return j;  /* that is easy... */
  else return unbound_search(t, j);
}
</code></pre></div></div>

<p>只看很小的一部分：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (j - i &gt; 1) {
  unsigned int m = (i+j)/2;
  if (ttisnil(&amp;t-&gt;array[m - 1])) j = m;
  else i = m;
}
return i;
</code></pre></div></div>

<blockquote>
  <p>unbound_search函数中也有一部分逻辑和上面代码一样</p>
</blockquote>

<p>知道二分查找的人花一点时间应该很快能够理解这段代码的意思，从数组[i-j]中二分查找的方式遍历，如果不为ni的话，相当于长度增加了(i=m)；如果为nil的话，相当于长度减少了，也举个简单的例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local t = {1, 2, nil}
print(&#34;#t1 = &#34;, #t1)
--[[
i=0, j=3
(1)m=1, array[m-1]=1不为nil, i=m=1
(2)m=2, array[m-1]=2不为nil, i=m=2
(3)j-i &lt;=1循环结束，return i，结果为2
]]

local t = {1, nil, 2, nil}
print(&#34;#t1 = &#34;, #t1)
--[[
i=0, j=4
(1)m=2, array[m-1]=nil, j=m=2
(2)m=1, array[m-1]=1不为nil, i=m=1
(3)j-i &lt;=1循环结束，return i，结果为1
]]
</code></pre></div></div>

<p>可以看到，ni的位置不确定性，让返回的长度变幻莫测了，这也就是为什么上面看到的结果千奇百怪了 ^_^</p>

<h1 id="总结">总结</h1>
<ul>
  <li>lua的’#’操作符获取的长度在table中间有nil的情况很不稳定</li>
  <li>虽然看到代码还是有一定规律可循的，但我个人认为也不应该把这个规律用来计算这种table的长度</li>
  <li>再回来看luaH_getn函数开头的一小段代码解释说明，会更容易理解一点:’Try to find a boundary in table <code class="highlighter-rouge">t&#39;. A </code>boundary’ is an integer index such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).’</li>
</ul>

<h1 id="拓展">拓展</h1>

<h2 id="1unpack">1.unpack({…})</h2>

<p>我们会经常用到这种方式，比如传进来的参数是不定长的’…‘，然后用table的操作符’{}’括起来，变成一个table，然后使用unpack解包。恰好，前两天有个同事跟我们分享了这个使用方式的漏洞。一开始有点吃惊，看完上面的一些分析只会，也就能够明晰许多了。下面是同事的分享。</p>

<h3 id="问题代码">问题代码</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function fnUnPack( ... )
	local p = {...};
	return unpack(p);
end

print(fnUnPack(1, 2, 3));
print(fnUnPack(1, 2, 3, nil ,4));
print(fnUnPack(1, 2, 3, nil ,4, nil));
--结果
1	2	3
1	2	3	nil	4
1	2	3
</code></pre></div></div>

<h3 id="解决办法">解决办法</h3>

<ul>
  <li>(1)使用table的pack和unpack</li>
</ul>

<p>示例代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function fnUnPack1( ... )
	local p = table.pack(...);
	 return table.unpack(p, 1, p.n);
end
</code></pre></div></div>

<blockquote>
  <p>版本lua-5.2及以上</p>
</blockquote>

<ul>
  <li>(2)使用select</li>
</ul>

<p>示例代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function fnUnPack2( ... )
	local p = {...}
	local n = select(&#39;#&#39;, ...)
	return unpack(p, 1, n);
end
</code></pre></div></div>

<h2 id="2版本52及以上">2.版本5.2及以上</h2>

<ul>
  <li>lua-5.2以上已经没有table.getn和table.maxn接口了</li>
</ul>