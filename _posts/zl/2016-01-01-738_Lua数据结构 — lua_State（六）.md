---
layout: post
title: Lua数据结构 — lua_State（六） 
tags: [lua文章]
categories: [topic]
---
<p>前面各种Lua的数据类型基本都说得差不多了，剩下最后一个数据类型：<strong>lua_State</strong>，我们可以认为是<strong>”脚本上下文”</strong>，主要是包括当前脚本环境的运行状态信息，还会有gc相关的信息。</p>

<p>Lua这门语言考虑了多线程的情况，在脚本空间中能够开多个线程相关脚本上下文，而大家会共用一个全局脚本状态数据，如下：</p>
<p><img src="https://keepmovingxin.github.io//images/luaState/lua-state-01.png" alt=""/></p>
<p>全局数据global_state的数据结构如下：</p>
<p><img src="https://keepmovingxin.github.io//images/luaState/lua-state-02.png" alt=""/></p>
<p>global_state主要是用于GC的数据链表，下面简要说明几个:</p>
<ol>
<li>stringtable strt：这个是在TString那章说到的全局字符串哈希表</li>
<li>TValue lregistry：对应LUAREGISTRYINDEX的全局table.</li>
<li>TString *tmname[TM_N]：元方法的名称字符串。</li>
<li>Table *mt[NUM_TAGS]：基本类型的元表，这是Lua5.0的特性。</li>
</ol>
<p>mt成员在作者介绍文章中说到:</p>
<p><img src="https://keepmovingxin.github.io//images/luaState/lua-state-03.png" alt=""/></p>
<p>在上面代码中，我们看到a支持一个tostring的方法，a是数值类型，我们可以为数值类型添加任意的方法。Lua文章中说到一个用途，就是对于unicode和gbk的字符串的len方法能自己实现。</p>
<p>其它成员就不一一介绍了，下面来介绍与线程相关的脚本上下文lua_State：</p>
<p><img src="https://keepmovingxin.github.io//images/luaState/lua-state-04.png" alt=""/></p>
<p>我们看到，luaState也带有CommonHeader头，在第一章中也提到了GCObject中有luaState th这个成员，由此可见lua_State也会是被回收的对象之一。</p>
<p>考虑回一个线程中的脚本上下文，我们再来逐个分析每个成员：</p>
<ul>
<li>lu_byte status：线程脚本的状态，线程可选状态如下：</li>
</ul>
<p><img src="https://keepmovingxin.github.io//images/luaState/lua-state-05.png" alt=""/></p>
<ul>
<li>StkId top：指向当前线程栈的栈顶指针，typedef TValue *StkId</li>
<li><p>StkId base：指向当前函数运行的相对基位置，具体可参考第四章的闭包</p>
</li>
<li><p>globalState *lG：指向全局状态的指针</p>
</li>
<li>CallInfo *ci：当前线程运行的函数调用信息</li>
<li>const Instruction *savedpc：函数调用前，记录上一个函数的pc位置</li>
<li>StkId stack_last：栈的实际最后一个位置（栈的长度是动态增长的）</li>
<li>StkId stack：栈底</li>
<li>CallInfo *end_ci：指向函数调用栈的栈顶</li>
<li>CallInfo *base_ci：指向函数调用栈的栈底</li>
<li>int stacksize：栈的大小</li>
<li>int size_ci：函数调用栈的大小</li>
<li>unsigned short nCcalls：当前C函数的调用的深度</li>
<li>unsigned short baseCcalls：用于记录每个线程状态的C函数调用深度的辅助成员</li>
<li>lu_byte hookmask：支持哪些hook能力，有下列可选的</li>
</ul>
<p><img src="https://keepmovingxin.github.io//images/luaState/lua-state-06.png" alt=""/></p>
<ul>
<li>lu_byte allowhook：是否允许hook</li>
<li>int basehookcount：用户设置的执行指令数(LUA_MASKCOUNT下有效)</li>
<li>int hookcount：运行时，跑了多少条指令（LUA_MASKCOUNT下有效）</li>
<li>lua_Hook：用户注册的hook回调函数</li>
<li>TValue l_gt：当前线程的全局的环境表</li>
<li>TValue env：当前运行的环境表</li>
<li>GCObject *openupval、gclist：用于gc，详细将会在GC一章细说</li>
<li>struct lua_longjmp *errorJmp：发生错误的长跳转位置，用于记录当函数发生错误时跳转出去的位置。</li>
</ul>
<p><img src="https://keepmovingxin.github.io//images/luaState/lua-state-07.png" alt=""/></p>
<p>本系列总结：</p>
<p>整个系列文章回答了我们对Lua中最基本的一个问题：“一个Lua变量究竟是什么？”。由此我们深入并引申出各种知识，在脚本中我们觉得弱类型变量用起来很痛快，而其实它的内部实现其实是如此的复杂。</p>
<p>对于实现一门脚本语言，必须实现的是解释器、虚拟机、上下文数据3大部分：</p>
<p><img src="https://keepmovingxin.github.io//images/luaState/lua-state-08.png" alt=""/></p>
<p>上下文数据这一层是脚本最基础，最底层的东西，它决定了这门脚本究竟能做什么。抛开解释器和虚拟机，我们依然可以单纯地通过C接口，在C++这一层就能操作脚本的上下文数据。</p>
<p>有空再研究一下Lua的GC，解释器等等。</p>
<p><strong>Lua数据结构</strong>系列转自阿里云博客，作者是<strong>罗日健</strong>。<br/>原文链接：<a href="http://blog.aliyun.com/795" target="_blank" rel="external noopener noreferrer">http://blog.aliyun.com/795</a></p>
<hr/>
<p>扫描二维码或在微信中搜索 KeepMovingXin<br/><img src="https://keepmovingxin.github.io//images/qrcode.jpg" alt="欢迎关注微信公众号！"/></p>