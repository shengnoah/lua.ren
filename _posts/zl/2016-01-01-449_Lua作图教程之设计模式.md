---
layout: post
title: Lua作图教程之设计模式 
tags: [lua文章]
categories: [topic]
---
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>

<p>到目前为止，我在用lua作图时只用到了单例模式，其他设计在后续开发中在逐步添加。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/></pre></td><td class="code"><pre><span class="line">    </span><br/><span class="line"><span class="comment">    优点  </span></span><br/><span class="line"><span class="comment">    一、实例控制  </span></span><br/><span class="line"><span class="comment">    单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。  </span></span><br/><span class="line"><span class="comment">    二、灵活性  </span></span><br/><span class="line"><span class="comment">    因为类控制了实例化过程，所以类可以灵活更改实例化过程。  </span></span><br/><span class="line"><span class="comment">  </span></span><br/><span class="line"><span class="comment">    缺点  </span></span><br/><span class="line"><span class="comment">    一、开销  </span></span><br/><span class="line"><span class="comment">    虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。  </span></span><br/><span class="line"><span class="comment">    二、可能的开发混淆  </span></span><br/><span class="line"><span class="comment">    使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。  </span></span><br/><span class="line"><span class="comment">    三、对象生存期  </span></span><br/><span class="line"><span class="comment">    不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于.NET Framework的语言），只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如 C++），其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用。  </span></span><br/><span class="line"><span class="comment">  </span></span><br/><span class="line"><span class="comment">]]</span><span class="comment">--  </span></span><br/><span class="line">  </span><br/><span class="line">Singleton = {}  </span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(o)</span></span>  </span><br/><span class="line">    o = o <span class="keyword">or</span> {}  </span><br/><span class="line">    <span class="built_in">setmetatable</span>(o,self)  </span><br/><span class="line">    self.<span class="built_in">__index</span> = self  </span><br/><span class="line">    <span class="keyword">return</span> o  </span><br/><span class="line"><span class="keyword">end</span>  </span><br/><span class="line">  </span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Singleton:Instance</span><span class="params">()</span></span>  </span><br/><span class="line">    <span class="keyword">if</span> self.instance == <span class="literal">nil</span> <span class="keyword">then</span>  </span><br/><span class="line">        self.instance = self:new()  </span><br/><span class="line">    <span class="keyword">end</span>  </span><br/><span class="line">    <span class="keyword">return</span> self.instance  </span><br/><span class="line"><span class="keyword">end</span>  </span><br/><span class="line">  </span><br/><span class="line">  </span><br/><span class="line">s1 = Singleton:Instance()  </span><br/><span class="line">  </span><br/><span class="line">s2 = Singleton:Instance()  </span><br/><span class="line">  </span><br/><span class="line"><span class="keyword">if</span> s1 == s2 <span class="keyword">then</span>  </span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;两个对象是相同的实例&#34;</span>)  </span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>