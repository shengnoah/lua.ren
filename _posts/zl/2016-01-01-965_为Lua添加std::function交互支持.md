---
layout: post
title: 为Lua添加std::function交互支持 
tags: [lua文章]
categories: [topic]
---
<p>我们常用的事件等机制需要设置回调函数，在C++中比较方便的是std::function配合lambda使用。当我们使用lua进行脚本化的时候，lua和C++交互便会遇到这样的问题，那么如何在lua脚本中设置和获取std::function作为变量呢？要解决这个问题，我们需要搞定两个方向——Lua-&gt;C++和 C++-&gt;Lua。</p>

<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="Lua-gt-C"><a href="#Lua-gt-C" class="headerlink" title="Lua-&gt;C++"></a>Lua-&gt;C++</h3><p>假如我们有一个回调函数需要设置<code>std::function&lt;void(int)&gt;</code> 该函数在Lua中可能是这样的：<br/></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(tag)</span></span></span><br/><span class="line"><span class="built_in">print</span>(<span class="string">&#34;tag is :&#34;</span> .. tag)</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure><p></p>
<p>它是一个Lua函数，我们可以在Lua栈中获取到它，那么如果我需要在以后调用它，我可以使用<span class="s1">luaL_ref将其注册，在需要调用的时候获取到它的引用，并使用</span><span class="s1">lua_pcall调用它。这样一来思路就清晰了，我们只需要使用lambda表达式构造出一个std::function，内容就是获取到这个Lua function并调用，在这个过程中使用lambda捕获Lua function的引用id，并在function销毁时进行解引用。</span></p>
<h3 id="C-gt-Lua"><a href="#C-gt-Lua" class="headerlink" title="C++-&gt;Lua"></a>C++-&gt;Lua</h3><p>如果是一个std::function压入Lua栈呢，我们可以简单的使用userdata进行储存，使用<span class="s1">lua_newuserdata开一块内存，将std::function拷贝进去，设置好元表，这样就完成了压入栈的操作。</span></p>
<h3 id="C-gt-Lua-gt-C"><a href="#C-gt-Lua-gt-C" class="headerlink" title="C++-&gt;Lua-&gt;C++"></a>C++-&gt;Lua-&gt;C++</h3><p>通过2存入std::function这样问题又来了，传进来的参数有可能是一个function也有可能是一个userdata，我们需要对其分别处理，如果是function，使用lambda进行转换，如果是userdata，直接还原内存。</p>
<p>经过上面的分析，我们可以实现其以下代码：<br/></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/><span class="line">60</span><br/><span class="line">61</span><br/><span class="line">62</span><br/><span class="line">63</span><br/><span class="line">64</span><br/><span class="line">65</span><br/><span class="line">66</span><br/><span class="line">67</span><br/><span class="line">68</span><br/><span class="line">69</span><br/><span class="line">70</span><br/><span class="line">71</span><br/><span class="line">72</span><br/><span class="line">73</span><br/><span class="line">74</span><br/><span class="line">75</span><br/><span class="line">76</span><br/><span class="line">77</span><br/><span class="line">78</span><br/><span class="line">79</span><br/><span class="line">80</span><br/><span class="line">81</span><br/><span class="line">82</span><br/><span class="line">83</span><br/><span class="line">84</span><br/><span class="line">85</span><br/><span class="line">86</span><br/><span class="line">87</span><br/><span class="line">88</span><br/><span class="line">89</span><br/><span class="line">90</span><br/><span class="line">91</span><br/><span class="line">92</span><br/><span class="line">93</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  {</span></span><br/><span class="line">    lua_State *state;</span><br/><span class="line">    <span class="keyword">int</span> ref;</span><br/><span class="line"><span class="keyword">public</span>:</span><br/><span class="line">    FunctionTransfer(lua_State *L, <span class="keyword">int</span> index)</span><br/><span class="line">    {</span><br/><span class="line">        state = L;</span><br/><span class="line">        ref = <span class="number">0</span>;</span><br/><span class="line">        <span class="keyword">if</span> (state) {</span><br/><span class="line">            lua_pushvalue(state, index);</span><br/><span class="line">            ref = luaL_ref(state, LUA_REGISTRYINDEX);</span><br/><span class="line">        }</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R , <span class="keyword">typename</span>... P&gt;</span><br/><span class="line">    static void create(lua_State *L, int index, std::function&lt;R(P...)&gt; &amp;func)</span><br/><span class="line">    {</span><br/><span class="line">        <span class="keyword">auto</span> auf = <span class="built_in">std</span>::make_shared&lt;FunctionTransfer&gt;(L, index);</span><br/><span class="line">        func = [auf](P... p)-&gt;R{</span><br/><span class="line">            lua_State *L = auf-&gt;getState();</span><br/><span class="line">            lua_rawgeti(L, LUA_REGISTRYINDEX, auf-&gt;getRef());</span><br/><span class="line">            <span class="keyword">int</span> nargs = pushArgs(L, p...);</span><br/><span class="line">            lua_pcall(L, nargs, <span class="number">1</span>, <span class="number">0</span>);</span><br/><span class="line">            <span class="keyword">return</span> Stack&lt;R&gt;::get(L, <span class="number">-1</span>);</span><br/><span class="line">        };</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R = <span class="keyword">void</span>, <span class="keyword">typename</span>... P&gt;</span><br/><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> create(lua_State *L, <span class="keyword">int</span> index, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(P...)&gt; &amp;func)</span><br/><span class="line">    {</span><br/><span class="line">        <span class="keyword">auto</span> auf = <span class="built_in">std</span>::make_shared&lt;FunctionTransfer&gt;(L, index);</span><br/><span class="line">        func = [auf](P... p)-&gt;<span class="keyword">void</span>{</span><br/><span class="line">            lua_State *L = auf-&gt;getState();</span><br/><span class="line">            lua_rawgeti(L, LUA_REGISTRYINDEX, auf-&gt;getRef());</span><br/><span class="line">            <span class="keyword">int</span> nargs = pushArgs(L, p...);</span><br/><span class="line">            lua_pcall(L, nargs, <span class="number">0</span>, <span class="number">0</span>);</span><br/><span class="line">        };</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... P&gt;</span><br/><span class="line">    static void create(lua_State *L, int index, std::function&lt;void(void)&gt; &amp;func)</span><br/><span class="line">    {</span><br/><span class="line">        <span class="keyword">auto</span> auf = <span class="built_in">std</span>::make_shared&lt;FunctionTransfer&gt;(L, index);</span><br/><span class="line">        func = [auf]()-&gt;<span class="keyword">void</span>{</span><br/><span class="line">            lua_State *L = auf-&gt;getState();</span><br/><span class="line">            lua_rawgeti(L, LUA_REGISTRYINDEX, auf-&gt;getRef());</span><br/><span class="line">            lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br/><span class="line">        };</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FT&gt;</span><br/><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(lua_State *L, <span class="keyword">int</span> index, <span class="built_in">std</span>::function&lt;FT&gt; &amp;func)</span></span></span><br/><span class="line"><span class="function">    </span>{</span><br/><span class="line">        <span class="keyword">if</span>(lua_isfunction(L, index))</span><br/><span class="line">        {</span><br/><span class="line">            create(L, index, func);</span><br/><span class="line">        }</span><br/><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lua_isuserdata(L, index))</span><br/><span class="line">        {</span><br/><span class="line">            func = (<span class="keyword">decltype</span>(func)(*luaL_checkudata(L, index, <span class="keyword">typeid</span>(func).name())));</span><br/><span class="line">        } <span class="keyword">else</span> {</span><br/><span class="line">            luaL_checktype(L, index, LUA_TFUNCTION);</span><br/><span class="line">        }</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRef</span><span class="params">()</span></span>{<span class="keyword">return</span> ref;}</span><br/><span class="line">    <span class="function">lua_State* <span class="title">getState</span><span class="params">()</span></span>{<span class="keyword">return</span> state;}</span><br/><span class="line"></span><br/><span class="line">    ~FunctionTransfer()</span><br/><span class="line">    {</span><br/><span class="line">        <span class="keyword">if</span> (state) {</span><br/><span class="line">            luaL_unref(state, LUA_REGISTRYINDEX, ref);</span><br/><span class="line">        }</span><br/><span class="line">    }</span><br/><span class="line">};</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FT&gt;</span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &lt;std::function&lt;FT&gt; &gt;</span></span><br/><span class="line"><span class="class">{</span></span><br/><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span> <span class="params">(lua_State* L, <span class="built_in">std</span>::function&lt;FT&gt; func)</span></span></span><br/><span class="line"><span class="function">    </span>{</span><br/><span class="line">        <span class="keyword">new</span> (lua_newuserdata(L, <span class="keyword">sizeof</span>(func))) <span class="built_in">std</span>::function&lt;FT&gt;(func);</span><br/><span class="line">        luaL_newmetatable(L, <span class="keyword">typeid</span>(func).name());</span><br/><span class="line">        lua_setmetatable(L, <span class="number">-2</span>);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">std</span>::function&lt;FT&gt; get (lua_State* L, <span class="keyword">int</span> index)</span><br/><span class="line">    {</span><br/><span class="line">        <span class="built_in">std</span>::function&lt;FT&gt; func;</span><br/><span class="line">        FunctionTransfer::get(L, index, func);</span><br/><span class="line">        <span class="keyword">return</span> func;</span><br/><span class="line">    }</span><br/><span class="line">};</span><br/></pre></td></tr></tbody></table></figure><p></p>
<h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>这里的std::function的userdata的metatable是没有实现__call方法的，因此实际上在lua层并不能调用这个方法。有需要的话可以自行实现。</p>