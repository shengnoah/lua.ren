---
layout: post
title: Redis Lua脚本大学教程 
tags: [lua文章]
categories: [topic]
---
<p>前面我们已经把Redis Lua相关的基础都介绍过了，如果你可以编写一些简单的Lua脚本，恭喜你已经可以从Lua中学毕业了。</p>
<p>在大学课程中，我们主要学习Lua脚本调试和Redis中Lua执行原理两部分内容两部分。</p>
<h4 id="Lua脚本调试"><a href="#Lua脚本调试" class="headerlink" title="Lua脚本调试"></a>Lua脚本调试</h4><p>Redis从3.2版本开始支持Lua脚本调试，调试器的名字叫做LDB。它有一些重要的特性：</p>
<ul>
<li>它使用的是服务器-客户端模式，所以是远程调试。Redis服务器就是调试服务器，默认的客户端是redis-cli。也可以开发遵循服务器协议的其他客户端。</li>
<li>默认情况下，每个debugging session都是一个新的session。也就是说在调试的过程中，服务器不会被阻塞。仍然可以被其他客户端使用或开启新的session。同时也意味着在调试过程中所有的修改在结束时都会回滚。</li>
<li>如果需要，可以把debugging模式调成同步，这样就可以保留对数据集的更改。在这种模式下，调试时服务器会处于阻塞状态。</li>
<li>支持步进式执行</li>
<li>支持静态和动态断点</li>
<li>支持从脚本中向调试控制台打印调试日志</li>
<li>检查Lua变量</li>
<li>追踪Redis命令的执行</li>
<li>很好的支持打印Redis和Lua的值</li>
<li>无限循环和长执行检测，模拟断点</li>
</ul>
<h5 id="Lua脚本调试实战"><a href="#Lua脚本调试实战" class="headerlink" title="Lua脚本调试实战"></a>Lua脚本调试实战</h5><p>在开始调试之前，首先编写一个简单的Lua脚本script.lua：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> src = KEYS[<span class="number">1</span>]</span><br/><span class="line"><span class="keyword">local</span> dst = KEYS[<span class="number">2</span>]</span><br/><span class="line"><span class="keyword">local</span> count = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br/><span class="line"><span class="keyword">while</span> count &gt; <span class="number">0</span> <span class="keyword">do</span></span><br/><span class="line">    <span class="keyword">local</span> item = redis.call(<span class="string">&#39;rpop&#39;</span>,src)</span><br/><span class="line">    <span class="keyword">if</span> item ~= <span class="literal">false</span> <span class="keyword">then</span></span><br/><span class="line">        redis.call(<span class="string">&#39;lpush&#39;</span>,dst,item)</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    count = count - <span class="number">1</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#39;llen&#39;</span>,dst)</span><br/></pre></td></tr></tbody></table></figure>
<p>这个脚本是把src中的元素依次插入到dst元素的头部。</p>
<p>有了这个脚本之后我们就可以开始调试工作了。</p>
<p>我们可以使用<code>redis-cli —eval</code>命令来运行这个脚本，而要调试的话，可以加上—ldb参数，因此我们先执行下面的命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">redis-cli --ldb --<span class="built_in">eval</span> script.lua foo bar , 10</span><br/></pre></td></tr></tbody></table></figure>
<p>页面会出现一些帮助信息，并进入到调试模式</p>
<p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1561000913/Blog/Redis/Lua/lua_debug_01.png" alt="lua_debug_help"/></p>
<p>可以看到帮助页告诉我们</p>
<ul>
<li>执行<strong>quit</strong>可以退出调试模式</li>
<li>执行<strong>restart</strong>可以重新调试</li>
<li>执行<strong>help</strong>可以查看更多帮助信息</li>
</ul>
<p>这里我们执行help命令，查看一下帮助信息，打印出很多可以在调试模式下执行的命令，中括号”[]”内到内容表示命令的简写。</p>
<p>其中常用的有：</p>
<ul>
<li>step/next：执行一行</li>
<li>continue：执行到西一个断点</li>
<li>list：展示源码</li>
<li>print：打印一些值</li>
<li>break：打断点</li>
</ul>
<p>另外在脚本中还可以使用<code>redis.breakpoint()</code>添加动态断点。</p>
<p>下面来简单演示一下</p>
<p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1561002326/Blog/Redis/Lua/lua_debug_02.gif" alt="lua_debug_display"/></p>
<p>现在我把代码中<code>count = count - 1</code>这一行删除，使程序死循环，再来调试一下</p>
<p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1561002773/Blog/Redis/Lua/lua_debug_03.gif" alt="lua_debug_dead_loop"/></p>
<p>可以看到我们并没有打断点，但是程序仍然会停止，这是因为执行超时，调试器模拟了一个断点使程序停止。从源码中可以看出，这里的超时时间是5s。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line"><span class="keyword">if</span> (ar-&gt;event == LUA_HOOKCOUNT &amp;&amp; ldb.step == <span class="number">0</span> &amp;&amp; bp == <span class="number">0</span>) {</span><br/><span class="line">  <span class="keyword">mstime_t</span> elapsed = mstime() - server.lua_time_start;</span><br/><span class="line">  <span class="keyword">mstime_t</span> timelimit = server.lua_time_limit ?</span><br/><span class="line">    server.lua_time_limit : <span class="number">5000</span>;</span><br/><span class="line">  <span class="keyword">if</span> (elapsed &gt;= timelimit) {</span><br/><span class="line">    timeout = <span class="number">1</span>;</span><br/><span class="line">    ldb.step = <span class="number">1</span>;</span><br/><span class="line">  } <span class="keyword">else</span> {</span><br/><span class="line">    <span class="keyword">return</span>; <span class="comment">/* No timeout, ignore the COUNT event. */</span></span><br/><span class="line">  }</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
<p>由于Redis默认的debug模式是异步的，所以在调试结束后不会改变redis中的数据。</p>
<p><img src="https://res.cloudinary.com/dxydgihag/image/upload/v1561004370/Blog/Redis/Lua/lua_debug_04.png" alt="lua_debug_asyn"/></p>
<p>当然，你也可以选择以同步模式执行，只需要把执行命令中的<strong>—ldb</strong>参数改成<strong>–ldb-sync-mode</strong>就可以了。</p>
<h4 id="解读EVAL命令"><a href="#解读EVAL命令" class="headerlink" title="解读EVAL命令"></a>解读EVAL命令</h4><p>前文我们已经详细介绍过EVAL命令了，不了解的同学可以再回顾一下<a href="[https://jackeyzhe.github.io/2019/06/10/Redis-Lua%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/](https://jackeyzhe.github.io/2019/06/10/Redis-Lua脚本中学教程（上）/">Redis Lua脚本中学教程（上）</a>)。今天我们结合源码继续探究EVAL命令。</p>
<p>在server.c文件中，我们知道了eval命令执行的是evalCommand函数。这个函数的实现在scripting.c文件中。</p>
<p>函数调用栈是</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">evalCommand</span><br/><span class="line">	(evalGenericCommandWithDebugging)</span><br/><span class="line">    evalGenericCommand</span><br/><span class="line">      lua_pcall  <span class="comment">//Lua函数</span></span><br/></pre></td></tr></tbody></table></figure>
<p>evalCommand函数很简单，只是简单的判断是否是调试模式，如果是调试模式，调用evalGenericCommandWithDebugging函数，如果不是，直接调用evalGenericCommand函数。</p>
<p>在evalGenericCommand函数中，先判断了key的数量是否正确</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get the number of arguments that are keys */</span></span><br/><span class="line"><span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;numkeys,<span class="literal">NULL</span>) != C_OK)</span><br/><span class="line">    <span class="keyword">return</span>;</span><br/><span class="line"><span class="keyword">if</span> (numkeys &gt; (c-&gt;argc - <span class="number">3</span>)) {</span><br/><span class="line">    addReplyError(c,<span class="string">&#34;Number of keys can&#39;t be greater than number of args&#34;</span>);</span><br/><span class="line">    <span class="keyword">return</span>;</span><br/><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (numkeys &lt; <span class="number">0</span>) {</span><br/><span class="line">    addReplyError(c,<span class="string">&#34;Number of keys can&#39;t be negative&#34;</span>);</span><br/><span class="line">    <span class="keyword">return</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
<p>接着查看脚本是否已经在缓存中，如果没有，计算脚本的SHA1校验和，如果已经存在，将SHA1校验和转换为小写</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* We obtain the script SHA1, then check if this function is already</span></span><br/><span class="line"><span class="comment">     * defined into the Lua state */</span></span><br/><span class="line">funcname[<span class="number">0</span>] = <span class="string">&#39;f&#39;</span>;</span><br/><span class="line">funcname[<span class="number">1</span>] = <span class="string">&#39;_&#39;</span>;</span><br/><span class="line"><span class="keyword">if</span> (!evalsha) {</span><br/><span class="line">    <span class="comment">/* Hash the code if this is an EVAL call */</span></span><br/><span class="line">    sha1hex(funcname+<span class="number">2</span>,c-&gt;argv[<span class="number">1</span>]-&gt;ptr,sdslen(c-&gt;argv[<span class="number">1</span>]-&gt;ptr));</span><br/><span class="line">} <span class="keyword">else</span> {</span><br/><span class="line">    <span class="comment">/* We already have the SHA if it is a EVALSHA */</span></span><br/><span class="line">    <span class="keyword">int</span> j;</span><br/><span class="line">    <span class="keyword">char</span> *sha = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">/* Convert to lowercase. We don&#39;t use tolower since the function</span></span><br/><span class="line"><span class="comment">         * managed to always show up in the profiler output consuming</span></span><br/><span class="line"><span class="comment">         * a non trivial amount of time. */</span></span><br/><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">40</span>; j++)</span><br/><span class="line">        funcname[j+<span class="number">2</span>] = (sha[j] &gt;= <span class="string">&#39;A&#39;</span> &amp;&amp; sha[j] &lt;= <span class="string">&#39;Z&#39;</span>) ?</span><br/><span class="line">        sha[j]+(<span class="string">&#39;a&#39;</span>-<span class="string">&#39;A&#39;</span>) : sha[j];</span><br/><span class="line">    funcname[<span class="number">42</span>] = <span class="string">&#39;