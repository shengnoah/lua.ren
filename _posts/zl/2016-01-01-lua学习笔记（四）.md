---
layout: post
title: lua学习笔记（四） 
tags: [lua文章]
categories: [lua文章]
---
## Lua数组

### 一维数组

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    

|

    
    
    array={"Lua","Java","C++"}  
    for i=0,2 do  
        print(array[i])  
    end  
      
    输出结果：  
    nil  
    Lua  
    Java  
    结果分析：  
    Lua索引值以1为起始，也可以指定0开始  
    ]]  
    -- 以负数为数组索引值  
    array={}  
    for i=-2,2 do  
        array[i]=i*2  
    end  
      
    for i=-2,2 do  
        print(array[i])  
    end  
      
  
---|---  
  
### 多维数组

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    

|

    
    
    -- 初始化数组  
    array={}  
    for i=1,3 do  
        array[i]={}  
        for j=1,3 do  
            array[i][j]=i*j  
        end  
    end  
      
    -- 访问数组  
    for i=1,3 do  
        for j=1,3 do  
            print(array[i][j])  
        end  
    end  
      
  
---|---  
  
## Lua迭代器

一种对象，能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。

在Lua中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素

### 泛型for迭代器

泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量

#### 泛型for的执行过程

<https://www.runoob.com/lua/lua-iterators.html>

### Lua迭代器类型

  * 无状态的迭代器
  * 多状态的迭代器

#### 无状态的迭代器

不保留任何状态的迭代器，每一次迭代，迭代函数都是用 **两个变量**
（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。如：`ipairs`函数

#### 多状态的迭代器

迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，方法：

  * 使用闭包（类似于lambda表达式，该表达式能包含函数本身以及外部引用变量，外部引用变量类似于lambda表达式中`[]`内捕获的外部变量）
  * 将所有状态信息封装到table内

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    

|

    
    
    array={"Google","Apple"}  
      
    function (collection)  
        local index=0  
        local count=#collection  
        -- 闭包函数  
        return function()  
            index=index+1  
            if index<=count then  
                return collection[index]  
            end  
        end  
    end  
      
    for element in elementIterator(array) do  
        print(element)  
    end  
      
    输出结果：  
    Google  
    Apple  
    ]]  
      
  
---|---  
  
## Lua table（表）

table是一种数据结构，可以用于创建不同的数据类型：数组、字典等

table的特点：

  * 使用关联型数组，可以用任意非nil的类型作为数组的索引
  * 大小不固定，可以根据需要扩容
  * 可以用于解决模块（module）、包（package）和对象（Object）

### table的构造

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    

|

    
    
    -- 初始化表  
    mytable={}		-- 最简单的构造函数  
      
    -- 指定值  
    mytable[1]="Lua"  
      
    -- 移除引用  
    mytable=nil  
    -- Lua垃圾回收会释放内存  
      
    -- 注意：table间的赋值是传引用，两者指向同一个内存，只有当没有任何变量指向该内存（即所有table变量都指向了nil），Lua的垃圾回收机制才会清理相对应的内存  
      
  
---|---  
  
### table操作

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    

|

    
    
      
    作用：列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开  
    参数列表：  
    	table：操作对象  
    	sep：分隔符  
    	start：起始索引  
    	end：末尾索引  
    返回值：连接后的字符串  
    ]]  
    table.concat(table[,sep[,start[,end]]])  
      
      
    作用：在table的数组部分指定位置(pos)插入值为value的一个元素  
    参数列表：  
    	table：操作对象  
    	pos：插入位置，默认为数组部分的末尾  
    	value：插入的值  
    返回值：  
    ]]  
    table.insert(table,[pos,]value)  
      
      
    作用：删除table数组部分位于pos位置的元素，其后的元素会被前移  
    参数列表：  
    	table：操作对象  
    	pos：删除的元素位置，默认为最后一个元素的位置  
    返回值：删除的元素的值  
    ]]  
    table.remove(table[,pos])  
      
      
    作用：对给定的table进行升序排序，数值按照数值大小，字符串按照首字母ASCCI码排序  
    参数列表：  
    	table：操作对象  
    	comp：比较方法，接收两个参数，返回一个布尔值，为true不交换，为false交换  
    返回值：nil  
    ]]  
    table.sort(table[,comp])  
      
  
---|---