---
layout: post
title: 《实现angluar》手记八:过滤器 
tags: [lua文章]
categories: [topic]
---
## 目标

实现过滤器`|`以及内置过滤器函数`filter`

## 过滤器

过滤器函数接受一个表达式, 并且返回一个处理后的最终值, 其使用的是 `|`管道语法, 左边接受的是原始的表达式, 右边接受的是过滤器函数,
**过滤器函数只接受一个值**

    
    
    1  
    

|

    
    
    myExpression | uppercase  
      
  
---|---  
  
过滤器可以组合

    
    
    1  
    

|

    
    
    myNumbers | odd | increment  
      
  
---|---  
  
由于过滤器就是一个函数, 上述表达式实际上等价于

    
    
    1  
    

|

    
    
    increment(odd(myNumbers))  
      
  
---|---  
  
## 过滤器注册

recurse函数递归调用自身, 加上数组的push方法, 这样得出来的字符串恰好是我们想要的,
注意forEach之中作者鸡贼地仅仅遍历拼接了ast.body前n-1项

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    

|

    
    
    ASTCompiler.prototype.recurse = function (ast, context, create) {  
        var intoId;  
        var self = this;  
        switch (ast.type) {  
            case AST.Program:  
                _.forEach(_.initial(ast.body), function (stmt) {  
                    self.state.body.push(self.recurse(stmt), ';');  
                });  
                self.state.body.push('return ', self.recurse(_.last(ast.body)), ';');  
                break;  
      
  
---|---  
      
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    

|

    
    
    register('upcase', function () {  
        return function (str) {  
            return str.toUpperCase();  
        };  
    });  
    var fn = parse('aString | upcase');  
    fn({ aString: 'Hello' });  
      
  
---|---  
  
上面几段代码最终编译成下面的函数

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    

|

    
    
    (function anonymous(ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, ifDefined, filter) {  
        var v0 = filter('upcase');  
        var fn = function(s, l) {  
            var v1;  
            if (l && ('aString'in l)) {  
                v1 = (l).aString;  
            }  
            if (!(l && ('aString'in l)) && s) {  
                v1 = (s).aString;  
            }  
            ensureSafeObject(v1);  
            return v0(v1);  
        };  
        return fn;  
    }  
    )  
      
  
---|---  
  
我们来看下作者是如何解决传参的问题的

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    

|

    
    
        var fnString = this.filterPrefix() +  
            'var fn=function(s,l){' +  
            (this.state.vars.length ?  
                'var ' + this.state.vars.join(',') + ';' :  
                ''  
            ) +  
            this.state.body.join('') +  
            '}; return fn;';  
      
        return new Function(  
            'ensureSafeMemberName',  
            'ensureSafeObject',  
            'ensureSafeFunction',  
            'ifDefined',  
            'filter',  
            fnString)(  
                ensureSafeMemberName,  
                ensureSafeObject,  
                ensureSafeFunction,  
                ifDefined,  
                filter);  
    `  
      
  
---|---  
  
## 过滤器的链式调用

## 额外的过滤器参数

## 内置的filter过滤器

降级写法 `var token = op3 ? ch3 : (op2 ? ch2 : ch);`

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    

|

    
    
    // "="与"==","=="   
    var ch = this.ch;  
    var ch2 = this.ch + this.peek();  
    var ch3 = this.ch + this.peek() + this.peek(2);  
    var op = OPERATORS[ch];  
    var op2 = OPERATORS[ch2];  
    var op3 = OPERATORS[ch3];  
    if (op || op2 || op3) {  
        var token = op3 ? ch3 : (op2 ? ch2 : ch);  
        this.tokens.push({ text: token });  
        this.index += token.length;  
    } else {  
        throw 'Unexpected next character: ' + this.ch;  
    }  
      
  
---|---  
  
优先级的处理方法: 让优先级比较`低`的去调用优先级比较`高`的函数  
The final precedence order of the operators can be read by looking at the
order in which the AST builder’s methods are called `in reverse`:

  1. Primary expressions: Lookups, function calls, method calls.
  2. Unary expressions: +a, -a, !a.
  3. Multiplicative arithmetic expressions: a * b, a / b, and a % b.
  4. Additive arithmetic expressions: a + b and a - b.
  5. Relational expressions: a < b, a > b, a <= b, and a >= b.
  6. Equality testing expressions: a == b, a != b, a === b, and a !== b.
  7. Logical AND expressions: a && b.
  8. Logical OR expressions: a || b.
  9. Ternary expressions: a ? b : c.
  10. Assignments: a = b.