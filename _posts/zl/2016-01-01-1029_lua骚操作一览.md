---
layout: post
title: lua骚操作一览 
tags: [lua文章]
categories: [topic]
---
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做了三年的游戏开发，其中有两年都在使用Lua这一脚本语言，想着是时候写点什么东西输出一下，算是给个交代。本文既不是讲Lua入门，也不会讲到Lua虚拟机那么深，读者尽可放大心随意看。</p>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><p>原生Lua是不支持面向对象编程的。那怎么办呢？使用prototype模式即可。</p>
<p>首先读者需要知道Lua的原方法和原表这一知识点。如果接触过c++或者c#的同学应该知道我们可以对一些类的操作做重载(<em>overload</em>)，改变诸如加减乘除，甚至一些更高级的操作。而在像是Lua这种脚本语言来说是没有重载这一操作的。取而代之的，我们可以通过重写元表来改变table原有的操作逻辑。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> theMetaTable = {}</span><br/><span class="line"></span><br/><span class="line">theMetaTable.<span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(leftVal, rightVal)</span></span></span><br/><span class="line">    <span class="keyword">local</span> ret = {}</span><br/><span class="line">    ret.age = leftVal.age + rightVal.age</span><br/><span class="line">    <span class="keyword">return</span> ret</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> tA = {age = <span class="number">1</span>}</span><br/><span class="line"><span class="keyword">local</span> tB = {age = <span class="number">99</span>}</span><br/><span class="line"><span class="built_in">setmetatable</span>(tA, theMetaTable)</span><br/><span class="line"><span class="built_in">setmetatable</span>(tB, theMetaTable)</span><br/><span class="line"><span class="keyword">local</span> tC = tA + tB</span><br/><span class="line"><span class="comment">-- tC = {age = 100}</span></span><br/><span class="line"><span class="built_in">print</span>(tc.age)</span><br/></pre></td></tr></tbody></table></figure>
<p>在这么多元方法里面有一个最值得关注的，称为<code>__index</code>。顾名思义，传入一个key，返回一个value。接下来就来讲解如何使用这个元方法实现面向对象。首先我们假设有一个方法叫做<code>class(string name)</code>，会生成一个带有构造方法和其他各种方法的类原型（类原型是啥意思？类似于Java里的Class，c#里的Type），我们使用这个类原型就可以实例化出我们的实例来。使用方法大概是这样子的：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/></pre></td><td class="code"><pre><span class="line">Person = class(<span class="string">&#39;class&#39;</span>)</span><br/><span class="line">Person.name = <span class="string">&#39;DefaultName&#39;</span></span><br/><span class="line">Person.age = <span class="number">-1</span>;</span><br/><span class="line">Person.sex = <span class="string">&#39;male&#39;</span></span><br/><span class="line">Person.<span class="built_in">create</span> = <span class="function"><span class="keyword">function</span><span class="params">(name, age)</span></span></span><br/><span class="line">    <span class="keyword">local</span> ret = Person.new()</span><br/><span class="line">    ret.name = name</span><br/><span class="line">    ret.age = age</span><br/><span class="line">    <span class="keyword">return</span> ret</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line">Person.introduce = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&#39;i am %s, and i am %d&#39;</span>, self.name, self.age))</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> oldWong = Person.<span class="built_in">create</span>(<span class="string">&#39;oldWong&#39;</span>, <span class="number">45</span>)</span><br/><span class="line">oldWong.sex = <span class="string">&#39;female&#39;</span></span><br/><span class="line">oldWong:introduce()</span><br/><span class="line"><span class="comment">-- console print: I am oldWong, and i am 45.</span></span><br/></pre></td></tr></tbody></table></figure>
<p>明眼的读者可以发现了：从class函数返回的<code>Person</code>一定是一个带着new方法的table。但是为什么这个new方法会生成新的实例呢？我改变oldWong实例的<code>sex</code>属性之后，再用Person去实例化一个实例，会是什么性别？有兴趣的读者可自行试试。</p>
<p>接下来笔者将为你揭秘<code>__index</code>方法在<code>class(string name)</code>函数中的应用。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(clzName)</span></span></span><br/><span class="line">    <span class="keyword">local</span> ret = {}</span><br/><span class="line">    ret.__class = {}</span><br/><span class="line">    ret.__class.__name = clzName</span><br/><span class="line">    ret.new = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">        <span class="keyword">local</span> instance</span><br/><span class="line">        <span class="comment">-- metatable</span></span><br/><span class="line">        <span class="keyword">local</span> mt = {}</span><br/><span class="line">        mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, key)</span></span></span><br/><span class="line">            <span class="keyword">return</span> <span class="built_in">rawget</span>(instance, key) <span class="keyword">or</span> ret[key]</span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">        <span class="built_in">setmetatable</span>(instance, mt)</span><br/><span class="line">        <span class="keyword">return</span> instance</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    <span class="keyword">return</span> ret</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>看一个函数我习惯先看最后return了什么东西，再看这个返回值是怎么被创建的，内容是啥。在这个<code>class</code>方法中，返回值是一个被命名为ret的表，这个表被填进了两个东西：</p>
<ul>
<li>类的信息，暂时只有类名</li>
<li>一个叫做new的方法</li>
</ul>
<p>看起来这个new方法就是关键了。</p>
<p>new方法最后返回了一个叫instance的table，这个看似什么内容都没有。等等…并不是什么东西都没有，这个table被塞进了一个元表(metatable)，而这个元表被重写了<code>__index</code>方法。</p>
<p><code>__index</code>方法实际上是为了定义一种行为：传进一个key，返回一个value。也就是说根据上面的代码，当mt这个表被设置为instance的元表之后，当以后外界要从instance取东西出去的时候，会先在表本身里面找(rawget)，如果找不到了，再继续在找ret表里面找。</p>
<p>看完上面的解释，我相信还是有一部分读者会睁着大眼睛问我，你说了这么多，那和面向对象有鸡毛关系？没事，笔者这篇文章本来就是想写给对Lua了解不深的朋友看的，所以一定会解释清楚。</p>
<p>我们要知道，在Lua中，方法其实是一个内置类型，成为function。当一个表想调用自己拥有的一个方法的时候有两种形式：</p>
<ul>
<li>t.function(t)</li>
<li>t:function()</li>
</ul>
<p>上面两种形式是等效的，使用冒号连接的时候，会把冒号前面的变量作为后面方法的第一个变量传入。</p>
<p>在上面关于Person的代码例子中，有一句代码我们来看看是怎么最后调用成功的。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">oldWong:introduce()</span><br/></pre></td></tr></tbody></table></figure>
<p>在调用<code>introduce()</code>之前，Lua需要先从oldWong这个表中拿出这个属性。这是一种以key换value的操作，于是自然会调用到<code>__index</code>元方法。首先Lua会在oldWong本身中找这个方法，找不到，然后就会在<code>__index</code>那段代码里的ret表里面找。还记得ret最后被返回，被我们持有为叫做Person的表了吗？</p>
<p>所以’oldWong:introduce()’的实质调用，可以看做是</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">Person.introduce(oldWong)</span><br/></pre></td></tr></tbody></table></figure>
<p>明白了吧。</p>
<h3 id="老王的叛逆"><a href="#老王的叛逆" class="headerlink" title="老王的叛逆"></a>老王的叛逆</h3><p>接下来，我们假设老王是一个很叛逆的人，他不想按照我们给他的方法进行自我介绍，想要用自己的方式来展示足够骚的自己，他怎么做呢：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">oldWong.introduce = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#39;i am Xiao Wang, bu yiyang de Xiao Wang&#39;</span>)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">oldWong.introduce()</span><br/></pre></td></tr></tbody></table></figure>
<p>老王他重写了自己的introduce方法。现在再从老王这个<del>婊</del>表中再读出introdce这个成员变量的时候，由于老王本身就已经拥有了自我介绍这个方法，于是就直接返回这个方法，不需要再从类里面去寻找原始的introduce方法了。于是老王的自我介绍就自成一派了。</p>
<p>在老王叛逆的故事中，我们可以学到一种debug的方法。在我两年的lua使用时间中，其中一年半是在使用cocos2dx的，以这里为例子解释一下如何使用这个原理来快速debug。</p>
<p>cocos2dx的节点Node类有一个<code>addChild(self, childNode)</code>方法，用来添加一个子节点。现在我发现游戏中有一个节点oldWongNode，莫名其妙地添加了一个叫做runNode的节点，但是由于前人写的代码太冗长太垃圾，找了半天都找不到究竟这个子节点是在哪里被添加的。这个时候我想起了老王的故事，这么写了一段代码，然后发现了究竟是哪个<del>凶手</del>同事调用了调用了这个方法添加了runNode：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> rawAddChild = oldWongNode.addChild</span><br/><span class="line">oldWongNode.addChild = <span class="function"><span class="keyword">function</span><span class="params">(self, child)</span></span></span><br/><span class="line">    <span class="keyword">if</span> child.name == <span class="string">&#39;runNode&#39;</span>:</span><br/><span class="line">        printTraceback()</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    rawAddChild(self, child)</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>未完待续。。。</p>