---
layout: post
title: Lua入门 
tags: [lua文章]
categories: [topic]
---
<h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1 注释"></a>1 注释</h4><p>行注释：<code>--</code>；<br/>块注释：<code>--[[注释内容]]</code>，推荐用<code>--[=[注释内容]=]</code>，其中<code>=</code>的个数前后一致。</p>
<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h4><p>基础类型有8种：</p>
<ol>
<li><code>nil</code><br/>未初始化的变量默认为<code>nil</code>；删除一个全局变量<code>b=nil</code></li>
<li><code>boolean</code><br/>只有false和nil视为<code>false</code>，其他值都为<code>true</code></li>
<li><code>number</code><br/>默认只有一种<code>double</code>类型</li>
<li><code>string</code><br/>一对单引号或双引号；表示一块字符串<code>[[]]</code>；字符串连接符<code>..</code>；长度操作符<code>#</code>；计算时数字与字符串自动转换</li>
<li><code>table</code><br/>数组+哈希表，一种动态分配的对象，程序仅持有一个对他们的引用；注意<code>a[&#39;x&#39;]</code>和<code>a.x</code>等价，但容易出错；索引的起始值为1；包含空隙Hole的数组，#会认为nil就是结尾标记，这时应该用<code>table.maxn()</code>，Lua5.2之后该方法不存在</li>
<li><code>function</code><br/>看做“第一类值”，可以赋给变量；允许以匿名函数的形式通过参数传递</li>
<li><code>thread</code><br/>在Lua里主要是协同程序，跟线程差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西；线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起<code>suspend</code>时才会暂停。</li>
<li><code>userdata</code><br/>用户自定义数据，可以将C/C++的任意数据类型（通常是 struct 和 指针）存储到 Lua 变量中调用。</li>
</ol>
<p>注意：对于 <code>table/userdata/function</code>，只做引用的比较，<code>a~=b</code>。</p>
<h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3 变量"></a>3 变量</h4><ul>
<li>Lua中的变量全是全局变量，哪怕是语句块或是函数里，除非用 <code>local</code> 显式声明；</li>
<li>局部变量的作用域为从声明位置开始到所在语句块结束，缩短变量的作用域能提高代码的可读性，块作用域 <code>do-end</code>；</li>
<li>尽可能使用局部变量：<code>local foo = foo</code>，避免命名冲突，同时加速在当前作用域对 foo 的访问；</li>
<li>对 table 的索引使用方括号 <code>[]</code>，<code>.</code> 操作符是索引为字符串类型时的一种简化写法。</li>
</ul>
<h4 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4 表达式"></a>4 表达式</h4><ul>
<li>先计算右边所有的值然后再执行赋值操作：<code>x, y = y, x</code>；</li>
<li>变量和值的个数不一致时：<code>a, b = 0 --b=nil</code>，<code>a, b = 0, 1, 2 --2 is ignored</code>；</li>
<li>and和or都是短路求值，只在需要时才评估第二个数，<code>x = x or v</code>，<code>max = (x&gt;y) and x or y</code>；</li>
</ul>
<h4 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5 迭代器"></a>5 迭代器</h4><p>迭代器获取三个值：迭代函数、状态常量、控制变量；<br/>无状态迭代器，避免创建闭包花费额外的代价；多状态迭代器，对应“多个状态信息”，将所有的状态封装到table内，作为迭代函数的唯一参数；<br/>不同类型的迭代器：文件中的每行 <code>io.lines</code>，table元素 <code>pairs</code>（遍历所有的值，包括nil），数组元素 <code>ipairs</code>（不能返回nil），字符串元素 <code>string.gmatch</code>。</p>
<h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h4><ul>
<li>函数的两个用途：作为调用语句，完成指定任务；</li>
<li>多返回值、可变参数 <code>(fmt, …)</code>、具名实参；</li>
<li>支持“尾调用消除”：递归不会造成栈溢出；编写“状态机”；</li>
<li>判断“尾调用”：一个函数在调用完另一个函数后，是否无需做其他事情；完成一条 goto 语句到另一个函数，非传统的函数调用；<code>return &lt;func&gt;(&lt;args&gt;)</code>。</li>
<li>冒号操作符：面向对象式的调用，<code>o.foo(o, x)</code> 等价于 <code>o:foo(x)</code>；所有Lua标准程序库的函数都是用C语言写的，但对于Lua程序员来说是透明的。</li>
</ul>