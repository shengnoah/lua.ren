---
layout: post
title: Lua数据类型 
tags: [lua文章]
categories: [topic]
---
<h2 id="前言">前言</h2>

<p>接触lua近4年了，一直断断续续读相关源码，这次计划把lua源码整体分析一遍，基于最新版本(<em>Lua 5.3.5</em>), 完成如下文章（顺序可能不一致）：</p>
<ul>
  <li>基本数据类型</li>
  <li>string/table 剖析</li>
  <li>luavm 分析</li>
  <li>lexer/ast/gencode 词法分析/语法树/生成字节码</li>
  <li>lua周边支持：debug/continue等</li>
</ul>

<h3 id="lua源码简介">lua源码简介</h3>
<ul>
  <li>可以从lua官方网站下载最新源码：<a href="https://www.lua.org/">源码下载</a></li>
  <li>推荐直接用 vscode+wsl 阅读代码，<a href="https://code.visualstudio.com/docs/cpp/config-wsl">方案参考</a>，然后可以配置Task/Debug， 很方便地即可实现断点，code定位等常用功能， 注意修改一下gcc编译优化等级即可</li>
</ul>

<h3 id="lua数据类型概括">Lua数据类型概括</h3>
<p>lua数据类型定义在 <b>lobject.h</b> 中, 暴露出来的类型一共有9中：nil/bool/lightud/number/string/table/func/ud/thread, 定义：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8
</code></pre></div></div>
<p>如此看，似乎4个bit就能完全满足类型定义了，但是lua在一些数据类型实现上还有进一步细分，如</p>
<ul>
  <li><em>LUA_TNUMBER</em> 细分：<em>LUA_TNUMFLT/LUA_TNUMINT</em> (float64/int64)</li>
  <li><em>LUA_TSTRING</em> 细分：<em>LUA_TSHRSTR/LUA_TLNGSTR</em></li>
  <li><em>LUA_TFUNCTION</em> 细分：<em>LUA_TLCL/LUA_TLCF/LUA_TCCL</em></li>
</ul>

<p>lua从设计上只想暴露出9中数据类型，但是实现上必须更加精巧地去考虑，那么如何用一个字节去定义9种基础类型以及部分细分类型：</p>
<ul>
  <li>0 - 3bit：定义9种基础数据类型，一共可以定义15种目前用了9种</li>
  <li>4 - 6bit: 定义细分类型</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define LUA_TLCL	(LUA_TFUNCTION | (0 &lt;&lt; 4))  /* Lua closure */
#define LUA_TLCF	(LUA_TFUNCTION | (1 &lt;&lt; 4))  /* light C function */
#define LUA_TCCL	(LUA_TFUNCTION | (2 &lt;&lt; 4))  /* C closure */

/* Variant tags for strings */
#define LUA_TSHRSTR	(LUA_TSTRING | (0 &lt;&lt; 4))  /* short strings */
#define LUA_TLNGSTR	(LUA_TSTRING | (1 &lt;&lt; 4))  /* long strings */

/* Variant tags for numbers */
#define LUA_TNUMFLT	(LUA_TNUMBER | (0 &lt;&lt; 4))  /* float numbers */
#define LUA_TNUMINT	(LUA_TNUMBER | (1 &lt;&lt; 4))  /* integer numbers */
</code></pre></div></div>

<p>那么为什么不能这么定义呢</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define LUA_TNUMFLT		9
#define LUA_TNUMINT     10
....
</code></pre></div></div>
<p>如果真的这样定义也不是一定就不行，但是会有一个小问题，当我们判断某个数据类型是不是 <em>LUA_TNUMBER</em> 时就变得有点麻烦，可能就需要<code class="language-plaintext highlighter-rouge">if type == LUA_TNUMFLT or type == LUA_TNUMINT {do something}</code>, 但是用bit去定义就可以 <code class="language-plaintext highlighter-rouge">if type &amp; LUA_TNUMBER { do something}</code></p>

<h3 id="lua数据类型结构体定义">Lua数据类型结构体定义</h3>

<ul>
  <li>
    <p>lua 是一种弱类型脚本语言，所以在实现时期望用一个统一的结构对象去实现所有类型，类比到高级语言种如：C# 可以用object对象去实现，golang可以用interface{}，java可以用Object等等，不考虑值类型装箱问题的话，的确可以这么做的。 但是放到c语言中，假设我们尝试用void*去处理，一则值类型也必须用指针处理，再者此时就失去原类型的定义，如任意 <em>void* ptr</em>并无法知道ptr具体是什么类型</p>
  </li>
  <li>可以用 <em>struct</em> 去实现吗？ 自然也不太好，struct会带来内存浪费问题，比如会如下定义 :
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct LuaType {
  int64 num;
  char* str;
  Table tbl;
  char type;
  ... 
  }  
</code></pre></div>    </div>
    <p>那么对于任意 LuaType 对象来说，内存都是 sizeof(LuaType) = sizeof(int64)+sizeof(char*)…., 然后需要的仅仅是某个类型+type的内存</p>
  </li>
  <li>Lua用了c中union去实现这种“内存共享”逻辑 <a href="https://www.geeksforgeeks.org/union-c/">union 参考</a></li>
</ul>

<p>Lua 数据类型大体上分为：可被<em>GC的对象 / 值类型</em>，<b><em>TValue</em></b> 是lua中所有类型的表示, 定义：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Inteluager i;   /* integer numbers */
  lua_Number n;    /* float numbers */
} Value;

#define TValuefields	Value value_; int tt_ 

typedef struct lua_TValue {
  TValuefields;
} TValue;

</code></pre></div></div>
<p>其中 <em>Value value_</em> 定义了数据部分，tt_ 定义了数据类型：</p>
<ul>
  <li>
    <p>lua_Number/lua_Inteluager 分别定义为：double/long long，所以lua中number就是8字节，浮点的数的话用double，那么它的精度就是52位 （最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M）， 所以如果是一个超出52位整型转float64时可能会丢失精度</p>
  </li>
  <li>
    <p>所以一个lua 数据对象，在内存中占用最少 12byte = sizeof(long long) + sizeof(int)</p>
  </li>
  <li>
    <p>tt_ 定义了具体数据类型，其中如果是 GCObject* 则tt_第7位会标记出来 <code class="language-plaintext highlighter-rouge">#define BIT_ISCOLLECTABLE	(1 &lt;&lt; 6);#define ctb(t)			((t) | BIT_ISCOLLECTABLE)</code></p>
  </li>
</ul>

<p>GCObject 是所有可GC对象的定义</p>
<ul>
  <li>next 字段使得GCObject可以变成一个单项链表，用于GC过程中遍历以及“根对象”管理</li>
  <li>tt 表示该对象类型类型</li>
  <li>mark 字段用于GC过程中的 扫描标记中 white/gray/black 标记</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Common Header for all collectable objects (in macro form, to be included in other objects) */
#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked

/* Common type has only the common header */
struct GCObject {
  CommonHeader;
};

</code></pre></div></div>

<h3 id="lua-数据结构字段getset-封装">Lua 数据结构字段get/set 封装</h3>

<p>为了更加方便地操作TValue字段，Lua定义了各种宏去判断类型/字段访问等，之所以用宏，主要考虑避免method频繁调用带来的上下文切换开销：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define val_(o)		((o)-&gt;value_)

/* raw type tag of a TValue */
#define rttype(o)	((o)-&gt;tt_)

/* tag with no variants (bits 0-3) */
#define novariant(x)	((x) &amp; 0x0F)

/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */
#define ttype(o)	(rttype(o) &amp; 0x3F)

/* type tag of a TValue with no variants (bits 0-3) */
#define ttnov(o)	(novariant(rttype(o)))
</code></pre></div></div>
<p>值得注意的是 如果是9种基础类型，那么用：<code class="language-plaintext highlighter-rouge">novariant(x)</code> 去处理即可, 细分类型用 <code class="language-plaintext highlighter-rouge">ttype(o)</code>, 正如Lua源码更高级地接口封装：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Macros to test type */
#define checktag(o,t)		(rttype(o) == (t))
#define checktype(o,t)		(ttnov(o) == (t))
#define ttisnumber(o)		checktype((o), LUA_TNUMBER)
#define ttisfloat(o)		checktag((o), LUA_TNUMFLT)
#define ttisinteger(o)		checktag((o), LUA_TNUMINT)
...
</code></pre></div></div>

<p>对于非GC类型的对象，<em>get/set</em> 不用转型，直接访问即可，如：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define settt_(o,t)	((o)-&gt;tt_=(t))

#define setfltvalue(obj,x) 
  { TValue *io=(obj); val_(io).n=(x); settt_(io, LUA_TNUMFLT); }

#define chgfltvalue(obj,x) 
  { TValue *io=(obj); lua_assert(ttisfloat(io)); val_(io).n=(x); }

#define setivalue(obj,x) 
  { TValue *io=(obj); val_(io).i=(x); settt_(io, LUA_TNUMINT); }
</code></pre></div></div>

<p>但是GC类型需要特殊处理一下， 因为他们本身是一种”继承“的复合类型，如string的定义：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  /*
** Header for string value; string bytes follow the end of this structure
** (aligned according to &#39;UTString&#39;; see next).
*/
typedef struct TString {
  CommonHeader;
  lu_byte extra;  /* reserved words for short strings; &#34;has hash&#34; for longs */
  lu_byte shrlen;  /* length for short strings */
  unsigned int hash;
  union {
    size_t lnglen;  /* length for long strings */
    struct TString *hnext;  /* linked list for hash table */
  } u;
} TString;

/*
** Ensures that address after this type is always fully aligned.
*/
typedef union UTString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  TString tsv;
} UTString;

</code></pre></div></div>
<p>复杂的GCObject类型数据访问方式需要特使处理，TString 内存结构： TString+rawData, 其中rawData就是真正存数据的内存，所以分配过程：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static TString *createstrobj (lua_State *L, size_t l, int tag, unsigned int h) {
  TString *ts;
  GCObject *o;
  size_t totalsize;  /* total size of TString object */
  totalsize = sizelstring(l);
  o = luaC_newobj(L, tag, totalsize);
  ts = gco2ts(o);
  ts-&gt;hash = h;
  ts-&gt;extra = 0;
  getstr(ts)[l] = &#39;