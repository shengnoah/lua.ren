---
layout: post
title: Lua 学习 chapter7  
tags: [lua文章]
categories: [topic]
---


                
                

				<h3 id="目录">目录</h3>
<ol>
  <li>简单I/O模型</li>
  <li>完整I/O模型</li>
  <li>其它文档操作</li>
  <li>其它系统调用</li>
</ol>



<h2 id="简单io模型">简单I/O模型</h2>
<p>对于文档操作，I/O提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前的输出流，其I/O是通过这些流实现的。
I/O库把当前的输入流初始化为进程的标准输入(C中的stdin),将当前的输出流初始化进程的标准输出(C中的stdout)。因此当执行io.read()这样的语句的时候就可以从标准的输入中读取一行。</p>

<p>函数的io.input和函数io.output用来改变当前的输入输出流。
io.input(fileName)会以只读的方式打开指定的文档，并将文档设置为当前的输入流。之后所有的输入都将来自于这个文档，除非重新调用io.input函数来改变。对于输出与之类似。</p>

<p><strong>函数write()</strong>:
由于调用该函数可以传入多个参数，所以应该避免使用io.write(a..b..b),而是使用write(a,b,c)。
作为原则应该只在用后<strong>即弃</strong>的代码或者调试代码的时候调用print输出，当需要完全控制输出是，应该使用io.write()输出，和print不同，
函数io.write最终的输出不会添加诸如制表符或者换行符这样的额外内容。
此外函数io.write允许对输出进行重定向，而函数print只能使用标准输出。函数print会为其参数调用tostring函数。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nb">io.write</span><span class="p">(</span><span class="s2">"sin(3)="</span><span class="p">,</span><span class="nb">math.sin</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="s2">"</span><span class="se">n</span><span class="s2">"</span><span class="p">)</span> <span class="c1">-- &gt;sin(3) = 0.1411200080</span>
<span class="nb">io.write</span><span class="p">(</span><span class="nb">string.format</span><span class="p">(</span><span class="s2">"sin(3)=%.4fn"</span><span class="p">,</span><span class="nb">math.sin</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span> <span class="c1">-- &gt;sin(3) = 0.1411</span>

<span class="nb">io.read</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span> <span class="c1">--&gt;从当前位置开始的读取当前输入文档的全部内容</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>函数io.read可以从当前的输入流中读取字符串，其参数决定了其要读取的数据：</p>

<ol>
  <li>“a”  读取整个文档</li>
  <li>“l”  读取下一行 （丢弃换行符）  默认参数</li>
  <li>“L”  读取下一行（保留换行符）</li>
  <li>“n”  读取一个数值(number 类型)</li>
  <li>num  以字符串读取num个字符</li>
</ol>

<p>获取一个文档的所有行数可以使用 io.lines() 函数</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kd">local</span> <span class="n">lines</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="nb">io.lines</span><span class="p">()</span> <span class="k">do</span>
    <span class="n">lines</span><span class="p">[</span><span class="o">#</span><span class="n">lines</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
<span class="k">end</span>

<span class="nb">table.sort</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">do</span>
    <span class="nb">io.write</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">"</span><span class="se">n</span><span class="s2">"</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>io.write(n) 从当前的输入流中最多读取n个字符，如果没有字符返回nil,io.write(0)是一个特烈，它常用于测试是否达到了文档末尾。如果仍然有数据可供读取，他就会返回一个空字符串，否则返回nil。</p>

<h2 id="完整io模型">完整I/O模型</h2>
<p>可以使用io.open来打开一个文档。该函数拥有两个参数，一个是文档名，一个是打开的模式。</p>
<ol>
  <li>“r”  只读</li>
  <li>“w”  只写(可以用来删除文档中原来的内容)</li>
  <li>“a”  追加</li>
  <li>“b”  打开二进制文档</li>
</ol>

<p>io.open函数打开发生错的时候会返回两个值，一个是nil另一个是系统相关错误的错误码</p>

<p>检测错误的一种典型方法是使用函数assert:
local f = assert(io.open(fileName,mode))  发生错的时候错误信息会作为函数assert的第二个餐宿被传入。 然后assert会将错误信息展示出来。</p>

<p>文档打开之后可以使用从流中读取和写入。</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">local</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">assert</span><span class="p">(</span><span class="nb">io.open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="s2">"r"</span><span class="p">))</span>
<span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="n">f</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
<span class="n">f</span><span class="p">:</span><span class="n">close</span><span class="p">()</span>
<span class="c1">-- io.stdin, io.stdout, io.stderr</span>
<span class="nb">io.stderr</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Io库提供了三个预定义的C语言流的句柄，可以直接调用。</p>

<p>可以通过io.input 和 io.output 来改变的当前的输入输出流</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">local</span> <span class="n">temp</span> <span class="o">=</span> <span class="nb">io.input</span><span class="p">()</span>
<span class="nb">io.input</span><span class="p">(</span><span class="s2">"newInput"</span><span class="p">)</span>
<span class="c1">--对新的输入流进行操作</span>
<span class="nb">io.input</span><span class="p">():</span><span class="n">close</span>
<span class="nb">io.input</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>  <span class="c1">--恢复之前的输入流</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>注意：</strong> io.read(args) 实际上是io.input():read(args)，同样的io.write(args)和io.output():write(args)的简写。
io.lines() 函数可以带参数，filename,读取文档中的内容，不带参数就是从当前输入流中读，现在次函数还可以接收像read函数一样的参数。</p>

<h2 id="其他文档操作">其他文档操作</h2>
<p>io.tmpfile返回一个操作临时文档的句柄，该句柄是以读写模式打开的，当进程运行完成后，该句柄就会被回收。
函数flush将所有的缓冲数据写入到文档中。与函数write一样，我们也可以把它当作io.flush()使用，以刷新当前的输出流，或者f:flush()，用来刷新当前流。</p>

<p>函数setvbuf用于设置流的缓冲模式。</p>
<ol>
  <li>“no” 不缓冲</li>
  <li>“full” 缓冲区满或者显示刷新文档时才写入数据</li>
  <li>“line” 遇到换行符或从特定文档中读到了数据</li>
</ol>

<p>对于后面两个模式，可以跟第二个参数来设置缓冲区大小。
一般情况下:io.stderr 是不缓冲的，io.stdout是按行缓冲的。</p>

<p>函数seek用来获取和设置文档当前位置。常使用f:seek(whence,offset)的形式来调用。whence有一下三种模式：</p>
<ol>
  <li>“set”  文档开头</li>
  <li>“cur”  文档当前位置</li>
  <li>“end”  文档结尾</li>
</ol>

<p>偏移是以字节为单位的。
whence默认值为”cur”,offset的默认值是0。file:seek() 返回当前位置且不改变当前位置。file:seek(“set”)会将位置重置到文档开头并返回0，file:seek(“end”)会将文档当前位置重置到文档结尾，并返回文档的大小。</p>

<p>os.rename改变文档名字 os.remove删除文档。</p>

<h2 id="其它系统调用">其它系统调用</h2>
<p>os.exit用于终止进程的执行。
os.getev用于获取环境变量。</p>

<p>os.execute用来运行系统命令，等价于c中的system。还用io.popen也是运行一条系统命令,但是该函数可以重定向命令的输入输出流。</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">function</span> <span class="nf">create</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
	<span class="nb">os.execute</span><span class="p">(</span><span class="s2">"mkdir "</span><span class="o">...</span><span class="n">dirname</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">io.popen</span><span class="p">(</span><span class="s2">"dir /B"</span><span class="p">,</span><span class="s2">"r"</span><span class="p">)</span> <span class="c1">-- 只读</span>
<span class="kd">local</span> <span class="n">dir</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">f</span><span class="p">:</span><span class="n">lines</span><span class="p">()</span> <span class="k">do</span>
	<span class="n">dir</span><span class="p">[</span><span class="o">#</span><span class="n">dir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div></div>



                
                
                <hr style="visibility: hidden;">