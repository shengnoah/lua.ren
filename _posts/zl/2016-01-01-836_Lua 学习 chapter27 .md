---
layout: post
title: Lua 学习 chapter27  
tags: [lua文章]
categories: [topic]
---
<h3 id="目录">目录</h3>
<ol>
  <li>前言</li>
  <li>第一个示例</li>
  <li>lua堆栈操作</li>
  <li>处理应用代码中的错误</li>
  <li>内存分配</li>
</ol>

<blockquote>
  <p>只有疯狂过，你才知道自己究竟能不能成功。</p>
</blockquote>

<h2 id="前言">前言</h2>

<p>lua是一种嵌入式语言，这就意味着lua并不是一个独立运行的应用，而是一个库，它可以链接到其它应用程序，将lua的功能融入到这些应用。</p>

<p>由于lua存在解释器（可执行的lua），所以我们可以独立的使用它，这个解释器是由lua标准库实现的独立解释器，它负责与用户交互，将用户的文件和字符串传递给lua标准库，由标准库完成主要工作。</p>

<p>因为能被当作ku来扩展某个应用程序，所以lua是一个嵌入式语言。同时，使用了lua语言的程序也可以在lua环境中注册新的函数，比如用c语言实现的函数，从而增加一些无法直接用lua语言编写的功能，因此lua也是一种可扩展的语言。</p>

<p>上述的两种对lua语言的定位，分别对应c语言和lua语言之间的两种交互方式。在第一种形式中，c语言拥有控制权，而lua语言被用作库，这种交互形式中c代码被称为应用代码。在第二种中，lua语言拥有控制权，而c语言被用作库，因此c代码被称为库代码。应用代码和库代码都是用相同的API与lua语言通信，这些API被称为C API。</p>

<p>C API是一个函数、常量和类型组成的集合，有了它，c语言代码就能与lua语言交互。C API包括读写lua全局变量的函数、调用lua函数的函数、运行lua代码段的函数以及注册c函数(以便于其后可被lua代码调用）的函数等。通过调用C API，C代码几乎可以做lua代码能够做的所有事情。</p>

<p>C API遵循C语言的操作模式，与lua模式有很大的区别。所以在c的时候可能会抛弃易用性，但是在效率上，c代码可能会高一些。</p>

<h2 id="第一个示例">第一个示例</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="cp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
</span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
<span class="cp">#include &lt;lua.h&gt;
#include &lt;lauxlib.h&gt;
#include &lt;lualib.h&gt;
</span><span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span> <span class="o">=</span> <span class="n">luaL_newstate</span><span class="p">();</span><span class="c1">//打开lua</span>
	<span class="n">luaL_openlibs</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="c1">//打开标准库</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">luaL_loadstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">buff</span><span class="p">)</span> <span class="o">||</span> <span class="n">lua_pcall</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s</span><span class="se">n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
			<span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//从栈中弹出错误信息</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">lua_close</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">--</span> <span class="err">测试输入</span>
<span class="n">qewqr</span>
<span class="p">[</span><span class="n">string</span> <span class="s">&#34;qewqr...&#34;</span><span class="p">]</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span> <span class="n">syntax</span> <span class="n">error</span> <span class="n">near</span> <span class="o">&lt;</span><span class="n">eof</span><span class="o">&gt;</span>
<span class="n">print</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="n">hello</span>
<span class="n">local</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">t</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">[</span><span class="n">string</span> <span class="s">&#34;t.a = 5...&#34;</span><span class="p">]</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span> <span class="n">attempt</span> <span class="n">to</span> <span class="n">index</span> <span class="n">a</span> <span class="n">nil</span> <span class="n">value</span> <span class="p">(</span><span class="n">global</span> <span class="sc">&#39;t&#39;</span><span class="p">)</span>
<span class="n">t</span><span class="o">=</span> <span class="p">{}</span>
<span class="n">t</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">a</span><span class="p">)</span>
<span class="mi">5</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>接下来我们来熟悉一下各种头文件的提供了那些函数，其中头文件lua.h声明了lua提供的基础函数，其中包括创建新的lua环境的函数，调用lua函数的函数、读写环境中的全局变量的函数，以及注册供lua语言调用的新函数的函数。lua.h中声明的所有的内容都有一个前缀lua_(eg:lua_pcall).</p>

<p>头文件lauxlib.h声明了辅助库(auxiliary library, auxlib)所提供的的函数，其中所有的声明均以luaL_开头（eg:luaL_loadstring)。辅助库使用lua.h提供的基础API来提供更高层次的抽象，特别是对标准库用到的相关机制进行抽象。</p>

<p>lua标准库没有定义任何c语言全局变量，它将所有的状态都保存在动态的结构体lua_State中，lua中的所有函数都接收一个纸箱该结构的指针作为参数。这种设计使得lua是可重入的，并且可以直接用于编写所线程代码。</p>

<p>函数luaL_newstate用于创建一个新的lua状态。当它创建一个新的状态时，新的环境中没有包含预定一个的函数，甚至连print都没有。为了保持lua语言的精炼，所有的标准库都被组织成不同的包，这样我们在不需要使用某些包的时候可以忽略它们。头文件lualib.h中声明了用于打开这些库的函数。函数luaL_openlibs用于打开所有的标准库。</p>

<p>当创建好一个状态并在其中加载了标准库之后，就可以处理用户的输入了。程序会首先调用函数luaL_loadstring来编译用户输入的每一行内容。如果没有错误，则返回零，并向栈中压入编译后得到的函数。然后，程序调用函数lua_pcall从栈中弹出编译后的函数，并以保护模式运行。如果没有发生错误，pcall一样返回零，如果发生错误，这两个函数都会像栈中压入一条错误信息。然后我们可以通过lua_tostring来获取错误信息。</p>

<p>在其中有一个lua_pop函数，该函数表示从当前lua状态栈中弹出几个元素，如lua_pop( pLua, 2 )表示从栈顶弹出2个元素，当第二个参数填入-1时弹出所有元素即lua_pop( pLua, -1 ).</p>

<h2 id="lua堆栈操作">lua堆栈操作</h2>

<p>lua和c之间的通信主要组件是无处不在的虚拟栈，几乎所有的API调用都是在操作这个栈中的值，lua与c之间的所有数据交换都是通过这个栈完成的。此外，还可以利用栈保存中的结果。</p>

<p>在对lua栈操作的时候，当循环向栈中压入元素的时候，需要调用函数lua_checkstack来检查栈中是否有足够的空间。</p>

<p>C API提供了一系列lua_is*的函数，其中*可以是任意一种lua数据类型。这些函数包括lua_isnil,lua_isnumber,lua_isstring和lua_istable.lua_type返回栈中元素的类型，包含：LUA_TSTRING，LUA_TBOOLEAN，LUA_TNUMBER，LUA_TSTRING等。</p>

<p>针对于lua堆栈的操作。</p>

<p>C API使用索引（index）来引用栈中的元素。。第一个被压如栈的元素索引为1，第二个被压入的元素索引为2，-1表示栈顶元素，-2表示在它之前被压入栈的元素。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">stackDump</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">lua_gettop</span><span class="p">(</span><span class="n">L</span><span class="p">);</span> <span class="c1">//栈深度</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">top</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">lua_type</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">case</span> <span class="n">LUA_TSTRING</span><span class="p">:</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">LUA_TBOOLEAN</span><span class="p">:</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="n">lua_toboolean</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="s">&#34;true&#34;</span> <span class="o">:</span> <span class="s">&#34;false&#34;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">LUA_TNUMBER</span><span class="p">:</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%g&#34;</span><span class="p">,</span> <span class="n">lua_tonumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">lua_typename</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">t</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span> <span class="o">=</span> <span class="n">luaL_newstate</span><span class="p">();</span>

	<span class="n">lua_pushboolean</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">lua_pushnumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">lua_pushnil</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
	<span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">);</span>
	<span class="n">stackDump</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="c1">//true 10 nil hello</span>
	<span class="n">lua_pushvalue</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">);</span><span class="c1">//将指定索引的值压到栈顶</span>
	<span class="n">stackDump</span><span class="p">(</span><span class="n">L</span><span class="p">);</span> <span class="c1">//true 10 nil hello true</span>
	<span class="n">lua_replace</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span><span class="c1">//pop栈顶元素，并将pop的值设置到指定索引</span>
	<span class="n">stackDump</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="c1">// true 10 true hello</span>
	<span class="n">lua_settop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span><span class="c1">//设置栈中元素个数,0的话清空栈，大于原来个数补nil</span>
	<span class="n">stackDump</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="c1">//true 10 true hello nil nil</span>
	<span class="n">lua_rotate</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//将指定元素向栈顶转动n个位置，并把栈顶元素补充过来</span>
	<span class="n">stackDump</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="c1">//true 10 nil true hello nil</span>
	<span class="n">lua_remove</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span><span class="c1">//移除指定位置的值</span>
	<span class="n">stackDump</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="c1">//true 10 nil hello nil</span>
	<span class="n">lua_close</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="处理应用代码中的错误">处理应用代码中的错误</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">secure_foo</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
	<span class="n">lua_pushcfucntion</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">lua_pcall</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="内存分配">内存分配</h2>

<p>lua语言核心对内存不进行任何假设，它既不会调用malloc也不会调用realloc来分配内存。相反lua语言核心只会通过一个分配内存函数来分配和释放内存，当用户创建状态时必须提供函数。</p>

<p>luaL_newstate是一个默认分配函数创建Lua状态的辅助函数。该默认分配函数使用了c语言标准库的标准函数malloc-realloc-freee，对于大多数程序来岁，这几个函数够用了。但是要完全控制lua的内存分配也很容易，使用原始的lua_newstate来创建我们自己的lua状态即可。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">lua_State</span> <span class="o">*</span><span class="nf">lua_newstate</span><span class="p">(</span><span class="n">lua_Alloc</span> <span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ud</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>该函数有两个参数：一个是分配函数，另一个是用户数据。用这种方式创建的lua状态会通过调用f完成所有的内存分配和释放，甚至结构lua_State也是由f分配的。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">lua_Alloc</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ud</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">osize</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">nsize</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>第一个参数始终为lua_newstate所提供的的用户数据；第二个参数正是被(重)分配或者释放的块的地址；第三个参数是原始块的大小；最后一个参数请求块大小。如果ptr不是NULL，lua会保证其之前分配的大小就是osize(如果是NULL，那么这个块之前的大小肯定是零，所以lua使用osize来存放某些调试信息）。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="nf">l_alloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ud</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">osize</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">nsize</span><span class="p">){</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ud</span><span class="p">;(</span><span class="kt">void</span><span class="p">)</span><span class="n">osize</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nsize</span> <span class="o">==</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">nsize</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>


                <hr style="visibility: hidden;"/>
                
                <hr style="visibility: hidden;"/>