---
layout: post
title: cocos2dx lua 安全之加密与解密实现 
tags: [lua文章]
categories: [topic]
---

    非常多使用cocos2dx+lua做游戏的同学。都会想到一个问题，我的游戏一旦公布，如何才干保证的我脚本代码不被破解。不泄露代码。尽管这和开源、共享的原则不合。可是代码也是coder的劳动成果，理应得到保护。
    

特别是商业游戏更是如此，不希望被别人破解掉源代码而且进行改动。

今天的话题就是怎样实现lua脚本文件的加密和解密。

我在网络上查过，都没有成熟的解决方式。然后我经过考虑之后，总结出两种解决方式，供大家參考。

  * 1、轻量级的解决方式。APK打包之前，用工具把全部的lua文件加密，详细是将lua文件读到内存，然后使用zip等压缩加密库进行压缩加密，然后将压缩加密之后的数据保存为和源文件同名的文件。

    * 打包之后执行lua文件的时候。则先读出lua数据。然后进行解密。将解密后的流数据传给lua虚拟机。
  * 2、重量级的解决方式，此方案是上一种方案的扩展。也是商用游戏的方案，实现一个游戏文件包，打包前将资源和脚本都使用工具打包到一个文件。能够在打包的时候加密压缩，也能够不加密压缩。

    * 然后在执行的时候直接从包内读出对应文件的数据。然后解密解压缩。然后提供给游戏引擎使用。这也是端游普遍使用的技术，手游眼下大部分也開始使用此技术。

本文主要简要解说第一种方案，另外一种方案则有时间再写一篇博客。好了。我们開始进入正题吧。

首先是压缩lua文件。代码例如以下：

    
    
    int write_file_content(const char* folder)
    {
        //获得文件数据，并压缩文件
        FILE* fpin = fopen(folder, "wb+");
        if (fpin == NULL)
        {
            printf("无法读取文件: %sn", folder);
            return 0;
        }
    
        //得到文件大小
        fseek(fpin, 0, SEEK_END);
        unsigned int size = ftell(fpin);
    
        //读出文件内容
        fseek(fpin, 0, SEEK_SET);
        void* con = malloc(size);
        int r = fread(con, size, 1, fpin);    
    
        //进行加密操作
        unsigned long zip_con_size = size * 2;
        void* zip_con = malloc(zip_con_size);
        if (Z_OK != compress((Bytef*)zip_con, &zip_con_size, (Bytef*)con, size)) 
        {
            printf("压缩 %s 时错误发生n",folder);
        }
        printf("%s 压缩前大小：%ld 压缩后大小：%ldn", folder,  size,  zip_con_size);
    
        //写文件内容
        fseek(fpin, 0, SEEK_SET);
        int len = fwrite(zip_con, zip_con_size, 1, fpin);
    
        //释放资源
        fclose(fpin);
        free(zip_con);
        free(con);    
        return 0;
    }
    

然后是解密操作。代码例如以下：

    
    
    void* read_file_content(const char* folder, int& bufflen)
    {
        FILE* file = fopen(folder, "wb+");
        if (file)
        {    
        {
            printf("无法读取文件: %sn", folder);
            return 0;
        }
    
        //获取文件大小
        fseek(file, 0, SEEK_END);
        unsigned int size = ftell(file);
    
        //读出文件内容
        void* con = malloc(size);
        fseek(file, 0, SEEK_SET);
        int len = fread(con, size, 1, file);
    
        //解压缩操作
        unsigned long zip_size = size * 4;
        void* zip_con = malloc(zip_size);
        int code = uncompress((Bytef*)zip_con, &zip_size, (Bytef*)con, size);
        if (Z_OK != code)
        {
            printf("解压 %s 时错误发生 :%dn", folder, code);
            return 0;
        }
    
        //释放资源
        fclose(file);
        free(con);
    
        //zip_con由外部释放
        bufflen = zip_size;
        return zip_con。
    }
    

最后就把此流文件塞给lua的虚拟机就可以，即以流方式执行lua代码。

> 当然更高级一点的方法是直接改写lua的文件载入策略