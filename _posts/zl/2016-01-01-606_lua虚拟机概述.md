---
layout: post
title: lua虚拟机概述 
tags: [lua文章]
categories: [topic]
---
<h4 id="何为虚拟机"><a href="#何为虚拟机" class="headerlink" title="何为虚拟机"></a>何为虚拟机</h4><p>用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode(”操作码”),可以理解为这门程序自己定义的”汇编语言”.一般的编译型语言,比如C等,经过编译器编译之后生成的都是与当前硬件环境相匹配的汇编代码;而脚本型的语言,经过前端的处理之后,生成的就是opcode,再将该opcode放在这门语言的虚拟机中执行.虚拟机是作为单独的程序独立存在,而Lua由于是一门嵌入式的语言是附着在宿主环境中的.   </p>
<h3 id="lua代码到虚拟机执行的流程"><a href="#lua代码到虚拟机执行的流程" class="headerlink" title="lua代码到虚拟机执行的流程"></a>lua代码到虚拟机执行的流程</h3><p><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215140547779-1286988518.png" alt=""/></p>
<p>在Lua中,Lua代码从词法分析到语法分析再到生成opcode,最后进入虚拟机执行的大体流程是什么样子的呢？</p>
<p>Lua的API中提供了luaL_dofile函数,它实际上是个宏,内部首先调用luaL_loadfile函数,加载Lua代码进行语法,词法分析,生成Lua虚拟机可执行的代码,再调用lua_pcall函数,执行其中的代码:</p>
<pre><code>    #define luaL_dofile(L, fn) 
        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
</code></pre><p>前半部分调用luaL_loadfile函数对Lua代码进行词法和语法分析,后半部分调用lua_pcall将第一步中分析的结果(也就是opcode)到虚拟机中执行.</p>
<p>首先来看luaL_loadfile函数,暂时不深入其中研究它如何分析一个Lua代码文件,先看它最后输出了什么.它最终会调用f_parser函数,这是对一个Lua代码进行分析的入口函数:</p>
<pre><code>    static void f_parser (lua_State *L, void *ud) {
      int i;
      Proto *tf;
      Closure *cl;
      struct SParser *p = cast(struct SParser *, ud);
      int c = luaZ_lookahead(p-&gt;z);
      luaC_checkGC(L);
      tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,
                                                                 &amp;p-&gt;buff, p-&gt;name);
      cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));
      cl-&gt;l.p = tf;
      for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */
        cl-&gt;l.upvals[i] = luaF_newupval(L);
      setclvalue(L, L-&gt;top, cl);
      incr_top(L);
    }
</code></pre><p>在完成词法分析之后,返回了Proto类型的指针tf,然后将其绑定在新创建的Closure指针上,初始化UpValue,最后压入Lua栈中.</p>
<p>不难想像,Lua词法分析之后产生的opcode等相关数据都在这个Proto类型的结构体中.</p>
<p>再来看lua_pcall函数是如何将产生的opcode放入虚拟机执行的.</p>
<p>lua_pcall函数中,首先获取需要调用的函数指针:</p>
<pre><code>    c.func = L-&gt;top - (nargs+1);  /* function to be called */
</code></pre><p>这里的nargs是由函数参数传入的,luaL_dofile中调用lua_pcall时这里传入的参数是0,换句话说,这里得到的函数对象指针就是在f_parser函数中最后放入Lua栈的指针.</p>
<p>继续往下执行,走到luaD_call函数,有这一段代码:</p>
<pre><code>
      if (luaD_precall(L, func, nResults) == PCRLUA)  /* is a Lua function? */
        luaV_execute(L, 1);  /* call it */
</code></pre><p>进入luaV_execute函数,这里是虚拟机执行代码的主函数:</p>
<pre><code>
    void luaV_execute (lua_State *L, int nexeccalls) {
      LClosure *cl;
      StkId base;
      TValue *k;
      const Instruction *pc;
     reentry:  /* entry point */
      lua_assert(isLua(L-&gt;ci));
      pc = L-&gt;savedpc;
      cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;
      base = L-&gt;base;
      k = cl-&gt;p-&gt;k;
      /* main loop of interpreter */
      for (;;) {
        const Instruction i = *pc++;
        StkId ra;
        if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;
            (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {
          traceexec(L, pc);
          if (L-&gt;status == LUA_YIELD) {  /* did hook yield? */
            L-&gt;savedpc = pc - 1;
            return;
          }
          base = L-&gt;base;
        }
        /* warning!! several calls may realloc the stack and invalidate `ra&#39; */
        ra = RA(i);
    // 以下是各种opcode的情况处理
    }
</code></pre><p>可以看到,这里的pc指针里存放的是虚拟机opcode代码,它最开始从L-&gt;savepc初始化而来,而L-&gt;savepc在luaD_precall中赋值:</p>
<pre><code>    L-&gt;savedpc = p-&gt;code;  /* starting point */
</code></pre><p>这里的p就是第一步f_parser中返回的Proto指针.</p>
<p>回顾一下整个流程:</p>
<ol>
<li><p>函数f_parser中,对Lua代码文件的分析返回了Proto指针</p>
</li>
<li><p>函数luaD_precall中,将Lua_state的savepc指针指向1中的Proto结构体的code指针</p>
</li>
<li><p>函数luaV_execute中,pc指针指向2中的savepc指针,紧跟着就是一个大的循环体,依次取出其中的opcode进行执行.<br/><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215141251439-1865045097.png" alt=""/></p>
</li>
</ol>