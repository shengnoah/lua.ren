---
layout: post
title: Lua知识回顾 
tags: [lua文章]
categories: [topic]
---
<p>学习 Lua 编程语言的比较</p>

<p>无聊之余，想要找个东西来打发时间和排解心中的百无聊赖，于是乎，想要重新玩一下 corona 这个游戏开发引擎。当然，第一步就是重温下以前学过的 lua 编程语言，这次我打算在 Windows 操作系统上摆弄下这玩意。</p>
<p>首先进入<a href="http://www.lua.org/" target="_blank" rel="noopener noreferrer">lua 官网</a>找到二进制文件的下载地址，下载好了之后，解压后先把文件夹里的<code>luax.ext</code>(x 代表版本号)文件修改为<code>lua.exe</code>，然后将该目录添加到 Path 系统变量中，在终端输入<code>lua -v</code>检查是否配置完成。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>调用函数时，被调用的函数一定要在调用者之前定义</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量的作用域：</p>
<ul>
<li>全局变量：除非显式声明为 local，其它所有变量都是全局变量；</li>
<li>本地变量：使用 local 来声明变量</li>
<li>表(table)变量:特殊类型的变量，值不可以为 nil</li>
</ul>
<p>容易混淆的例子：</p>
<pre><code>local a, b = 1, 2 --该写法正确
local a = 1, b = 2 --该写法错误
</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Lua 是动态类型语言，变量没有类型，只有值有类型，下面是数据类型：</p>
<ul>
<li>nil</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>function</li>
<li>userData</li>
<li>thread</li>
<li>table</li>
</ul>
<p><code>type</code>函数用来计算变量的数据类型。所有的变量除非赋值，不然都是指向<code>nil</code>。</p>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><ul>
<li><code>A^n</code>表示 A 的 n 次方</li>
<li><code>~=</code>表示不等于的操作符</li>
<li><code>A and B</code>：A 为真，返回 B；A 为假，返回 A</li>
<li><code>A or B</code>：A 为真，返回 A；A 为假，返回 B</li>
<li><code>!A</code>：A 为真，返回假；A 为假，返回真</li>
<li><code>..</code>：连接字符串</li>
<li><code>#</code>：返回字符串或表的长度</li>
</ul>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>while 循环：</p>
<pre><code>local i = 20
while(i &gt; 0)
do
    print(i)
    i = i - 1
end
</code></pre><p>for 循环：</p>
<pre><code>for i = 10, 1, -1
do
    print(i)
end
-- for 初始值,最大/小值,步长
</code></pre><p>repeat…until 循环</p>
<pre><code>local a = 10
repeat
    print(a)
    a = a - 1
until(a &lt; 1)
</code></pre><h4 id="条件控制语句"><a href="#条件控制语句" class="headerlink" title="条件控制语句"></a>条件控制语句</h4><p>条件为 false 的情况只有值为 false 或 nil 时成立，0 被认为是 true。</p>
<pre><code>if nil then
    print(&#34; nil is true&#34;)
else
    print(&#34;nil is false&#34;)
end
</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 Lua 中，可以将函数赋值给变量，也可以将函数作为其它函数的参数传递。</p>
<p>使用<code>...</code>作为参数可以创建参数数量可变的函数：</p>
<pre><code>function average(...)
    result = 0
    local arg = {...}
    for i, v in ipairs(arg) do
        result = result + v
    end
    return result / #arg
end
</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串创建的方法：</p>
<ul>
<li><code>&#39;&#39;</code>：单引号</li>
<li><code>&#34; &#34;</code>：双引号</li>
<li><code>[[ ]]</code></li>
</ul>
<p>字符串方法的调用形式：<code>string.methodName(params)</code></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是用索引为数字的表来实现的，索引从 1 开始，如果索引不存在，则返回 nil。</p>
<pre><code>arr = {&#34;A&#34;, &#34;B&#34;, &#34;C&#34;}

for i = 0, 3 do
    print(arr[i])
end

-- nil A B C
</code></pre><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器(Iterator)可以遍历集合或容器中的元素，而在 Lua 中，集合一般指的是表。</p>
<pre><code>arr = {&#34;A&#34;, &#34;B&#34;}
for key, value in ipairs(arr)
do
    print(key, &#34; = &#34;, value)
end
</code></pre><p>在 Lua 中，使用函数来实现迭代器，有两种类型的迭代器：</p>
<ul>
<li>无状态</li>
<li>有状态</li>
</ul>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>表使用<code>{}</code>来表示</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>模块可以使用 require 来加载，模块由一系列函数和变量组成，所有这些函数和变量包含在表中。</p>
<p>模块名和文件名要相同。</p>
<pre><code>-- mymath.lua定义了模块
local mymath = {}
function mymath.add(a, b)
    print(a + b)
end
return mymath

-- app.lua
mymathmodule = require(&#34;mymyth&#34;)
mymathmodule.add(1, 2)
</code></pre><h4 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h4><p>附着在表上的元表(metatable)会修改表的行为。</p>
<ul>
<li><code>setmetatable(table, metatable)</code>：设置表的元表</li>
<li><code>getmetatable(table)</code>:获取表的元表</li>
</ul>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul>
<li><code>coroutine.create(f)</code>：创建新的协程</li>
<li><code>coroutine.resume(co [, val1, ...])</code>：继续执行协程，可以传递参数。该调用会返回操作的状态，和一些可选的返回值</li>
<li><code>coroutine.yield(...)</code>：停止协程的执行，传递给该方法的参数会作为 resume 方法的返回值。</li>
</ul>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4>