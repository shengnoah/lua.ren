---
layout: post
title: Lua程序设计（4） 
tags: [lua文章]
categories: [topic]
---
<p>Lua的输入输出、补充知识</p>

<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>单就Lua语言而言，只提供了ISO C语言标准支持的功能，即基本的文件操作等。</p>
<h4 id="简单I-O模型"><a href="#简单I-O模型" class="headerlink" title="简单I/O模型"></a>简单I/O模型</h4><p>简单模型虚拟了一个当前输入流和一个当前输出流。函数<code>io.input</code>和函数<code>io.output</code>可以用于改变当前的输入输出流，调用<code>io.input</code>会以只读模式打开指定文件，并将文件设置为当前输入流。之后所有的输入都将来自该文件，除非再次调用<code>io.input</code>。</p>
<h5 id="io-write"><a href="#io-write" class="headerlink" title="io.write"></a>io.write</h5><p>函数<code>io.write</code>可以读取任意数量的字符串并将其写入当前输入流。由于调用函数时可以使用多个参数，因此应尽量避免使用连接操作符以节省资源。</p>
<p>作为原则，应该只在”用后即弃”的代码中使用函数print，当需要完全控制输出时，应该使用函数io.write。</p>
<h5 id="io-read"><a href="#io-read" class="headerlink" title="io.read"></a>io.read</h5><table>
<thead>
<tr>
<th>参数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>“a”</td>
<td>读取整个文件</td>
</tr>
<tr>
<td>“l”</td>
<td>读取下一行（丢弃换行符）</td>
</tr>
<tr>
<td>“L”</td>
<td>读取下一行（保留换行符）</td>
</tr>
<tr>
<td>“n”</td>
<td>读取一个数值</td>
</tr>
<tr>
<td>Num</td>
<td>以字符串读取num个字符</td>
</tr>
</tbody>
</table>
<p>调用<code>io.read(&#34;a&#34;)</code>可从当前位置开始读取当前输入文件的全部内容，如果当前处于文件末尾或者文件为空，那么该函数返回一个空字符串。</p>
<h4 id="完整I-O模型"><a href="#完整I-O模型" class="headerlink" title="完整I/O模型"></a>完整I/O模型</h4><p>可以使用函数<code>io.open</code>来打开一个文件，这个函数有两个参数，一个参数是待打开文件的文件名，另一个参数是一个模式字符串，包括表示只读的r，表示只写的w，表示追加的a，以及一个可选的表示打开二进制文件的b。</p>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="局部变量和代码块"><a href="#局部变量和代码块" class="headerlink" title="局部变量和代码块"></a>局部变量和代码块</h4><p>Lua中的变量在默认情况下是全局变量，所有的局部变量在使用前必须声明。</p>
<ul>
<li>局部变量可以避免由于不必要的命名而造成全局变量的混乱。</li>
<li>局部变量还能避免同一程序中不同代码部分的命名冲突</li>
<li>访问局部变量比访问全局变量更快</li>
<li>局部变量会随着其作用域的结束而消失，使得垃圾收集器能够将其释放</li>
</ul>
<h4 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h4><ul>
<li><p>if then else</p>
</li>
<li><p>elseif</p>
</li>
<li><p>while</p>
</li>
<li><p>repeat-until：类似于do-while</p>
</li>
<li><p>数值型for：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var = exp1,exp2,exp3 <span class="keyword">do</span></span><br/><span class="line">	something</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>var值从exp1变化到exp2之前的每次循环会执行something，并在每次循环结束后将步长exp3增加到var上，如果exp3不存在则默认为1，不想设置循环上限，可以使用math.huge。</p>
</li>
<li><p>泛型for：</p>
<p>泛型for遍历迭代函数返回的所有值，例如<code>pairs</code>、<code>ipairs</code>、<code>io.lines</code>等。</p>
</li>
<li><p>break、return、goto：标签形如<code>::name::</code></p>
</li>
</ul>