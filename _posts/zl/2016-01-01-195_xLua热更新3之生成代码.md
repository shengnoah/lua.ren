---
layout: post
title: xLua热更新3之生成代码 
tags: [lua文章]
categories: [topic]
---


      
      

      
        <p>思考并回答以下问题：<br>1.如何创建一个空表？</p>


<p>之前提到了生成代码的问题，是不是对这个概念很陌生？生成代码从广义上来说就是通过进程来生成代码。在xLua中也是如此，下面来看看在xLua中具体是什么。</p>
<h2 id="什么是生成代码？"><a href="https://chebincarl.github.io/#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%9F" class="headerlink" title="什么是生成代码？"></a><span style="color:#EF7060;">什么是生成代码？</span></h2><p>生成代码是xLua支持的lua和C#间交互技术之一，这种技术通过生成两者间的适配代码来实现交互，性能较好，是<span style="color:red"> 推荐的方式</span>。xLua可以自动生成配置好的代码，后面会有介绍。</p>
<p>另一种交互技术是反射，这种方式对安装包的影响更少，可以在性能要求不高或者对安装包大小很敏感的场景下使用。</p>
<h2 id="应该什么时候生成代码？"><a href="https://chebincarl.github.io/#%E5%BA%94%E8%AF%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%9F" class="headerlink" title="应该什么时候生成代码？"></a><span style="color:#EF7060;">应该什么时候生成代码？</span></h2><p>开发期不建议生成代码，可以避免很多由于不一致导致的编译失败，以及生成代码本身的编译等待。</p>
<p>发布手机版本前必须执行生成代码，建议做成自动化的流程。</p>
<p>做性能调优，性能测试前必须执行生成代码，因为生成和不生成性能的区别还是很大的。</p>
<h2 id="如何生成代码？"><a href="https://chebincarl.github.io/#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%9F" class="headerlink" title="如何生成代码？"></a><span style="color:#EF7060;">如何生成代码？</span></h2><p>生成代码的过程是自动化的，xLua提供了相关的脚本进行生成。</p>
<p>入口是下图的菜单栏：</p>
<img src="https://chebincarl.github.io/2019/06/24/xLua%E7%83%AD%E6%9B%B4%E6%96%B03%E4%B9%8B%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/1.png">

<p>但是xLua需要首先知道生成哪些代码，这就涉及到xLua的配置了。</p>
<h2 id="xLua的配置"><a href="https://chebincarl.github.io/#xLua%E7%9A%84%E9%85%8D%E7%BD%AE" class="headerlink" title="xLua的配置"></a><span style="color:#EF7060;">xLua的配置</span></h2><p>xLua所有的配置都支持三种方式：打标签；静态列表；动态列表。</p>
<p>配置有两必须两建议：</p>
<ul>
<li>列表方式均必须是static的字段/属性</li>
<li>列表方式均必须放到一个static类</li>
<li>建议不用标签方式</li>
<li>建议列表方式配置放Editor目录（如果是Hotfix配置【后面会讲】，而且类位于Assembly-CSharp.dll之外的其它dll，必须放Editor目录）</li>
</ul>
<p>** 打标签 **</p>
<p>xLua用白名单来指明生成哪些代码，而白名单通过attribute来配置，比如你想从lua调用c#的某个类，希望生成适配代码，你可以为这个类型打一个LuaCallCSharp标签：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> </span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><span style="color:red">该方式方便，但在il2cpp下会增加不少的代码量，不建议使用。</span></p>
<p>** 静态列表 **</p>
<p>有时我们无法直接给一个类型打标签，比如系统API，没源码的库，或者实例化的泛化类型，这时你可以在一个静态类里声明一个静态字段，该字段的类型除BlackList和AdditionalProperties之外只要实现了IEnumerable就可以了（这两个例外后面具体会说），然后为这字段加上标签：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Type&gt; mymodule_lua_call_cs_list = <span class="keyword">new</span> List&lt;Type&gt;()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">typeof</span>(GameObject),</span><br><span class="line">    <span class="keyword">typeof</span>(Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;),</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>这个字段需要放到一个<span style="color:red">静态类</span>里头，建议放到<span style="color:red">Editor</span>目录 。</p>
<p>** 动态列表 **</p>
<p>声明一个静态属性，打上相应的[Hotfix]标签即可。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Hotfix</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Type&gt; by_property</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">from</span> type <span class="keyword">in</span> Assembly.Load(<span class="string">"Assembly-CSharp"</span>).GetTypes()</span><br><span class="line">                <span class="keyword">where</span> type.Namespace == <span class="string">"XXXX"</span></span><br><span class="line">                <span class="keyword">select</span> type).ToList();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>Getter是代码，你可以实现很多效果，比如按名字空间配置，按进程集配置等等。</p>
<p>这个属性需要放到一个<span style="color:red">静态类</span>里头，建议放到<span style="color:red">Editor</span>目录 。</p>
<h2 id="配置Attribute"><a href="https://chebincarl.github.io/#%E9%85%8D%E7%BD%AEAttribute" class="headerlink" title="配置Attribute"></a><span style="color:#EF7060;">配置Attribute</span></h2><p>** XLua.LuaCallCSharp **</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">LuaCallCSharp</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> </span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>一个C#类型加了这个配置，xLua会生成这个类型的适配代码（包括构造该类型实例，访问其成员属性、方法，静态属性、方法），否则将会尝试用性能较低的反射方式来访问。</p>
<p>一个类型的扩展方法（Extension Methods）加了这配置，也会生成适配代码并追加到被扩展类型的成员方法上。</p>
<p>xLua只会生成加了该配置的类型，不会自动生成其父类的适配代码，当访问子类对象的父类方法，如果该父类加了LuaCallCSharp配置，则执行父类的适配代码，否则会尝试用反射来访问。</p>
<p>反射访问除了性能不佳之外，在il2cpp下还有可能因为代码剪裁而导致无法访问，后者可以通过下面介绍的ReflectionUse标签来避免。</p>
<h2 id="XLua-ReflectionUse"><a href="https://chebincarl.github.io/#XLua-ReflectionUse" class="headerlink" title="XLua.ReflectionUse"></a><span style="color:#EF7060;">XLua.ReflectionUse</span></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ReflectionUse</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>一个C#类型类型加了这个配置，xLua会生成link.xml阻止il2cpp的代码剪裁。</p>
<p>对于扩展方法，必须加上LuaCallCSharp或者ReflectionUse才可以被访问到。</p>
<p>建议所有要在Lua访问的类型，要么加LuaCallCSharp，要么加上ReflectionUse，这才能够保证在各平台都能正常运行。</p>
<h2 id="XLua-BlackList"><a href="https://chebincarl.github.io/#XLua-BlackList" class="headerlink" title="XLua.BlackList"></a><span style="color:#EF7060;">XLua.BlackList</span></h2><p>如果你不要生成一个类型的一些成员的适配代码，你可以通过这个配置来实现。</p>
<p>标签方式比较简单，对应的成员上加就可以了。</p>
<p>由于考虑到有可能需要把重载函数的其中一个重载列入黑名单，配置方式比较复杂，类型是List<list>，对于每个成员，在第一层List有一个条目，第二层List是个string的列表，第一个string是类型的全路径名，第二个string是成员名，如果成员是一个方法，还需要从第三个string开始，把其参数的类型全路径全列出来。</list></p>
<p>例如下面是对GameObject的一个属性以及FileInfo的一个方法列入黑名单：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">BlackList</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;<span class="keyword">string</span>&gt;&gt; BlackList = <span class="keyword">new</span> List&lt;List&lt;<span class="keyword">string</span>&gt;&gt;()  {</span><br><span class="line">    <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(){<span class="string">"UnityEngine.GameObject"</span>, <span class="string">"networkView"</span>},</span><br><span class="line">    <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(){<span class="string">"System.IO.FileInfo"</span>, <span class="string">"GetAccessControl"</span>, <span class="string">"System.Security.AccessControl.AccessControlSections"</span>},</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h2 id="XLua-DoNotGen"><a href="https://chebincarl.github.io/#XLua-DoNotGen" class="headerlink" title="XLua.DoNotGen"></a><span style="color:#EF7060;">XLua.DoNotGen</span></h2><p>指明一个类里的部分函数、字段、属性不生成代码，通过反射访问。</p>
<p>只能标注Dictionary&lt;type, list&gt;的field或者property。key指明的是生效的类，value是一个列表，配置的是不生成代码的函数、字段、属性的名字。</p>
<p>和ReflectionUse的区别是：</p>
<ul>
<li>ReflectionUse指明的是整个类；</li>
<li>当第一次访问一个函数（字段、属性）时，ReflectionUse会把整个类都wrap，而DoNotGen只wrap该函数（字段、属性），换句话DoNotGen更lazy一些；</li>
</ul>
<p>和BlackList的区别是：</p>
<ul>
<li>BlackList配了里面指定的类型就不能在lua中用了；</li>
<li>BlackList能指明某重载函数，DoNotGen不能。</li>
</ul>
<h2 id="XLua-CSharpCallLua"><a href="https://chebincarl.github.io/#XLua-CSharpCallLua" class="headerlink" title="XLua.CSharpCallLua"></a><span style="color:#EF7060;">XLua.CSharpCallLua</span></h2><p>如果希望把一个lua函数适配到一个C# delegate（一类是C#侧各种回调：UI事件，delegate参数，比如List:ForEach；另外一类场景是通过LuaTable的Get函数指明一个lua函数绑定到一个delegate）。或者把一个lua table适配到一个C# interface，该delegate或者interface需要加上该配置。</p>
<h2 id="XLua-GCOptimize"><a href="https://chebincarl.github.io/#XLua-GCOptimize" class="headerlink" title="XLua.GCOptimize"></a><span style="color:#EF7060;">XLua.GCOptimize</span></h2><p>一个C#纯值类型（注：指的是一个只包含值类型的struct，可以嵌套其它只包含值类型的struct）或者C#枚举值加上了这个配置。xLua会为该类型生成gc优化代码，效果是该值类型在lua和c#间传递不产生（C#）gc alloc，该类型的数组访问也不产生gc。</p>
<p>除枚举之外，包含无参构造函数的复杂类型，都会生成lua table到该类型，以及改类型的一维数组的转换代码，这将会优化这个转换的性能，包括更少的gc alloc。</p>
<h2 id="XLua-AdditionalProperties"><a href="https://chebincarl.github.io/#XLua-AdditionalProperties" class="headerlink" title="XLua.AdditionalProperties"></a><span style="color:#EF7060;">XLua.AdditionalProperties</span></h2><p>这个是GCOptimize的扩展配置，有的时候，一些struct喜欢把field写成私有的，通过property来访问field，这时就需要用到该配置（默认情况下GCOptimize只对public的field打解包）。</p>
<p>标签方式比较简单，配置方式复杂一点，要求是Dictionary&lt;type, list&gt;类型，Dictionary的Key是要生效的类型，Value是属性名列表。</p>
<h2 id="下面是生成期配置，必须放到Editor目录下"><a href="https://chebincarl.github.io/#%E4%B8%8B%E9%9D%A2%E6%98%AF%E7%94%9F%E6%88%90%E6%9C%9F%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%BF%85%E9%A1%BB%E6%94%BE%E5%88%B0Editor%E7%9B%AE%E5%BD%95%E4%B8%8B" class="headerlink" title="下面是生成期配置，必须放到Editor目录下"></a><span style="color:#EF7060;">下面是生成期配置，必须放到Editor目录下</span></h2><p>** CSObjectWrapEditor.GenPath **</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CSObjectWrapEditor.GenPath</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> Path = Application.streamingAssetsPath;</span><br></pre></td></tr></table></figure>

<p>配置生成代码的放置路径，类型是string。如果不配置默认生成在”Assets/XLua/Gen/“下。</p>
<p>** CSObjectWrapEditor.GenCodeMenu **</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CSObjectWrapEditor.GenCodeMenu</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"></span>)</span>{</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>该配置用于生成引擎的二次开发，一个无参数函数加了这个标签，在执行”XLua/Generate Code”菜单时会触发这个函数的调用。</p>
<h1 id="总结"><a href="https://chebincarl.github.io/#%E6%80%BB%E7%BB%93" class="headerlink" title="总结"></a>总结</h1><p>xLua也给出了一份常用的xLua的配置，可以在这个基础上根据自己的项目做修改。地址是：<a href="https://github.com/Tencent/xLua/blob/master/Assets/XLua/Editor/ExampleConfig.cs" target="_blank" rel="noopener noreferrer">https://github.com/Tencent/xLua/blob/master/Assets/XLua/Editor/ExampleConfig.cs</a></p>