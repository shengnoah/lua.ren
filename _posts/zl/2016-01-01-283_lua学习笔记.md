---
layout: post
title: lua学习笔记 
tags: [lua文章]
categories: [topic]
---

            <p><img src="https://lostplesed.github.io/images/lua.jpg" alt="img"></p>
<p>使用命令行参数-i来启动lua解释器，那么解释器就会在运行完指定的进程块后进入交互模式。</p>
<pre><code>test.lua
function foo( ... )
    -- body
    print("foo")
end

lua -i test.lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&gt; foo()
foo
</code></pre><p>另一种运行进程块的方式是使用函数dofile，该函数会立即执行一个文档。</p>
<p>行注释</p>
<pre><code>-- here
</code></pre><p>块注释</p>
<pre><code>--[[
here
here
--]]
</code></pre><h1 id="类型与值"><a href="https://lostplesed.github.io/#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC" class="headerlink" title="类型与值"></a>类型与值</h1><p>在lua中有8种基础类型：nil，boolean，number，string，userdata，function，thread，table</p>
<p>函数type可根据一个值返回其类型名称：</p>
<pre><code>print(type(type)) -- function
</code></pre><p>lua将值false和nil视为“假”，而除此之外的其他值视为“真”。</p>
<p>lua提供运行时的数字与字符串的自动转换。在一个字符串上应用算数操作时，lua会尝试将这个字符串转换成一个数字：</p>
<pre><code>print("10" + 1) -- 11
</code></pre><p>lua不仅在算数操作中会使用这种强制转换，还会在其他任何需要数字的地方这么做，反之亦然：</p>
<pre><code>print(10 .. 20) -- 1020
</code></pre><p>a.x和a[“x”]等价</p>
<h1 id="关系操作符"><a href="https://lostplesed.github.io/#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6" class="headerlink" title="关系操作符"></a>关系操作符</h1><p>操作符==和~=用来做相等测试，如果两个值具有不同的类型，lua就认为它们不相等。否则，lua会根据它们的类型来比较两者。对于table，userdata和函数，lua是作引用比较。</p>
<p>只能对两个数字或两个字符串作大小性比较。lua是按字母次序来比较字符串的，具体的字母次序取决于对lua的区域设置。</p>
<p>lua操作符优先级（从高到低）：</p>
<pre><code>^
not # -
* / %
+ -
..
&lt; &gt; &lt;= &gt;= ~= ==
and
or
</code></pre><p>在二元操作符中，除了指数操作符^和连接操作符..是右结合，所有其他操作符都是左结合。</p>
<pre><code>a + i &lt; b / 2 + 1    --         (a + i ) &lt; ((b / 2) + 1)
x ^ y ^ z                --        x ^ (y ^ z)
</code></pre><h1 id="语句"><a href="https://lostplesed.github.io/#%E8%AF%AD%E5%8F%A5" class="headerlink" title="语句"></a>语句</h1><p>lua允许多重赋值</p>
<pre><code>a, b = 10, 2
</code></pre><p>尽可能地使用局部变量是一种良好的编程风格，局部变量可以避免将一些无用的名称引入全局环境，避免扰乱了全局环境。此外，访问局部变量比访问全局变量更快，。最后一个局部变量通常会随着其作用域的结束而消失，这样便使垃圾收集器可以释放其值。</p>
<p>控制结构：</p>
<p>if-else-then:</p>
<pre><code>if cond then
    -- do
elseif cond1 then
    -- do1
else
    -- rest
end
</code></pre><p>while:</p>
<pre><code>while cond do
    -- do
end
</code></pre><p>repeat:</p>
<pre><code>repeat
    -- do
until cond
</code></pre><p>对于lua的repeat语句来说，一个声明在循环体中的局部变量的作用域包括了条件测试。</p>
<h1 id="函数"><a href="https://lostplesed.github.io/#%E5%87%BD%E6%95%B0" class="headerlink" title="函数"></a>函数</h1><p>调用函数无论哪种方法都需要将所有参数放到一对圆括号中。即使调用函数时没有参数，也必须写出一对空括号。对于此规则只有一种特殊的例外情况：一个函数若只有一个参数，并且此参数是一个字面字符串或者table构造式，那么圆括号便是可有可无的：</p>
<pre><code>print "hello world"
f{x = 10, y = 20}
</code></pre><p>lua函数可以返回多个值，如果一个函数没有返回值或者没有足够多的返回值，那么lua会用nil来补充缺失的值：</p>
<pre><code>function foo()
    return 1, 2
end

local a, b, c = foo()
print("a = " .. a .. " b = " .. b .. " c = " .. type(c)) -- a = 1 b = 2 c = nil
</code></pre><p>unpack函数接受一个数组作为参数，并从下标1开始返回该数组的所有元素：</p>
<pre><code>print(unpack{10, 20, 30}) -- 10 20 30
</code></pre><p>参数表中使用3个点（…）表示该函数可接受不同数量的实参，表达式“…”的行为类似于一个具有多重返回值的函数，它返回的是当前函数的所有变长参数。</p>
<p>在lua中，函数是第一类值，它们具有特定的词法域。“第一类值”表示在lua中函数与其它传统类型的值具有相同的权利。函数可以存储到变量或者table中，可以作为实参传递给其他函数，还可以作为其它函数的返回值。“词法域”是指一个函数可以嵌套在另外一个函数中，内部的函数可以访问外部函数中的变量。</p>
<p>一个closure就是一个函数加上该函数所需访问的所有“非局部的变量”。</p>
<pre><code>function newCounter()
    local i = 0
    return
    function()
        i = i + 1
        return i
    end
end

c1 = newCounter()
c2 = newCounter()
print(c1()) -- 1
print(c1()) -- 2
print(c2()) -- 1
</code></pre><p>上面这段代码中，匿名函数访问了一个“非局部变量”i，如果再次调用newCounter，那么它会创建一个新的局部变量i，从而也将得到一个新的closure。</p>
<p>可以使用同样的技术创建一个安全的运行环境，即所谓的“沙盒（sandbox）”。当执行一些未受信任的代码时就需要一个安全的执行环境，例如在服务器中执行那些从internet上接收到的代码。</p>
<pre><code>do
    local oldOpen = io.open
    local access_ok = function (filename, mode)
        --检查访问权限
    end

    io.open = function (filename, mode)
        if access_ok(filename, mode) then
            return oldOpen(filename, mode)
        else
            return nil, "access denied"
        end
    end
end
</code></pre><p>经过重新定义后，一个进程就只能通过新的受限版本来调用原来那个未受限的open函数了。</p>
<h1 id="表和面向对象"><a href="https://lostplesed.github.io/#%E8%A1%A8%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" class="headerlink" title="表和面向对象"></a>表和面向对象</h1><p>创建表</p>
<pre><code>t = {}
</code></pre><p>设置和访问表内容，不存在的表内容返回nil</p>
<pre><code>t["key] = 1
local value = t["key"]
</code></pre>