---
layout: post
title: 深度理解Lua中的table 
tags: [lua文章]
categories: [topic]
---
<p>Lua的table是个很有意思的东西。有些内容平时写代码的时候很少接触到，但是了解一下还是很有意思的。</p>

<p>这篇blog参考<a href="http://lua-users.org/wiki/MetatableEvents">MetatableEvents</a>，一个一个边写测试边细说。</p>

<h2 id="__newindex">__newindex</h2>

<p>原文翻译：</p>

<p><code class="highlighter-rouge">__newindex</code>用于分配属性，当调用 <code class="highlighter-rouge">myTable[key]=value</code>时，如果元表中有<code class="highlighter-rouge">__newindex</code>并且指向一个function，就会调用这个function，传入的参数为table, key 和 value</p>

<ul>
  <li>用 <code class="highlighter-rouge">rawset(myTable, key, value)</code>可以跳过这个元方法直接给myTable的key属性赋值为value。</li>
  <li>如果<code class="highlighter-rouge">__newindex</code>指向的方法中，没有调用<code class="highlighter-rouge">rawset</code>方法，传入的键值对（key/value）就不会添加到myTable中。</li>
</ul>

<p>测试代码：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {
    __newindex = function(t, key, value)
        print(&#34;call __newindex&#34;,t, key, value)
    end
}

local test = {}
setmetatable(test, meta)

print(&#34;test&#34;, test)
print(&#34;meta&#34;, meta)

test.name = &#34;t1&#34;
test.name = &#34;t2&#34;
print(&#34;test.name&#34;, test.name)

---- result output ----
test	table: 0x7f9c13406f00
meta	table: 0x7f9c13407240
call __newindex	table: 0x7f9c13406f00	name	t1
call __newindex	table: 0x7f9c13406f00	name	t2
test.name	nil
</code></pre></div></div>

<p>测试代码中，当给t的name的赋值时，就会触发元表中的__newindex指向的function，打印的信息可以看到key和value的值。</p>

<p><code class="highlighter-rouge">__newindex</code>方法中传进来的参数<code class="highlighter-rouge">t</code>的指针和<code class="highlighter-rouge">test</code>的指针指向同一个地址，说明<code class="highlighter-rouge">__newindex</code>中的参数<code class="highlighter-rouge">t</code>，并不是元表。</p>

<p>测试代码中对t.name连续赋值时，<code class="highlighter-rouge">__newindex</code>会连续调用，需要留意一下这里，后面的测试会跟这里做一个对比。</p>

<p>赋值之后打印 t.name 的值是空的。原因是<code class="highlighter-rouge">__newindex</code>并没有给t.name赋值，我们用一个错误的方式给t.name赋值，来加深<code class="highlighter-rouge">__newindex</code>的理解。修改一下测试代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {
    __newindex = function(t, key, value)
        print(&#34;call __newindex&#34;,t, key, value)
        t[key] = value
    end
}

local test = {}
setmetatable(test, meta)

print(&#34;test&#34;, test)
print(&#34;meta&#34;, meta)

test.name = &#34;t1&#34;
test.name = &#34;t2&#34;
print(test.name)

---- result output ----
...
lua: C stack overflow
...
</code></pre></div></div>

<p>报错信息，栈溢出。因为<code class="highlighter-rouge">t[key] = value</code>这段代码会调用t元表中的<code class="highlighter-rouge">__newindex</code>的方法，<code class="highlighter-rouge">__newindex</code>的方法又会调用<code class="highlighter-rouge">t[key] = value</code>，这样就进入了死循环，导致栈溢出。这时就需要用到方法<code class="highlighter-rouge">rawset</code>。</p>

<p>修改测试代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {
    __newindex = function(t, key, value)
        print(&#34;call __newindex&#34;,t, key, value)
        rawset(t, key, value)
    end
}

local test = {}
setmetatable(test, meta)

test.name = &#34;t1&#34;
test.name = &#34;t2&#34;
print(&#34;test.name&#34;, test.name)

---- result output ----
call __newindex	table: 0x7fdade404e20	name	t1
test.name	t2
</code></pre></div></div>

<p>这段代码中信息比较多</p>

<p>在<code class="highlighter-rouge">__newindex</code>中使用了<code class="highlighter-rouge">rawset</code>方法，可以看到，没有栈溢出的错误了，说明用<code class="highlighter-rouge">rawset</code>给table赋值，不会进入<code class="highlighter-rouge">__newindex</code>
的方法。</p>

<p>给t.name连续赋值，会发现只进入<code class="highlighter-rouge">__newindex</code>一次，跟之前不同的是，我们在<code class="highlighter-rouge">__newindex</code>给t.name赋了值。如果t中没有这个key时，才会进入<code class="highlighter-rouge">__newindex</code>方法。否则不会进入。</p>

<p><code class="highlighter-rouge">__newindex</code>的默认值就是上面<code class="highlighter-rouge">meta.__newindex</code>的代码。如果不需要额外处理，完全可以不写。如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {}
local test = {}
setmetatable(test, meta)

test.name = &#34;t1&#34;
print(&#34;test.name&#34;, test.name)

---- result output ----
test.name	t1

</code></pre></div></div>

<h2 id="__index">__index</h2>

<p>翻译原文</p>

<p><code class="highlighter-rouge">__index</code>用于控制属性（prototype）的继承，当访问 myTable[key] 时，如果myTable中不存在这个key，但是如果元表（metatable）中有 <code class="highlighter-rouge">__index</code>时：</p>

<ul>
  <li>如果<code class="highlighter-rouge">__index</code>是一个<code class="highlighter-rouge">function</code>，传递的参数是<code class="highlighter-rouge">table</code>和<code class="highlighter-rouge">key</code>,<code class="highlighter-rouge">function</code>的返回值作为结果返回。</li>
  <li>如果<code class="highlighter-rouge">__index</code>是一个<code class="highlighter-rouge">table</code>，就返回这个表中key对应的值。
    <ul>
      <li>如果这个<code class="highlighter-rouge">table</code>不存在该<code class="highlighter-rouge">key</code>，但是这个<code class="highlighter-rouge">table</code>有元表，会继续寻找元表中的<code class="highlighter-rouge">__index</code>属性，以此类推。都没有就返回<code class="highlighter-rouge">nil</code></li>
    </ul>
  </li>
  <li>使用 “rawget(myTable,key)” 可以跳过这个元方法（__index）.</li>
</ul>

<p>写点测试：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local test = {}

local meta = {
    __index = function(t, k)
        print(&#34;__index&#34;, k)
        if rawget(t, k) == nil then
            print(&#34;Can&#39;t find &#34;.. k)
        end

        return rawget(t, k)
    end,
}

setmetatable(test, meta)

print(&#34;test.name1&#34;, test.name)
test.name = &#34;hello&#34;
print(&#34;test.name2&#34;, test.name)


---- result output ----

__index	name
Can&#39;t find name
test.name1	nil
test.name2	hello
</code></pre></div></div>

<p><code class="highlighter-rouge">__newindex</code>和<code class="highlighter-rouge">__index</code>其实可以类比成setter和getter，这么类比会比较容易理解，但是实际上还是有比较大的区别。</p>

<p>上面的测试中<code class="highlighter-rouge">__index</code>是个function。当执行test.name时，如果test.name是nil，会调用<code class="highlighter-rouge">__index</code>的function，并返回function的返回值。否则，直接返回test[key]，不会进入<code class="highlighter-rouge">__index</code>。</p>

<p>再做一个测试，这次<code class="highlighter-rouge">__index</code>是个table</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local test = {}

local meta = {
    __index = {name=&#34;meta&#34;},
}

setmetatable(test, meta)

print(&#34;test.name1&#34;, test.name)
test.name = &#34;hello&#34;
print(&#34;test.name2&#34;, test.name)

---- result output ----

test.name1	meta
test.name2	hello
</code></pre></div></div>

<p>这个测试可以看到，访问顺序是先访问test的name，如果没有值，再访问test元表中<code class="highlighter-rouge">__index</code>的table。如果test的元表还有元表，会继续向上访问，Lua继承的实现就是利用这个特性。</p>

<p>掌握<code class="highlighter-rouge">__newindex</code>和<code class="highlighter-rouge">__index</code>这两个元方法，可以把这两个元方法看做两个事件，那要就要清楚两个方法的触发条件和特性。才能融会贯通。</p>

<p>举个例子：</p>

<p>禁用全局变量</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {
    __newindex = function(t, k, v)
        print(&#34;Error! Can&#39;t set globle variable&#34;, k)
    end,

    -- 默认实现
    -- __index = function(t, k)
    --     return rawget(t, k)
    -- end
}

setmetatable(_G, meta)

test = &#34;test&#34;
print(test)

---- result output ----

Error! Can&#39;t set globle variable	test
nil
</code></pre></div></div>

<h2 id="__mode">__mode</h2>

<p>原文翻译:</p>

<p>控制弱引用，用字符<code class="highlighter-rouge">k</code>和<code class="highlighter-rouge">v</code>来代表table的<code class="highlighter-rouge">键</code>和<code class="highlighter-rouge">值</code>是否是弱引用。这个感觉没什么好说的，只写个测试就好了。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {__mode = &#34;k&#34;}
local test = {}
setmetatable(test, meta)
key = {}
test[key] = 1
key = {}
test[key] = 2
for k,v in pairs(test) do
    print(v)
end

collectgarbage()
print(&#34;collectgarbage&#34;)

for k,v in pairs(test) do
    print(v)
end

---- result output ----

1
2
collectgarbage
2
</code></pre></div></div>

<p>例子中当调用collectgarbage()进行回收后，test表中只剩下一个值。弱引用的key被清理了。我们也可以在__mode中设置<code class="highlighter-rouge">v</code>,<code class="highlighter-rouge">kv</code>来表示<code class="highlighter-rouge">值</code> <code class="highlighter-rouge">键和值</code>都是弱引用。</p>

<h2 id="__call">__call</h2>

<p>原文翻译:</p>

<p>把table当做一个function使用，当table后跟一个圆括号时，而且table的元表中的__call指向一个function，就会调用这个function，table自己做为第一个参数，后面可接任意数量的参数，返回值就是function的返回值。</p>

<p>测试代码来模拟实现一个构造方法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {
    __call = function(t, ...)

        local instance = {}
        for k, v in pairs(t) do
            instance[k] = v
        end
        return instance
    end
}

local A = setmetatable({}, meta)

function A:info()
    print(&#34;info&#34;,self)
end

local a = A()
local b = A()

a:info()
b:info()

---- result output ----
info	table: 0x7f8771e05030
info	table: 0x7f8771e050a0
</code></pre></div></div>

<h2 id="__metatable">__metatable</h2>

<p>原文翻译：</p>

<p>隐藏真正的元表，当调用<code class="highlighter-rouge">getmetatable</code>时，而且table的元表有<code class="highlighter-rouge">__metatable</code>字段，则返回<code class="highlighter-rouge">__metatable</code>字段中的值。</p>

<p>测试代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {
    name = &#34;meta&#34;
}

local test = setmetatable({}, meta)
print(getmetatable(test).name)

local meta = {
    __metatable = {name = &#34;__metatable&#34;},
    name = &#34;meta&#34;
}

local test = setmetatable({}, meta)
print(getmetatable(test).name)

---- result output ----
meta
__metatable
</code></pre></div></div>

<p>结果很直观不解释了，我另外还做了个的测试，让<code class="highlighter-rouge">__metatable</code>指向了一个function，调用<code class="highlighter-rouge">getmetatable</code>时也会返回这个function。很有意思，但是暂时没想到有什么应用场景。</p>

<h2 id="__tostring">__tostring</h2>

<p>原文翻译：</p>

<p>控制字符串的表现，当调用<code class="highlighter-rouge">tostring(myTable)</code>时，且myTable的元表中有<code class="highlighter-rouge">__tostring</code>字段时，就会调用这个方法。返回值是方法的返回值。</p>

<p>测试代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {
    __tostring = function(t)
        return string.format(&#34;My name is %s&#34;, t.name)
    end
}

local test = setmetatable({}, meta)
test.name = &#34;test&#34;
print(test)
print(tostring(test))

---- result output ----
My name is test
My name is test
</code></pre></div></div>

<p>这个也不做过多说明了，很容易理解。有一点提一下就是print方法会自动调用tostring(test)</p>

<h2 id="__len">__len</h2>

<p>原文翻译：</p>

<p>控制table的长度。当用<code class="highlighter-rouge">#</code>操作符请求长度时，且table的元表有<code class="highlighter-rouge">__len</code>字段指向一个function，就会调用这个function，参数是table自己，返回值是function的返回值。</p>

<p>写个测试代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {
    __len = function(t)
        local result = 0
        for k, v in pairs(t) do
            result = result + 1
        end
        return result
    end
}


local test = {
    [1] = &#34;A&#34;,
    [2] = &#34;B&#34;,
    [3] = &#34;C&#34;,
    [5] = &#34;D&#34;,
    [6] = &#34;E&#34;,
    [8] = &#34;F&#34;,
}
print(#test)

setmetatable(test, meta)
print(#test)

---- result output ----
3
6
</code></pre></div></div>

<p>Lua中使用<code class="highlighter-rouge">#</code>获取长度有个特性，就是如果某个key对应的值是nil就结束，上面例子中，test第4个值是nil，那返回的长度为3。我们重新定义了<code class="highlighter-rouge">__len</code>后返回了，用遍历的方式计算长度，返回table内元素的数量为6。</p>

<h2 id="__gc">__gc</h2>

<p>原文翻译：</p>

<p>简单说就是数据被垃圾回收的时候会首先触发<code class="highlighter-rouge">__gc</code>。</p>

<p>测试代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local meta = {

    __gc = function(t)
        print(&#34;gc&#34;)
    end
}

local function test()
    local test = {}
    setmetatable(test, meta)
end

test()

---- result output ----
gc
</code></pre></div></div>

<p>Lua table中所有的元方法就分析完了，还有一些操作符重载的，之后再写。</p>