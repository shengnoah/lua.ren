---
layout: post
title: lua学习笔记 
tags: [lua文章]
categories: [topic]
---
<p><img src="https://lostplesed.github.io//images/lua.jpg" alt=""/></p>
<p>使用命令行参数-i来启动lua解释器，那么解释器就会在运行完指定的程序块后进入交互模式。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">test.lua</span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">( ... )</span></span></span><br/><span class="line">	</span><br/><span class="line">	<span class="built_in">print</span>(<span class="string">&#34;foo&#34;</span>)</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">lua -i test.lua</span><br/><span class="line">Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio</span><br/><span class="line"> foo()</span><br/><span class="line">foo</span><br/></pre></td></tr></tbody></table></figure>
<p>另一种运行程序块的方式是使用函数dofile，该函数会立即执行一个文件。</p>
<p>行注释</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">-- here</span></span><br/></pre></td></tr></tbody></table></figure>
<p>块注释</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br/><span class="line"><span class="comment">here</span></span><br/><span class="line"><span class="comment">here</span></span><br/><span class="line"><span class="comment">--]]</span></span><br/></pre></td></tr></tbody></table></figure>
<h1 id="类型与值"><a href="#类型与值" class="headerlink" title="类型与值"></a>类型与值</h1><p>在lua中有8种基础类型：nil，boolean，number，string，userdata，function，thread，table</p>
<p>函数type可根据一个值返回其类型名称：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>)) <span class="comment">-- function</span></span><br/></pre></td></tr></tbody></table></figure>
<p>lua将值false和nil视为“假”，而除此之外的其他值视为“真”。</p>
<p>lua提供运行时的数字与字符串的自动转换。在一个字符串上应用算数操作时，lua会尝试将这个字符串转换成一个数字：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#34;10&#34;</span> + <span class="number">1</span>) <span class="comment">-- 11</span></span><br/></pre></td></tr></tbody></table></figure>
<p>lua不仅在算数操作中会使用这种强制转换，还会在其他任何需要数字的地方这么做，反之亦然：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span> .. <span class="number">20</span>) <span class="comment">-- 1020</span></span><br/></pre></td></tr></tbody></table></figure>
<p>a.x和a[“x”]等价</p>
<h1 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h1><p>操作符==和~=用来做相等测试，如果两个值具有不同的类型，lua就认为它们不相等。否则，lua会根据它们的类型来比较两者。对于table，userdata和函数，lua是作引用比较。</p>
<p>只能对两个数字或两个字符串作大小性比较。lua是按字母次序来比较字符串的，具体的字母次序取决于对lua的区域设置。</p>
<p>lua操作符优先级（从高到低）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line">^</span><br/><span class="line">not # -</span><br/><span class="line">* / %</span><br/><span class="line">+ -</span><br/><span class="line">..</span><br/><span class="line">&lt; &gt; &lt;= &gt;= ~= ==</span><br/><span class="line">and</span><br/><span class="line">or</span><br/></pre></td></tr></tbody></table></figure>
<p>在二元操作符中，除了指数操作符^和连接操作符..是右结合，所有其他操作符都是左结合。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">a + i &lt; b / 2 + 1	-- 		(a + i ) &lt; ((b / 2) + 1)</span><br/><span class="line">x ^ y ^ z				--		x ^ (y ^ z)</span><br/></pre></td></tr></tbody></table></figure>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>lua允许多重赋值</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span></span><br/></pre></td></tr></tbody></table></figure>
<p>尽可能地使用局部变量是一种良好的编程风格，局部变量可以避免将一些无用的名称引入全局环境，避免扰乱了全局环境。此外，访问局部变量比访问全局变量更快，。最后一个局部变量通常会随着其作用域的结束而消失，这样便使垃圾收集器可以释放其值。</p>
<p>控制结构：</p>
<p>if-else-then:</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cond <span class="keyword">then</span></span><br/><span class="line">	<span class="comment">-- do</span></span><br/><span class="line"><span class="keyword">elseif</span> cond1 <span class="keyword">then</span></span><br/><span class="line">	<span class="comment">-- do1</span></span><br/><span class="line"><span class="keyword">else</span></span><br/><span class="line">	<span class="comment">-- rest</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>while:</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> cond <span class="keyword">do</span></span><br/><span class="line">	<span class="comment">-- do</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>repeat:</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br/><span class="line">	<span class="comment">-- do</span></span><br/><span class="line"><span class="keyword">until</span> cond</span><br/></pre></td></tr></tbody></table></figure>
<p>对于lua的repeat语句来说，一个声明在循环体中的局部变量的作用域包括了条件测试。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>调用函数无论哪种方法都需要将所有参数放到一对圆括号中。即使调用函数时没有参数，也必须写出一对空括号。对于此规则只有一种特殊的例外情况：一个函数若只有一个参数，并且此参数是一个字面字符串或者table构造式，那么圆括号便是可有可无的：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#34;hello world&#34;</span></span><br/><span class="line">f{x = <span class="number">10</span>, y = <span class="number">20</span>}</span><br/></pre></td></tr></tbody></table></figure>
<p>lua函数可以返回多个值，如果一个函数没有返回值或者没有足够多的返回值，那么lua会用nil来补充缺失的值：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line">	<span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> a, b, c = foo()</span><br/><span class="line"><span class="built_in">print</span>(<span class="string">&#34;a = &#34;</span> .. a .. <span class="string">&#34; b = &#34;</span> .. b .. <span class="string">&#34; c = &#34;</span> .. <span class="built_in">type</span>(c)) <span class="comment">-- a = 1 b = 2 c = nil</span></span><br/></pre></td></tr></tbody></table></figure>
<p>unpack函数接受一个数组作为参数，并从下标1开始返回该数组的所有元素：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">unpack</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>}) <span class="comment">-- 10 20 30</span></span><br/></pre></td></tr></tbody></table></figure>
<p>参数表中使用3个点（…）表示该函数可接受不同数量的实参，表达式“…”的行为类似于一个具有多重返回值的函数，它返回的是当前函数的所有变长参数。</p>
<p>在lua中，函数是第一类值，它们具有特定的词法域。“第一类值”表示在lua中函数与其它传统类型的值具有相同的权利。函数可以存储到变量或者table中，可以作为实参传递给其他函数，还可以作为其它函数的返回值。“词法域”是指一个函数可以嵌套在另外一个函数中，内部的函数可以访问外部函数中的变量。</p>
<p>一个closure就是一个函数加上该函数所需访问的所有“非局部的变量”。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br/><span class="line">	<span class="keyword">local</span> i = <span class="number">0</span></span><br/><span class="line">	<span class="keyword">return</span></span><br/><span class="line">	<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">		i = i + <span class="number">1</span></span><br/><span class="line">		<span class="keyword">return</span> i</span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">c1 = newCounter()</span><br/><span class="line">c2 = newCounter()</span><br/><span class="line"><span class="built_in">print</span>(c1()) <span class="comment">-- 1</span></span><br/><span class="line"><span class="built_in">print</span>(c1()) <span class="comment">-- 2</span></span><br/><span class="line"><span class="built_in">print</span>(c2()) <span class="comment">-- 1</span></span><br/></pre></td></tr></tbody></table></figure>
<p>上面这段代码中，匿名函数访问了一个“非局部变量”i，如果再次调用newCounter，那么它会创建一个新的局部变量i，从而也将得到一个新的closure。</p>
<p>可以使用同样的技术创建一个安全的运行环境，即所谓的“沙盒（sandbox）”。当执行一些未受信任的代码时就需要一个安全的执行环境，例如在服务器中执行那些从internet上接收到的代码。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br/><span class="line">	<span class="keyword">local</span> oldOpen = <span class="built_in">io</span>.<span class="built_in">open</span></span><br/><span class="line">	<span class="keyword">local</span> access_ok = <span class="function"><span class="keyword">function</span> <span class="params">(filename, mode)</span></span></span><br/><span class="line">		<span class="comment">--检查访问权限</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line">	</span><br/><span class="line">	<span class="built_in">io</span>.<span class="built_in">open</span> = <span class="function"><span class="keyword">function</span> <span class="params">(filename, mode)</span></span></span><br/><span class="line">		<span class="keyword">if</span> access_ok(filename, mode) <span class="keyword">then</span></span><br/><span class="line">			<span class="keyword">return</span> oldOpen(filename, mode)</span><br/><span class="line">		<span class="keyword">else</span></span><br/><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&#34;access denied&#34;</span></span><br/><span class="line">		<span class="keyword">end</span></span><br/><span class="line">	<span class="keyword">end</span></span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<p>经过重新定义后，一个程序就只能通过新的受限版本来调用原来那个未受限的open函数了。</p>
<h1 id="表和面向对象"><a href="#表和面向对象" class="headerlink" title="表和面向对象"></a>表和面向对象</h1><p>创建表</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">t = {}</span><br/></pre></td></tr></tbody></table></figure>
<p>设置和访问表内容，不存在的表内容返回nil</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">t[<span class="string">&#34;key] = 1</span></span><br/><span class="line"><span class="string">local value = t[&#34;</span>key<span class="string">&#34;]</span></span><br/></pre></td></tr></tbody></table></figure>