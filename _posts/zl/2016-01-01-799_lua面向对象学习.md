---
layout: post
title: lua面向对象学习 
tags: [lua文章]
categories: [topic]
---
<div class="content" itemprop="articleBody">
    <h2 id="元表和元方法"><a href="#元表和元方法" class="headerlink" title="元表和元方法"></a>元表和元方法</h2><p>   在Lua中，每个值都有一个元表，table和userdata类型的每个变量都可以有各自独立的元表，<br/>   其他类型的值则共享其类型所属的单一元表。</p>
<h3 id="基本的metatable"><a href="#基本的metatable" class="headerlink" title="基本的metatable"></a>基本的metatable</h3><ul>
<li>创建新的table时不会创建元表</li>
<li><strong>getmetatable(table)</strong> 获取table或者userdata类型变量的元表</li>
<li><p><strong>setmetatable(t,ot)</strong> 设置table或者userdata类型变量的元表</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">local t = {1,1}</div><div class="line">print getmetatable(t)     -- nil</div><div class="line"></div><div class="line">local t1 = {}</div><div class="line">setmetatable(t,t1)</div><div class="line">assert(getmetatable(t) == t1)</div></pre></td></tr></tbody></table></figure>
</li>
<li><p>Lua代码中，只能设置table的元表，若要设置其他类型的值的元表，必须通过C代码来完成。</p>
</li>
<li>标准的字符串程序库为所有的字符串都设置了一个元表，其他类型在默认情况下没有元表。</li>
<li><p>table中可以重新定义的元方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">__add(a,b) --加法</div><div class="line">__sub(a,b) --减法</div><div class="line">__mul(a,b) --乘法</div><div class="line">__div(a,b) --除法</div><div class="line">__mod(a,b) --取模</div><div class="line">__pow(a,b) --乘幂</div><div class="line">__unm(a)   --相反数</div><div class="line">__concat(a,b) -- 连接</div><div class="line">__len(a)   --长度</div><div class="line">__eq(a,b)  --相等</div><div class="line">__lt(a,b)  --小于</div><div class="line">__le(a,b)  --小于等于</div><div class="line">__index(a,b) --索引查询</div><div class="line">__newindex(a,b,c) --索引更新</div><div class="line">__call(a,...) --执行方法调用</div><div class="line">__tostring(a) --字符串输出</div><div class="line">__metatable --保护元表</div></pre></td></tr></tbody></table></figure>
</li>
<li><p>当操作符的两个操作数都有元表时的函数获取规则：</p>
<ol>
<li>对于二元操作符，如果第一个操作数有元表，并且元表中有所需要的字段定义，那么lua就以这个字段为元方法。</li>
<li>对于二元操作符，如果第一个操作数有元表，但是元表中没有所需要的字段定义，那么lua就去查找第二个操作数的元表。</li>
<li>如果两个操作数都没有元表，或者都没有对应的元方法定义，lua就会引发一个错误。</li>
</ol>
</li>
<li><p>保护元表：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Set.new(l)</div><div class="line">    local set = {}</div><div class="line">    setmetatable(set,mt)</div><div class="line">    for _, v in pairs(l) do set[v] = true end</div><div class="line">    mt.__metatable = &#34;You cannot get the metatable&#34;</div><div class="line">    return set</div><div class="line">end</div><div class="line"></div><div class="line">local tb = Set.new({1,2})</div><div class="line">print(tb)                -- 输出：{1, 2}</div><div class="line"></div><div class="line">print(getmetatable(tb))  -- 输出__metatable的内容：You cannot get the metatable</div><div class="line">setmetatable(tb,{})      -- 输出错误信息：lua: test.lua:56: cannot change a protected metatable</div></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><p>当访问一个table中不存在的字段时，lua的处理规则：</p>
<ol>
<li>当table有这个字段时，直接返回对应的值；</li>
<li>当table没有这个字段时，解释器会去查找一个叫__index的元方法，并调用对应的元方法，返回结果</li>
<li>如果没有这个元方法，返回nil<br/>__index使用的例子：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">-- 假设要创建一些描述窗口，每个table中都必须描述一些窗口参数，例如颜色，位置和大小等</div><div class="line">Windows = {} -- 创建一个命名空间</div><div class="line"></div><div class="line">-- 创建默认值表</div><div class="line">Window.default = {x = 0, y = 0, width = 100, height = 100, color = {r = 255, g = 255, b = 255}}</div><div class="line"></div><div class="line">Window.mt = {} --创建元表</div><div class="line"></div><div class="line">-- 声明构造函数</div><div class="line">function Windows.new(0)</div><div class="line">    setmetatable(o, Window.mt)</div><div class="line">end</div><div class="line"></div><div class="line">-- 定义__lindex元方法</div><div class="line">Window.mt.__index = function (table, key)</div><div class="line">    return Windows.default[key]</div><div class="line">end</div><div class="line"></div><div class="line">local win = Window.new({x = 10, y = 10})</div><div class="line">print(win.x)     -- &gt;10 访问自身已经拥有的值</div><div class="line">print(win.width) -- &gt;100 访问default表中的值</div><div class="line">print(win.color.r) -- &gt;255 访问default表中的值</div><div class="line"></div><div class="line">-- __index元方法不一定必须是个函数，它还可以是一个table。</div></pre></td></tr></tbody></table></figure>
</li>
</ol>
<ul>
<li><p><strong>newindex元方法，与</strong>index类似，<strong>newindex用于更新table中的数据，</strong>index用于查询table中的数据。当对table中不存在的索引赋值时，执行步骤如下：</p>
<ol>
<li>Lua解释器先判断这个table是否有元表，如果没有元表，就直接添加这个索引，然后对应赋值</li>
<li>如果有了元表，就查找元表中是否有__newindex元方法，如果有这个方法，lua解释器就执行这个元方法，而不是赋值</li>
<li>如果这个__newindex对应的不是一个函数，而是一个table时，lua解释器就在这个table中执行赋值，而不是在原来的table中<br/>示例代码：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">local tb1 = {}</div><div class="line">local tb2 = {}</div><div class="line"></div><div class="line">tb1.__newindex = tb2</div><div class="line">tb2.__newindex = tb1</div><div class="line"></div><div class="line">setmetatable(tb1,tb2)</div><div class="line">setmetatable(tb2,tb1)</div><div class="line"></div><div class="line">tb1.x = 10</div></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>上面的代码存在循环引用的问题，lua解释器会抛出如下错误:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loop in settable</div></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>- rawget(tb,i); 直接访问tb属性，不使元表，即忽略__index的定义
- rawset(tb,k,v); 直接设置tb属性，不使用元表，即忽略__newindex的定义
</code></pre><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code>记录table的访问
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">local t = {} --原来的table</div><div class="line"></div><div class="line">-- 保持对原table的一个引用</div><div class="line">local _t = t</div><div class="line"></div><div class="line">-- 创建代理</div><div class="line">t = {}</div><div class="line"></div><div class="line">-- 创建元表</div><div class="line">local mt = {</div><div class="line">__index = function(t, k)</div><div class="line">    print(&#34;access to element &#34; .. tostring(k))</div><div class="line">    return _t[k]</div><div class="line">end,</div><div class="line"></div><div class="line">__newindex = function(t, k, v)</div><div class="line">    print(&#34;update of element &#34; .. tostring(k))</div><div class="line">    _t[k] = v</div><div class="line">end</div><div class="line">}</div><div class="line"></div><div class="line">setmetatable(t, mt)</div><div class="line"></div><div class="line">t.x = 10  -- update of element x</div><div class="line">print(t.x) -- access to element x</div></pre></td></tr></tbody></table></figure>

多个table访问日志，使用代理模式
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">-- 创建唯一索引</div><div class="line">local index = {}</div><div class="line"></div><div class="line">-- 创建元表</div><div class="line">local mt = {</div><div class="line">    __index = function(t, k)</div><div class="line">        print(&#34;access to element &#34; .. tostring(k))</div><div class="line">        return t[index][k]</div><div class="line">    end,</div><div class="line">    </div><div class="line">    __newindex = function(t, k, v)</div><div class="line">        print(&#34;update of element &#34; .. tostring(k))</div><div class="line">        t[index][k] = v</div><div class="line">    end</div><div class="line">}</div><div class="line"></div><div class="line">function track(t)</div><div class="line">    local proxy = {}</div><div class="line">    proxy[index] = t</div><div class="line">    setmetatable(proxy, mt)</div><div class="line">    return proxy</div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line">local t = {}</div><div class="line">local proxy = track(t)</div><div class="line">proxy.x = 10</div><div class="line">print(proxy.x)</div></pre></td></tr></tbody></table></figure>


只读的table(代理模式)
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function readOnly(t)</div><div class="line">    local proxy = {}</div><div class="line">    </div><div class="line">    -- 创建元表</div><div class="line">    local mt = {</div><div class="line">    __index = t,</div><div class="line">    __newindex = function(t, k, v)</div><div class="line">        error(&#34;Attempt to update a read-only table&#34;, 2)</div><div class="line">    end</div><div class="line">    }</div><div class="line">    </div><div class="line">    setmetatable(proxy, mt)</div><div class="line">    return proxy</div><div class="line">end</div><div class="line"></div><div class="line">local tb = readOnly{1, 2, 3, 4, 5}</div><div class="line">print(tb[1])</div><div class="line">tb[1] = 20  -- Attempt to update a read-only table</div></pre></td></tr></tbody></table></figure>
</code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>lua中，table就是对象，对象就是表，lua中的类本质上也是对象（表），不过是用来做模版的对象。<br/>lua中的类和javascript中的非常类似，也是采用原型(prototype)的概念。lua通过元表实现原型。<br/>像下面这样：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setmetatable(a, {__index = b})</div></pre></td></tr></tbody></table></figure><p></p>
<p>lua中方法的调用：<br/></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">local Account = {balance = 0}</div><div class="line">function Account.withDraw(self, v)  -- 需要明确定义传入self参数</div><div class="line">    self.balance = self.balance - v</div><div class="line">end</div><div class="line"></div><div class="line">local a = Account</div><div class="line">a.withDraw(a,10) -- 调用函数，需要明确指定self参数</div><div class="line"></div><div class="line">-- 隐藏self参数的语法糖</div><div class="line">function Account:withDraw(v) -- 注意，是&#34;:&#34;号，且省略了self参数，但是函数仍然可以使用self</div><div class="line">    self.balance = self.balance - v   </div><div class="line">end</div><div class="line"></div><div class="line">a = Account</div><div class="line">a:withDraw(100) -- 注意这里的调用使用&#34;:&#34;并且也不需要传入a本身</div><div class="line">print(a.balance)</div></pre></td></tr></tbody></table></figure><p></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.jellythink.com/archives/529" target="_blank" rel="external noopener noreferrer">Lua中的面向对象编程</a></li>
<li><a href="http://blog.codingnow.com/2006/06/oo_lua.html" target="_blank" rel="external noopener noreferrer">在Lua中实现面向对象</a></li>
<li><a href="http://www.jellythink.com/archives/511" target="_blank" rel="external noopener noreferrer">Lua中的元表与元方法</a></li>
<li><a href="http://www.jellythink.com/archives/517" target="_blank" rel="external noopener noreferrer">Lua中<strong>index和</strong>newindex实践</a></li>
</ul>

  </div>