---
layout: post
title: Lua table 
tags: [lua文章]
categories: [topic]
---
<div itemprop="articleBody">
                        



<h2 id="heading-table">table</h2>

<h3 id="heading-常用函数">常用函数</h3>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">-- 获取参数表 table，并对这个 table 预定义一个字段 n（表示该表的长度）。</span>
<span class="kd">local</span> <span class="n">arg</span> <span class="o">=</span> <span class="nb">table.pack</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">n</span> <span class="k">do</span>  
  <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="k">end</span>

<span class="cm">--[[
提供一个列表，其所有元素都是字符串或数字，返回字符串 list[i]..sep..list[i+1] ··· sep..list[j]。 
sep 的默认值是空串， i 的默认值是 1 ， j 的默认值是 #list 。 如果 i 比 j 大，返回空串。
]]</span>

<span class="nb">table.concat</span><span class="p">(</span><span class="n">list</span> <span class="p">[,</span> <span class="n">sep</span> <span class="p">[,</span> <span class="n">i</span> <span class="p">[,</span> <span class="n">j</span><span class="p">]]])</span>

<span class="cm">--[[
在 list 的位置 pos 处插入元素 value ， 并后移元素 list[pos], list[pos+1], ···, list[#list] 。 
pos 的默认值为 #list+1 ， 因此调用 table.insert(t,x) 会将 x 插在列表 t 的末尾。
]]</span>
<span class="nb">table.insert</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">[</span><span class="n">pos</span><span class="p">,]</span> <span class="n">value</span><span class="p">)</span>

<span class="cm">--[[
将元素从表 a1 移到表 a2。 这个函数做了次等价于后面这个多重赋值的等价操作： a2[t],··· = a1[f],···,a1[e]。 a2 的默认值为 a1。 
目标区间可以和源区间重叠。 索引 f 必须是正数。
]]</span>
<span class="n">table</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">t</span> <span class="p">[,</span> <span class="n">a2</span><span class="p">])</span>

<span class="cm">--[[
移除 list 中 pos 位置上的元素，并返回这个被移除的值。 
当 pos 是在 1 到 #list 之间的整数时， 它向前移动元素　list[pos+1], list[pos+2], ···, list[#list] 并删除元素 list[#list]； 
索引 pos 可以是 #list + 1 ，或在 #list 为 0 时可以是 0 ； 在这些情况下，函数删除元素 list[pos]。
pos 默认为 #list， 因此调用 table.remove(l) 将移除表 l 的最后一个元素。
]]</span>
<span class="nb">table.remove</span><span class="p">(</span><span class="n">list</span> <span class="p">[,</span> <span class="n">pos</span><span class="p">])</span>

<span class="cm">--[[
在表内从 list[1] 到 list[#list] 原地 对其间元素按指定次序排序。 
如果提供了 comp ， 它必须是一个可以接收两个列表内元素为参数的函数。 
当第一个元素需要排在第二个元素之前时，返回真 （因此 not comp(list[i+1],list[i]) 在排序结束后将为真）。 
如果没有提供 comp， 将使用标准 Lua 操作 &lt; 作为替代品。
排序算法并不稳定； 即当两个元素次序相等时，它们在排序后的相对位置可能会改变。
]]</span>
<span class="nb">table.sort</span><span class="p">(</span><span class="n">list</span> <span class="p">[,</span> <span class="n">comp</span><span class="p">])</span>

<span class="cm">--[[
返回列表中的元素。 这个函数等价于
     return list[i], list[i+1], ···, list[j]
i 默认为 1 ，j 默认为 #list。
]]</span>
<span class="nb">table.unpack</span><span class="p">(</span><span class="n">list</span> <span class="p">[,</span> <span class="n">i</span> <span class="p">[,</span> <span class="n">j</span><span class="p">]])</span>

</code></pre></div></div>

<h3 id="heading-table-的深拷贝">table 的深拷贝</h3>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">--[[
一般表的复制都是引用，深拷贝需要实现：1、值的复制，2、方法的复制
所以要解决 3 个问题：
1、table 存在循环引用
2、metatable（metatable 都不参与复制）
3、keys 也是 table
]]</span>
<span class="k">function</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
  <span class="kd">local</span> <span class="n">Table</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kd">local</span> <span class="k">function</span> <span class="nf">func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">~=</span> <span class="s2">&#34;table&#34;</span> <span class="k">then</span>
      <span class="k">return</span>
    <span class="k">end</span>
    <span class="kd">local</span> <span class="n">newtable</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">Table</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">newtable</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">pairs</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">newtable</span><span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="nb">setmetatable</span><span class="p">(</span><span class="n">newtable</span><span class="p">,</span> <span class="nb">getmetatable</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="heading-元表">元表</h2>

<h1 id="heading-参考链接">参考链接</h1>

<ul>
  <li><a href="https://blog.csdn.net/zr339361504/article/details/52432163">lua table 的内部实现</a></li>
</ul>

                    </div>