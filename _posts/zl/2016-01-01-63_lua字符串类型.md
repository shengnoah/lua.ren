---
layout: post
title: lua字符串类型 
tags: [lua文章]
categories: [topic]
---
<p>Lua中字符串结构体的定义是:</p>
<pre><code>typedef union TString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  struct {
    CommonHeader;
    lu_byte reserved;
    unsigned int hash;
    size_t len;
  } tsv;
} TString;
</code></pre><p>这里TString结构体是一个union, 最开始的L_Umaxalign dummy;起到的是对齐作用.紧跟着是CommonHeader,可以看出TString也是可GC数据类型的一种.</p>
<p>在Lua中,字符串是一个保存在一个全局的地方,在globale_state的strt里面,这是一个hash数组,专门用于存放字符串:</p>
<pre><code>typedef struct stringtable {
  GCObject **hash;
  lu_int32 nuse;  /* number of elements */
  int size;
} stringtable;
</code></pre><p>一个字符串TString,首先根据hash算法算出hash值,这就是stringtable中hash的索引值,如果这里已经有元素,则使用链表串接起来.</p>
<p>同时,TString中的字段reserved,表示这个字符串是不是保留字符串,比如Lua的关键字,在最开始赋值的时候是这么处理的:</p>
<pre><code>void luaX_init (lua_State *L) {
  int i;
  for (i=0; itsv.reserved = cast_byte(i+1);  /* reserved word */
  }
}
</code></pre><p>这里存放的值,是数组luaX_tokens中的索引:</p>
<pre><code>const char *const luaX_tokens [] = {
    &#34;and&#34;, &#34;break&#34;, &#34;do&#34;, &#34;else&#34;, &#34;elseif&#34;,
    &#34;end&#34;, &#34;false&#34;, &#34;for&#34;, &#34;function&#34;, &#34;if&#34;,
    &#34;in&#34;, &#34;local&#34;, &#34;nil&#34;, &#34;not&#34;, &#34;or&#34;, &#34;repeat&#34;,
    &#34;return&#34;, &#34;then&#34;, &#34;true&#34;, &#34;until&#34;, &#34;while&#34;,
    &#34;..&#34;, &#34;...&#34;, &#34;==&#34;, &#34;&gt;=&#34;, &#34;&lt;=&#34;, &#34;~=&#34;,
    &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;,
    NULL
};
</code></pre><p>一方面可以迅速定位到是哪个关键字,另方面如果这个reserved字段不为0,则表示该字符串是不可自动回收的,在GC过程中会略过这个字符串的处理.</p>
<p>具体查找字符串时,首先计算出hash值,定位到所在的strt中的hash数组所在,再遍历hash桶所在链表,首先比较长度,如果相同再继续逐字节的比较字符串内容:</p>
<pre><code>TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
  GCObject *o;
  unsigned int h = cast(unsigned int, l);  /* seed */
  size_t step = (l&gt;&gt;5)+1;  /* if string is too long, don&#39;t hash all its chars */
  size_t l1;
  for (l1=l; l1&gt;=step; l1-=step)  /* compute hash */
    h = h ^ ((h&lt;&lt;5)+(h&gt;&gt;2)+cast(unsigned char, str[l1-1]));
  for (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];
       o != NULL;
       o = o-&gt;gch.next) {
    TString *ts = rawgco2ts(o);
    if (ts-&gt;tsv.len == l &amp;&amp; (memcmp(str, getstr(ts), l) == 0)) {
      /* string may be dead */
      if (isdead(G(L), o)) changewhite(o);
      return ts;
    }
  }
  return newlstr(L, str, l, h);  /* not found */
}
</code></pre>