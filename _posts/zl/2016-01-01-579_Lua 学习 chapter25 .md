---
layout: post
title: Lua 学习 chapter25  
tags: [lua文章]
categories: [topic]
---
<h3 id="目录">目录</h3>
<ol>
  <li>自省机制</li>
  <li>访问变量</li>
  <li>钩子</li>
  <li>沙盒</li>
</ol>

<blockquote>
  <p>只有疯狂过，你才知道自己究竟能不能成功。</p>
</blockquote>

<h2 id="自省机制">自省机制</h2>
<p>通过debug.getinfo(foo)，函数就会返回一个包含该函数有关的一些数据的表。</p>

<h2 id="访问变量">访问变量</h2>
<p>通过debug.getlocal来检查任意活跃函数的局部变量。还可以通过函数getupvalue来访问一个呗lua函数所使用的的非局部变量。
我们还可以通过traceback函数来打印堆栈信息。</p>

<h2 id="钩子">钩子</h2>
<p>调试库中的钩子机制允许用户注册一个钩子函数，这个钩子函数会在程序运行中某个特定事件发生时被调用：</p>
<ul>
  <li>每当调用一个函数时产生的call事件</li>
  <li>每当函数返回时产生的return事件</li>
  <li>每当开始执行一行新代码产生的line事件</li>
  <li>执行完指定数量的指令后产生的count事件</li>
</ul>

<p>钩子函数的注册：通过debug.sethook：第一个参数是钩子函数，第二个参数是描述要监控事件掩码字符串，第三个参数是一个用于描述以何种频度获取count事件的可选参数。
要监控call、return、line事件，把这几个事件的首字母放入掩码字符串。要监控count事件，则需要在第三个参数中指定一个计数器。如果要关闭钩子，不带参数的调用sethook函数即可。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">function</span> <span class="nf">hello</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hello&#34;</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">debug.sethook</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span><span class="s2">&#34;c&#34;</span><span class="p">)</span>
<span class="n">hello</span><span class="p">()</span>
<span class="cm">--[[输出
hello	call
hello	call
hello	call
hellohello	call
	nil
]]</span><span class="c1">--</span>


</pre></td></tr></tbody></table></code></pre></div></div>

<p>load函数通常被加载代码段的上值_ENV初始化为全局变量。</p>

<p>在lua中，<strong>一个具有弱引用的键和一个强引用的值的表是一个瞬表。</strong></p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">o</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">}</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">{</span><span class="n">__gc</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="k">end</span><span class="p">})</span>
<span class="n">o</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="nb">collectgarbage</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>元函数__gc表示析构函数，在垃圾回收这个对象的时候会自动调用函数。</p>

<h2 id="垃圾收集器">垃圾收集器</h2>
<p>每一个垃圾回收周期由四个阶段组成：标记、清理、清除和析构。</p>
<ul>
  <li>标记阶段：把可达对象标记为活跃；</li>
  <li>清理阶段处：理析构器和弱引用表，这些没有被标记为活跃状态的对象会被标记为活跃（复苏），并放在一个单独的列表中，这个列表将在析构阶段使用。然后，lua遍历弱引用表并从中移除键或者值未被标记的元素。</li>
  <li>清除阶段：遍历所有对象，对象未被标记为活跃就回收，否则标记为清理标记，然后准备下一个清理周期。</li>
  <li>析构阶段：调用清理阶段被分离出来的对象的析构器。</li>
</ul>



                <hr style="visibility: hidden;"/>
                
                <hr style="visibility: hidden;"/>