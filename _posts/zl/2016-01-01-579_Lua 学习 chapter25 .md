---
layout: post
title: Lua 学习 chapter25  
tags: [lua文章]
categories: [topic]
---
### 目录

  1. 自省机制
  2. 访问变量
  3. 钩子
  4. 沙盒

> 只有疯狂过，你才知道自己究竟能不能成功。

## 自省机制

通过debug.getinfo(foo)，函数就会返回一个包含该函数有关的一些数据的表。

## 访问变量

通过debug.getlocal来检查任意活跃函数的局部变量。还可以通过函数getupvalue来访问一个呗lua函数所使用的的非局部变量。
我们还可以通过traceback函数来打印堆栈信息。

## 钩子

调试库中的钩子机制允许用户注册一个钩子函数，这个钩子函数会在程序运行中某个特定事件发生时被调用：

  * 每当调用一个函数时产生的call事件
  * 每当函数返回时产生的return事件
  * 每当开始执行一行新代码产生的line事件
  * 执行完指定数量的指令后产生的count事件

钩子函数的注册：通过debug.sethook：第一个参数是钩子函数，第二个参数是描述要监控事件掩码字符串，第三个参数是一个用于描述以何种频度获取count事件的可选参数。
要监控call、return、line事件，把这几个事件的首字母放入掩码字符串。要监控count事件，则需要在第三个参数中指定一个计数器。如果要关闭钩子，不带参数的调用sethook函数即可。

    
    
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    

|

    
    
    function hello(event)
        print("hello", event)
    end
    debug.sethook(hello,"c")
    hello()
    --[[输出
    hello	call
    hello	call
    hello	call
    hellohello	call
    	nil
    ]]--
    
    
      
  
---|---  
`

load函数通常被加载代码段的上值_ENV初始化为全局变量。

在lua中， **一个具有弱引用的键和一个强引用的值的表是一个瞬表。**

    
    
    1
    2
    3
    4
    

|

    
    
    o = { x = "hi"}
    setmetatable(o, {__gc = function(o) print(o.x) end})
    o = nil
    collectgarbage()
      
  
---|---  
`

元函数__gc表示析构函数，在垃圾回收这个对象的时候会自动调用函数。

## 垃圾收集器

每一个垃圾回收周期由四个阶段组成：标记、清理、清除和析构。

  * 标记阶段：把可达对象标记为活跃；
  * 清理阶段处：理析构器和弱引用表，这些没有被标记为活跃状态的对象会被标记为活跃（复苏），并放在一个单独的列表中，这个列表将在析构阶段使用。然后，lua遍历弱引用表并从中移除键或者值未被标记的元素。
  * 清除阶段：遍历所有对象，对象未被标记为活跃就回收，否则标记为清理标记，然后准备下一个清理周期。
  * 析构阶段：调用清理阶段被分离出来的对象的析构器。

* * *

* * *