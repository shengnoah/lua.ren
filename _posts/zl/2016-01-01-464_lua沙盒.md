---
layout: post
title: lua沙盒 
tags: [lua文章]
categories: [topic]
---
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>Lua 给我的感觉是：各种内置函数和标准库的存在感都是比较强的。如果执行这句：   </p>
<p><code>for name in pairs(_G) do print(_G) end</code><br/>就会把各种环境中已存在名称的打印出来：    </p>
<p>全局变量：比如字符串 _VERSION。<br/>内置函数：比如 print、tonumber、dofile 之类。<br/>模块名称：比如 string、io、coroutine 之类。<br/>这里的全局变量 _G 就是存放环境的表（于是会有 _G 中存在着 _G._G 的递归）。   </p>
<p>于是，平时对于全局变量的访问就可以等同于对 _G 表进行索引：   </p>
<p>value = _G[varname]  –&gt; value = varname<br/>_G[varname] = value  –&gt; varname = value  </p>
<h3 id="改变函数的环境"><a href="#改变函数的环境" class="headerlink" title="改变函数的环境"></a>改变函数的环境</h3><p>函数的上下文环境可以通过 setfenv(f, table) 函数改变，其中 table 是新的环境表，f 表示需要被改变环境的函数。如果 f 是数字，则将其视为堆栈层级（Stack   Level），从而指明函数（1 为当前函数，2 为上一级函数）：           </p>
<pre><code>a = 3          -- 全局变量 a
setfenv(1, {}) -- 将当前函数的环境表改为空表
print(a)       -- 出错，因为当前环境表中 print 已经不存在了
没错，不仅是 a 不存在，连 print 都一块儿不存在了。如果需要引用以前的 print 则需要在新的环境表中放入线索：

a = 3
setfenv(1, { g = _G })
g.print(a)             -- 输出 nil
g.print(g.a)           -- 输出 3
</code></pre><h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3><p>于是，出于安全或者改变一些内置函数行为的目的，需要在执行 Lua   代码时改变其环境时便可以使用 setfenv   函数。仅将你认为安全的函数或者新的实现加入新环境表中：  </p>
<pre><code>local env = {}  -- 沙盒环境表，按需要添入允许的函数  

function run_sandbox(code)
  local func, message = loadstring(code)
  if not func then return nil, message end  -- 传入代码本身错误
  setfenv(func, env)
  return pcall(func)
end
</code></pre><p>Lua 5.2 的 _ENV 变量<br/>Lua 5.2 中所有对全局变量 var 的访问都会在语法上翻译为 _ENV.var。而 _ENV 本身被认为是处于当前块外的一个局部变量。（于是只要你自己定义一个名为 _ENV 的变量，就自动成为了其后代码所处的「环境」（enviroment）。另有一个「全局环境」（global enviroment）的概念，指初始的 _G 表。）</p>
<p>Lua 的作者之一 Roberto Ierusalimschy 同志在介绍 Lua 5.2 时说：</p>
<p>the new scheme, with _ENV, allows the main benefit of setfenv with a little more than syntactic sugar.</p>
<p>就我的理解来说，优点就是原先虚无缥缈只能通过 setfenv、getfenv 访问的所谓「环境」终于实体化为一个始终存在的变量 _ENV 了。</p>
<p>于是以下两个函数内容大致是一样的：</p>
<pre><code>-- Lua 5.1
function foobar()
  setfenv(1, {})
  -- code here
end

-- Lua 5.2
function foobar()
  local _ENV = {}
  -- code here
end
</code></pre><p>而更进一步的是，5.2 中对 load 函数作出了修改。（包括但不限于 :)）合并了 loadstring 功能，并可以在参数中指定所使用的环境表：</p>
<p><code>local func, message = load(code, nil, &#34;t&#34;, env)</code></p>
<h3 id="setfenv"><a href="#setfenv" class="headerlink" title="setfenv"></a>setfenv</h3><p>当我们在全局环境中定义变量时经常会有命名冲突，尤其是在使用一些库的时候，变量声明可能会发生覆盖，这时候就需要一个非全局的环境来解决这问题。setfenv函数可以满足我们的需求。     </p>
<p>　　setfenv(f, table)：设置一个函数的环境     </p>
<p>　　（1）当第一个参数为一个函数时，表示设置该函数的环境    </p>
<p>　　（2）当第一个参数为一个数字时，为1代表当前函数，2代表调用自己的函数，3代表调用自己的函数的函数，以此类推   </p>
<p>　　所谓函数的环境，其实一个环境就是一个表，该函数被限定为只能访问该表中的域，或在函数体内自己定义的变量。下面这个例子，设定当前函数的环境为一个空表，那么在设定执行以后，来自全局的print函数将不可见，所以调用会失败。   </p>
<p>– 一个环境就是一个表，该表记录了新环境能够访问的全部域<br/>newfenv = {}<br/>setfenv(1, newfenv)<br/>print(1)        – attempt to call global `print’ (a nil value)<br/>　　我们可以这样继承已有的域：  </p>
<pre><code>a = 10
newfenv = {_G = _G}
setfenv(1, newfenv)
_G.print(1)        -- 1
_G.print(_G.a)        -- 10
_G.print(a)        -- nil 注意此处是nil，新环境没有a域，但可以通过_G.a访问_G的a域
　　可以看到，新环境中可以访问_G，但有一点就是_G中的所有函数必须手动调用，这样其实很不方便。我们可以使用metatable来对上述代码进行改进：

-- 任何赋值操作都对新表进行，不用担心误操作修改了全局变量表。另外，你仍然可以通过_G修改全局变量：
newfenv = {}
setmetatable(newfenv, {__index = _G})
setfenv(1, newfenv)
print(1)        -- 1 新环境直接继承了全局环境的所有域，好处：可以不需要通过_G来手动调用
</code></pre><p>　　这样，当访问到函数中不存在的变量时，会自动在_G中查找。对于当前函数和_G都存在的变量，可以通过是否用_G显示调用来区分，比如如果有两个a，那么_G.a表示继承来的，a就是当前函数环境的。    </p>
<p>　　另外，可以通过getfenv(f)函数查看函数所处的环境，默认会返回全局环境_G。   </p>