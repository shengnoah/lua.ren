---
layout: post
title: 高并发抢红包方案－－基于Redis lua方案 
tags: [lua文章]
categories: [topic]
---
<script src="assetsjsAPlayer.min.js"> </script><p>Redis 2.6 内置Lua解释器</p>
<ul>
<li>Lua由标准C编写而成，代码简洁优美，完整的Lua解释器不过200k，极易嵌入到其他程序。</li>
<li>Lua和C/C++代码交互容易， 性能和灵活性大大提高。</li>
<li>可作为扩展脚本，也可以作为普通的配置文件，实现复杂的配置逻辑，并且容易理解和维护.</li>
</ul>
<h2 id="Redis–lua脚本"><a href="#Redis–lua脚本" class="headerlink" title="Redis–lua脚本"></a>Redis–lua脚本</h2><ul>
<li>减少网络开销：本来多次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。</li>
<li>原子操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。</li>
<li>脚本复用：客户端发送的脚本会永久存储在Redis中，意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL <span class="string">&#34;return 1+1&#34;</span> 0</span><br/><span class="line">(<span class="built_in">integer</span>) 2</span><br/><span class="line">redis&gt; EVAL <span class="string">&#34;return {KEYS[1], KEYS[2], ARGV[1], ARGV[2]}&#34;</span> 4 <span class="string">&#34;msg&#34;</span> <span class="string">&#34;age&#34;</span> 123 <span class="string">&#34;hello world&#34;</span></span><br/><span class="line">1) <span class="string">&#34;msg&#34;</span> </span><br/><span class="line">2) <span class="string">&#34;age&#34;</span> <span class="comment"># KEYS[2]</span></span><br/><span class="line">3) <span class="string">&#34;123&#34;</span> <span class="comment"># ARGV[1]</span></span><br/><span class="line">4) <span class="string">&#34;hello world&#34;</span> <span class="comment"># ARGV[2]</span></span><br/></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>但是，<code>脚本执行很慢就会影响redis的高响应。</code></p>
<h2 id="redis集群脚本存在的问题"><a href="#redis集群脚本存在的问题" class="headerlink" title="redis集群脚本存在的问题"></a>redis集群脚本存在的问题</h2><p><code>问题</code>：集群对于<code>multi-key</code>操作（即一次RPC调用中需要进行多个key的操作）比如Set类型的交集、并集等，则要求这些key必须属于同一个node。<br/></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment"># There are 16384 hash slots in Redis Cluster.This allows to add an</span></span><br/><span class="line"><span class="comment"># remove nodes in the cluster easily. </span></span><br/><span class="line">Node A contains <span class="built_in">hash</span> slots from 0 to 5500.</span><br/><span class="line">Node B contains <span class="built_in">hash</span> slots from 5501 to 11000.</span><br/><span class="line">Node C contains <span class="built_in">hash</span> slots from 11001 to 16383.</span><br/></pre></td></tr></tbody></table></figure><p></p>
<p><code>解决方案</code>：Hash tags。每个key都可以包含一个自定义的“tags”，那么在存储时将根据tags计算此key应该分布在哪个node上（存储层面仍然是key),比如“foo”和“{foo}.student”将会被保存在同一个node上。</p>
<h1 id="2-抢红包"><a href="#2-抢红包" class="headerlink" title="2. 抢红包"></a>2. 抢红包</h1><ul>
<li>红包操作能够在一次cache请求中完成并返回结果。</li>
<li>数据格式一致，脚本能够复用。<br/>数据结构<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">{</span><br/><span class="line">    rid: 123,</span><br/><span class="line">    uid: 456,</span><br/><span class="line">    money: 789</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h1 id="3-红包"><a href="#3-红包" class="headerlink" title="3. 红包"></a>3. 红包</h1><h1 id="3-相关测试信息"><a href="#3-相关测试信息" class="headerlink" title="3.相关测试信息"></a>3.<a href="http://xiejiangchu.github.io/redis-lua.html">相关测试信息</a></h1>