---
layout: post
title: Lua Future 
tags: [lua文章]
categories: [topic]
---
<h2 id="Future模式："><a href="#Future模式：" class="headerlink" title="Future模式："></a>Future模式：</h2><p>参见<a href="http://www.cnblogs.com/zhiranok/archive/2011/03/26/Future_Pattern.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/zhiranok/archive/2011/03/26/Future_Pattern.html</a></p>
<p>使用future的好处是即利用了异步的并行能力，又保证主逻辑串行执行，保持简单。</p>
<h2 id="Lua-协程"><a href="#Lua-协程" class="headerlink" title="Lua 协程"></a>Lua 协程</h2><p>sina Timyang 的介绍 <a href="http://timyang.net/lua/lua-coroutine/" target="_blank" rel="noopener noreferrer">http://timyang.net/lua/lua-coroutine/</a></p>
<p>lua coroutine 通过create创建一个伪线程，该“线程”通过yield可以挂起自己，通过调用resume可以使该“线程”从挂起位置继续执行。</p>
<h2 id="LUA-coroutine-实现-Future"><a href="#LUA-coroutine-实现-Future" class="headerlink" title="LUA coroutine 实现 Future"></a>LUA coroutine 实现 Future</h2><p>假设有如下应用场景：</p>
<ul>
<li>用户登录系统，需要将用户数据从Mysql中获取用户数据，然后在LUA中实例化user_t对象。</li>
<li>用户登录事件由C++触发，将uid参数传递给lua</li>
<li>lua 并不存在mysql接口，必须委托c++完成mysql操作，而且lua state必须被单线程操作，顾我们期望LUA不能被阻塞，在单个user从mysql 载入数据</li>
</ul>
<p>时其他user应该能够继续接受请求</p>
<p>故我们设计了如下解决方案：</p>
<ol>
<li>lua中的user_t对象每个实例拥有两个主要数据，<br/>a. request_cache，在user未初始化完成时该uid的请求将被缓存起来（我们将请求封装成function）。<br/>b. coroutine ，该协程尝试将request_cache中的所有请求执行完毕，当出现如下情况该协程为挂起自己<br/>　　　　（1）request_cache 为空，挂起等待新的请求<br/>　　　　（2）需要执行mysql时挂起，等待mysql执行完毕被唤醒。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/></pre></td><td class="code"><pre><span class="line"> user_t = {}</span><br/><span class="line"> user_t.<span class="built_in">__index</span> = user_t</span><br/><span class="line"> </span><br/><span class="line"> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br/><span class="line">     <span class="keyword">local</span> funjc = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&#34;TODO exe all request in request_cache&#34;</span>) <span class="keyword">end</span></span><br/><span class="line">     <span class="keyword">local</span> ret =</span><br/><span class="line">     {</span><br/><span class="line">         [<span class="string">&#34;request_cache&#34;</span>] = {},</span><br/><span class="line">         [<span class="string">&#34;coroutine_obj&#34;</span>] = coroutine.<span class="built_in">create</span>(funjc),</span><br/><span class="line">     }</span><br/><span class="line">     <span class="built_in">setmetatable</span>(ret, self)</span><br/><span class="line">     <span class="keyword">return</span> ret</span><br/><span class="line"> <span class="keyword">end</span></span><br/><span class="line">``` </span><br/><span class="line"></span><br/><span class="line"><span class="number">2.</span> C++ 封装异步调用Mysql的接口，注册接口到LUA</span><br/><span class="line"><span class="number">1.</span> future_t 用于LUA和C++传递数据</span><br/><span class="line"></span><br/><span class="line">```cpp</span><br/><span class="line">class future_t</span><br/><span class="line">{</span><br/><span class="line">public:</span><br/><span class="line">　 void   set_result(const <span class="built_in">string</span>&amp; v_) { m_result = v_;   }</span><br/><span class="line">    <span class="built_in">string</span> get_result() const           { <span class="keyword">return</span> m_result; }</span><br/><span class="line">private:</span><br/><span class="line">    <span class="built_in">string</span> m_result;</span><br/><span class="line">};</span><br/></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>async_load_data_from_db 用于异步执行mysql操作</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">async_load_data_from_db</span><span class="params">(<span class="keyword">future_t</span>* ret_)</span></span></span><br/><span class="line"><span class="function"></span>{</span><br/><span class="line">    </span><br/><span class="line">    thread.post(boost::bind(do_load_data_from_db, ret_));    </span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_load_data_from_db</span><span class="params">(<span class="keyword">future_t</span>* ret_)</span></span></span><br/><span class="line"><span class="function"></span>{</span><br/><span class="line">    <span class="comment">//! TODO exe sql opertion</span></span><br/><span class="line">    lua_pcall(<span class="string">&#34;resume_routine&#34;</span>)</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>
<p>lua 调用C++的接口async_load_data_from_db，async_load_data_from_db 将请求post另外的线程，执行mysql请求，将请求结果赋值到future中，调用lua的resume函数唤醒<br/>lua协程继续执行</p>
<ol start="3">
<li>LUA 示例代码</li>
</ol>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/></pre></td><td class="code"><pre><span class="line">user_t = {}</span><br/><span class="line">user_t.<span class="built_in">__index</span> = user_t</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(uid_)</span></span></span><br/><span class="line">    <span class="keyword">local</span> ret =</span><br/><span class="line">    {</span><br/><span class="line">        [<span class="string">&#34;uid&#34;</span>]              = uid_,</span><br/><span class="line">        [<span class="string">&#34;request_cache&#34;</span>] = {},</span><br/><span class="line">        [<span class="string">&#34;coroutine_obj&#34;</span>] = <span class="literal">true</span>,</span><br/><span class="line">        [<span class="string">&#34;runing_flag&#34;</span>]      = <span class="literal">true</span>,</span><br/><span class="line">    }</span><br/><span class="line">    <span class="built_in">setmetatable</span>(ret, self)</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">local</span> func = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> == runing_flag</span><br/><span class="line">            <span class="keyword">if</span> <span class="number">0</span> == #ret.request_cache</span><br/><span class="line">            <span class="keyword">then</span></span><br/><span class="line">                coroutine.<span class="built_in">yield</span>()</span><br/><span class="line">            <span class="keyword">else</span></span><br/><span class="line">                <span class="keyword">local</span> todo_func = ret.request_cache[<span class="number">1</span>]</span><br/><span class="line">                <span class="keyword">local</span> tmp = {}</span><br/><span class="line">                <span class="keyword">for</span> k = <span class="number">2</span>, #ret.request_cache</span><br/><span class="line">                <span class="keyword">do</span></span><br/><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(tmp, ret.request_cache[k])</span><br/><span class="line">                <span class="keyword">end</span></span><br/><span class="line">                ret.request_cache = tmp</span><br/><span class="line">                todo_func()</span><br/><span class="line">            <span class="keyword">end</span></span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    ret.coroutine_obj = coroutine.<span class="built_in">create</span>(func)</span><br/><span class="line">    <span class="keyword">return</span> ret</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user_t:init</span><span class="params">()</span></span></span><br/><span class="line">    <span class="keyword">local</span> func = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br/><span class="line">        <span class="keyword">local</span> future = future_t:new()</span><br/><span class="line">        async_load_data_from_db(future)</span><br/><span class="line">        coroutine.<span class="built_in">yield</span>()</span><br/><span class="line">        <span class="built_in">print</span>(<span class="string">&#34;user_t:init ok&#34;</span>, self.uid, future:get_result())</span><br/><span class="line">        future:delete()</span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(self.request_cache, func)</span><br/><span class="line">    coroutine.<span class="built_in">resume</span>(self.coroutine_obj)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user_t:resume_routine</span><span class="params">()</span></span></span><br/><span class="line">    coroutine.<span class="built_in">resume</span>(self.coroutine_obj)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">local</span> test_user = user_t:new(<span class="number">1122334</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user_login</span><span class="params">()</span></span></span><br/><span class="line">    <span class="keyword">return</span> test_user:init()</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume_routine</span><span class="params">()</span></span></span><br/><span class="line">    <span class="keyword">return</span> test_user:resume_routine()</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>
<ol start="4">
<li>注意事项：<br/>尽管一个lua state是串行执行的，使用lua coroutine时仍然要注意数据一致性，比如在coroutine执行时使用了全局变量，yield挂起后全局变量有可能被修改了，</li>
</ol>
<p>所以协程适合于例子中的user_t对象，各个user是互不干扰的，相同的user请求会被单个协程串行化。</p>