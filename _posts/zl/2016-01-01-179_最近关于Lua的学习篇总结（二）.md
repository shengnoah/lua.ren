---
layout: post
title: 最近关于Lua的学习篇总结（二） 
tags: [lua文章]
categories: [topic]
---
**Contents**

## 1.Lua的介绍

Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de
Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de
Figueiredo所组成并于1993年开发。
其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。Lua
有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。

## 2.使用lua

自行上网下载编写的lua脚本的东西吧

## 3.编程程序

### 3.1永恒的hello world

print(“Hello World”)

### 3.2特殊的小状况

与其他语言不一样的地方  
1.字符串随意用单引号或者多引号  
2.可以没有分号

### 3.3变量

在Lua中定义变量是没有类型的，根据存储什么数据，来决定是什么类型  
变量的命名不能以数字开头  
尽量避免下划线加大写字母开头，这种格式Lua自身保留  
推荐使用C#中的命名规范和驼峰命名

### 3.3.1变量类型

1，nil表示空数据，等同于null  
2，boolean 布尔类型，存储true和false  
3，string 字符串类型，字符串可以用双引号也可以使用单引号表示  
4，number小数类型（Lua中没有整数类型）  
5，table表类型  
myTable = {34,,34,2,342,4}  
myTable[3]  
我们可以使用type()来取得一个变量的类型

### 3.3.2特殊的地方

默认定义的变量都是全局的，定义局部变量需要在前面加一个local；  
在代码块中声明的局部变量，当代码块运行结束的时候，这个变量就会被释放；

### 3.3.3运算符

与其他语言一样，and or not。然而并没有特殊符号表示，就是英文

### 3.3.4流程控制语句

#### 3.3.4.1 if语句

    
    
    1，    if [condition] then
    end
    
    2，    if [condition] then
    else
    end
    
    3，    if [condition] then
    elseif [condition]
    else
    end
    

### 3.3.5循环语句

#### 3.3.5.1 while语句

    
    
    while [condition] do
    end
    

#### 3.3.5.2 repeat语句

    
    
    repeat
        [code to execute]
    until [condition]
    

#### 3.3.5.3 for循环语句

    
    
    for index = [start],[end] do
        [code to execute]
    end
    

循环语句while就是while，repeat相当于do while，for循环入这个，但是还有另外一种对于表的操作的用法，利用的  
for k,v in (ipairs)tablename then  
print(k,v)  
end

### 3.3.6函数

    
    
    function [function name](param1,param2)
        [function code]
    end
    

### 3.3.7lua内置函数

上网可以自由查文档即可

### 3.3.8table表（重点，重中之重）

在Lua中的table类似C#中的字典，其实就是一个 key-value键值对的数据结构。但是也可以类似于C#的数组

1，table的创建  
myTable = {}  
表名后面使用{}赋值，表示一个空的表

2，table的赋值

    
    
    myTable[3]=34  当键是一个数字的时候的赋值方式
    myTable["name"]="seven" 当键是一个字符串的赋值方式
    myTable.name = "seven"当键是一个字符串的赋值方式
    

3，table的访问

    
    
    myTable[3]  当键是数字的时候，只有这一种访问方式
    myTable.name 当键是字符串的时候有两种访问方式
    myTable["name"]
    

4，table的第二种创建方式

    
    
    myTable = {name="seven",age=22,isMan = false}
    （表创建之后依然可以添加数据）
    数据访问
        myTable.name
        myTable["name"]
    

5，table的第三种方式(类似数组的使用)  
myTable = {34,34,34,3,4,”seven”}  
当没有键的时候，编译器会默认给每一个值，添加一个数字的键，该键从1开始  
表的遍历分为两种  
1,如果是只有数字键，并且是连续的可以使用下面的遍历

    
    
    for index = 1,table.getn(myTable) do
        [code to execute]
    end
    
    2，所有的表都可以通过下面的方式遍历
    
    for index,value in pairs(myNames) do
        print(index,value)
    end
    

### 3.3.9通过表来实现面向对象

    
    
    myTable={}  申明对象
    local this = myTable声明this关键字代表当前对象
    

–定义并声明对象中的属性  
myTable.name=”seven”  
myTable.age = 22  
–定义并声明对象中的方法  
myTable.function = function ()  
[code to execute]  
end  
function myTable.function ()  
[code to execute]  
end

### 3.3.10元表

在 Lua table 中我们可以访问对应的key来得到value值，但是却无法对两个 table 进行操作。  
因此 Lua 提供了元表(Metatable)，允许我们改变table的行为，每个行为关联了对应的元方法。  
给一个table关联元表 就是当你访问的这个table所访问的值不存在的时候 会返回默认的元表里的值

可以理解成面向对象里的继承

元表就是它的父类 如果本身有值就用本身的值 没值就用父类的值

1.在表中查找，如果找到，返回该元素，找不到则继续

2.判断该表是否有元表（操作指南），如果没有元表，返回nil，有元表则继续

3.判断元表（操作指南）中有没有关于索引失败的指南（即 **index方法），如果没有（即** index方法为nil），则返回nil；如果
**index方法是一个表，则重复1、2、3；如果** index方法是一个函数，则返回该函数的返回值  
以上均为自我学习作用

参考若干人士。