---
layout: post
title: 作业_4 leetcode 399 Evaluate Division 
tags: [lua文章]
categories: [topic]
---
<h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.</p>
<p>Example:<br/>Given <code>a / b = 2.0, b / c = 3.0.</code><br/>queries are: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .</code><br/>return <code>[6.0, 0.5, -1.0, 1.0, -1.0 ].</code></p>
<p>The input is: <code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries</code> , where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code>vector&lt;double&gt;</code>.</p>
<p>According to the example above:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">equations = [ [&#34;a&#34;, &#34;b&#34;], [&#34;b&#34;, &#34;c&#34;] ],</span><br/><span class="line">values = [2.0, 3.0],</span><br/><span class="line">queries = [ [&#34;a&#34;, &#34;c&#34;], [&#34;b&#34;, &#34;a&#34;], [&#34;a&#34;, &#34;e&#34;], [&#34;a&#34;, &#34;a&#34;], [&#34;x&#34;, &#34;x&#34;] ].</span><br/></pre></td></tr></tbody></table></figure>
<p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目意思大概是给出 <code>a/b=2.0, b/c=3.0</code> 这样的算式，要求求出 <code>a/c</code> 这样的式子的结果，如果不能得出，就返回 <code>-1.0</code></p>
<p>如果直接给出一道这样的题，我可能会感觉没有思路，但是我是从 <strong>Graph</strong> 的标签点进来的，所以自然就想到用 <strong>图</strong> 来解决。从 <code>a/b=2.0, b/c=3.0</code> 建出关系</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">a ---&gt; b ---&gt; c</span><br/><span class="line">  2.0    3.0</span><br/></pre></td></tr></tbody></table></figure>
<p>当计算 <code>a/c</code> 时，则从a开始搜索，直到搜索到c，将搜索路径上边的值相乘，就得到了结果，即 <code>a/c=(a/b)*(b/c)=2.0*3.0=6.0</code></p>
<p>思路上比较简单</p>
<ol>
<li><p>建出图结构，但要建出双向的关系，即对于关系 <code>a/b=2.0</code> ，需要建出下图关系</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">  2.0    3.0</span><br/><span class="line">  ---&gt;   ---&gt;</span><br/><span class="line">a      b      c</span><br/><span class="line">  &lt;---   &lt;---</span><br/><span class="line">  0.5    0.333</span><br/></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用DFS查询关系，如对于 <code>a/c=?</code> ，先找到节点 <code>a</code> 的位置，然后对其进行DFS，直到遇到查询中的另一节点 <code>c</code> ，返回路径上的边的值的乘积</p>
</li>
</ol>
<hr/>
<p>思路是简单，但是实现的时候要注意一些问题，比如DFS不能 “回头”，这一点需要在代码中作出判断，因此递归中还传递了一个 <code>Node *last_node</code> 的参数</p>
<p>而图的构造使用的Node声明，由一个节点名和一个表示有向边的next数组组成</p>
<p>具体代码如下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  {</span></span><br/><span class="line">  <span class="built_in">string</span> name;</span><br/><span class="line">  <span class="built_in">vector</span>&lt;pair&lt;Node*, <span class="keyword">double</span>&gt;&gt; next;</span><br/><span class="line">  Node(<span class="built_in">string</span> t_name, <span class="built_in">vector</span>&lt;pair&lt;Node*, <span class="keyword">double</span>&gt;&gt; t_next = {}) : name(t_name), next(t_next) {}</span><br/><span class="line">};</span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(Node *node, <span class="built_in">string</span> target, <span class="keyword">double</span> ret = <span class="number">1.0</span>, Node *last_node = <span class="literal">NULL</span>)</span> </span>{</span><br/><span class="line">  <span class="keyword">if</span> (node-&gt;name == target) <span class="keyword">return</span> ret;</span><br/><span class="line">  <span class="keyword">if</span> (node-&gt;next.empty()) <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br/><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : node-&gt;next) {</span><br/><span class="line">    <span class="keyword">if</span> (i.first == last_node) <span class="keyword">continue</span>;</span><br/><span class="line">    <span class="keyword">double</span> temp = <span class="number">0.0</span>;</span><br/><span class="line">    temp = dfs(i.first, target, ret * i.second, node);</span><br/><span class="line">    <span class="keyword">if</span> (temp != <span class="number">-1.0f</span>) <span class="keyword">return</span> temp;</span><br/><span class="line">  }</span><br/><span class="line">  <span class="keyword">return</span> <span class="number">-1.0f</span>;</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; calcEquation(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; queries) {</span><br/><span class="line">  <span class="built_in">map</span>&lt;<span class="built_in">string</span>, Node*&gt; name_to_node;</span><br/><span class="line"></span><br/><span class="line">  </span><br/><span class="line">  <span class="keyword">int</span> n = equations.size();</span><br/><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br/><span class="line">    <span class="keyword">if</span> (name_to_node.find(equations[i].first) == name_to_node.end()) name_to_node[equations[i].first] = <span class="keyword">new</span> Node(equations[i].first);</span><br/><span class="line">    <span class="keyword">if</span> (name_to_node.find(equations[i].second) == name_to_node.end()) name_to_node[equations[i].second] = <span class="keyword">new</span> Node(equations[i].second);</span><br/><span class="line"></span><br/><span class="line">    (name_to_node[equations[i].first]-&gt;next).push_back(make_pair(name_to_node[equations[i].second], values[i]));</span><br/><span class="line">    (name_to_node[equations[i].second]-&gt;next).push_back(make_pair(name_to_node[equations[i].first], <span class="number">1.0</span> / values[i]));</span><br/><span class="line">  }</span><br/><span class="line"></span><br/><span class="line">  <span class="comment">// cal queries</span></span><br/><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br/><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> query : queries) {</span><br/><span class="line">    <span class="keyword">if</span> (name_to_node.find(query.first) == name_to_node.end() || name_to_node.find(query.second) == name_to_node.end()) {</span><br/><span class="line">      ret.push_back(<span class="number">-1.0</span>);</span><br/><span class="line">      <span class="keyword">continue</span>;</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    ret.push_back(dfs(name_to_node[query.first], query.second));</span><br/><span class="line">  }</span><br/><span class="line"></span><br/><span class="line">  <span class="comment">// clear</span></span><br/><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> val : name_to_node) {</span><br/><span class="line">    <span class="keyword">delete</span> val.second;</span><br/><span class="line">  }</span><br/><span class="line"></span><br/><span class="line">  <span class="keyword">return</span> ret;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>