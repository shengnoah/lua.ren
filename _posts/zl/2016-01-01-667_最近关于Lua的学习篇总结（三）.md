---
layout: post
title: 最近关于Lua的学习篇总结（三） 
tags: [lua文章]
categories: [topic]
---
<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
		</div>
		
		<h2 id="lua和-Net的相互调用"><a href="#lua和-Net的相互调用" class="headerlink" title="lua和.Net的相互调用"></a>lua和.Net的相互调用</h2><p>由于我们公司主要是用ulua进行热更新，所以不可避免的就是luainterface呢</p>
<h3 id="luainterface"><a href="#luainterface" class="headerlink" title="luainterface"></a>luainterface</h3><p>luainterface包括两个核心库，一个是luainterface.dll,一个是luanet.dll<br/>可以通过luainterface完成lua和C#的相互调用</p>
<h3 id="在C-中执行访问lua代码"><a href="#在C-中执行访问lua代码" class="headerlink" title="在C#中执行访问lua代码"></a>在C#中执行访问lua代码</h3><p>Lua lua = new Lua();    //创建Lua解析器<br/>    lua[“num”]=2;   //定义一个num<br/>    lua[“str”]=”a string”;  //定义一个字符串<br/>    lua.newTable(“tab”);    //创建一个表  tab={}</p>
<h3 id="取得lua环境中的变量"><a href="#取得lua环境中的变量" class="headerlink" title="取得lua环境中的变量"></a>取得lua环境中的变量</h3><p>double num = (double)lua[“num”];</p>
<p>string str = (string)lua[“str”];</p>
<h3 id="在C-中执行Lua脚本文件-或者脚本字符串"><a href="#在C-中执行Lua脚本文件-或者脚本字符串" class="headerlink" title="在C#中执行Lua脚本文件,或者脚本字符串"></a>在C#中执行Lua脚本文件,或者脚本字符串</h3><p>在C#中执行Lua脚本文件,或者脚本字符串<br/>lua.DoFile(“script.lua”);//执行script.lua脚本</p>
<pre><code>lua.DoString(&#34;num=2&#34;);

lua.DoString(&#34;str=&#39;a string&#39;&#34;);

object[] retVals = lua.DoString(&#34;return num,str&#34;);
</code></pre><p>在热更新中，只需要写好解析lua脚本的代码，然后c#代码不需要变动，只需要修改lua脚本就好，通过lua脚本控制游戏逻辑。</p>
<h1 id="lua和C-中类型的对应"><a href="#lua和C-中类型的对应" class="headerlink" title="lua和C#中类型的对应"></a>lua和C#中类型的对应</h1><p>lnil        null</p>
<pre><code>string      System.String

number      System.Double

boolean         System.Boolean

table       LuaInterface.LuaTable

function        LuaInterface.LuaFunction
</code></pre><h1 id="把一个C-方法注册进Lua的一个全局方法"><a href="#把一个C-方法注册进Lua的一个全局方法" class="headerlink" title="把一个C#方法注册进Lua的一个全局方法"></a>把一个C#方法注册进Lua的一个全局方法</h1><p>//把一个类中的普通方法注册进去<br/>lua.RegisterFunction(“NormalMethod”,obj,obj.GetType().GetMethod(“NormalMethod”))<br/>lua.DoString(“ NormalMethod()”);</p>
<p>//把一个类的静态方法注册进去<br/>lua.RegisterFunction(“StaticMethod”,null,typeof(ClassName).GetMethod(“StaticMethod”))<br/>lua.DoString(“ StaticMethod()”)</p>
<h1 id="在Lua中使用c-中的类"><a href="#在Lua中使用c-中的类" class="headerlink" title="在Lua中使用c#中的类"></a>在Lua中使用c#中的类</h1><p>require “luanet”<br/>–加载CLR的类型、实例化CLR对象<br/>luanet.load_assembly(“System.Windows.Forms”)<br/>luanet.load_assembly(“System.Drawing”)<br/>Form = luanet.import_type(“System.Windows.Forms.Form”)<br/>StartPosition = luanet.import_type(“System.Windows.Forms.FormStartPosition”)</p>
<p>print(Form)<br/>print(StartPosition)<br/>在Lua中使用C#中的类创建对象的时候，会自动匹配最合适的构造方法</p>
<h1 id="在Lua中访问C-中的属性和方法"><a href="#在Lua中访问C-中的属性和方法" class="headerlink" title="在Lua中访问C#中的属性和方法"></a>在Lua中访问C#中的属性和方法</h1><p>Lua代码中，访问C#对象的属性的方式和访问table的键索引一样，比如obj.name 或者 obj[“name”]</p>
<p>Lua代码中，访问C#对象的普通函数的方式和调用table的函数一样，比如obj:method1()</p>
<h1 id="在Lua中访问C-中的方法-特殊情况"><a href="#在Lua中访问C-中的方法-特殊情况" class="headerlink" title="在Lua中访问C#中的方法-特殊情况"></a>在Lua中访问C#中的方法-特殊情况</h1><p>当函数中有out或ref参数时，out参数和ref参数和函数的返回值一起返回，并且调用的时候，out参数不需要传入<br/>C#函数定义<br/>class Obj{<br/>int OutMethod1(int parameter1,out parameter2,out parameter3){<br/>    parameter2=34;parameter3=213;<br/>    return parameter1;<br/>}<br/>int OutMethod2(int parameter1,ref parameter2){<br/>    parameter2=parameter2+2;<br/>    return parameter1+parameter2;<br/>}<br/>}<br/>Lua中的调用和返回值<br/>obj:OutMethod1(34)<br/> –out参数不需要参数，这个返回一个table，里面的值为parameter1,parameter2,parameter3<br/>(34,34,213)</p>
<p>obj:OutMethod2(10,10)<br/>–ref参数需要传入，返回一个table有两个值(value1,value2)</p>
<h1 id="在Lua中访问C-中的方法-特殊情况-1"><a href="#在Lua中访问C-中的方法-特殊情况-1" class="headerlink" title="在Lua中访问C#中的方法-特殊情况"></a>在Lua中访问C#中的方法-特殊情况</h1><p>当有重载函数的时候，调用函数会自动匹配第一个能匹配的函数</p>
<p>可以使用get_method_bysig函数得到C#中指定类的指定参数的函数用法<br/>luaMethod = get_method_bysig(Obj,”CSharpMethod”,”System.String”)<br/>                  luaMethod(“siki”)</p>
<h1 id="在Lua中注册C-中的事件委托（event-delegate）"><a href="#在Lua中注册C-中的事件委托（event-delegate）" class="headerlink" title="在Lua中注册C#中的事件委托（event delegate）"></a>在Lua中注册C#中的事件委托（event delegate）</h1><p>在Lua中通过Add方法或者Remove方法把一个Lua的函数注册或者注销从C#中的事件委托中<br/>function method()<br/>end<br/>obj.SomeEvent:Add(methodname(不用带引号))<br/>私人学习笔记而已。</p>