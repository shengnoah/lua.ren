---
layout: post
title: lua 状态机及内存管理 
tags: [lua文章]
categories: [topic]
---

    <p>Lua虚拟机之间的工作是线程安装的，因为一切和虚拟机相关的内存都被关联到虚拟机对象中，没有任何共享变量。Lua允许用户自定义内存管理器，在虚拟机创建时传入，使得使用者对整个运行状态可控。虚拟机的核心部分没有任何的System call。</p>

<h2 id="section">1. 内存管理</h2>

<p>一般我们直接使用：</p>

<pre><code>lua_State *(luaL_newstate) (void);
</code></pre>

<p>来直接创建一个虚拟机。其实这样创建虚拟机，传入虚拟机的内存管理函数是C标准库的内存管理函数，具体如下：</p>

<pre><code>lua_State *luaL_newstate (void) {
  	lua_State *L = lua_newstate(l_alloc, NULL);
  	if (L) lua_atpanic(L, &amp;panic);
  	return L;
}
</code></pre>

<p>luaL_newstate其实是利用lua_newstate实现的，传给lua_newstate的内存管理器这l_alloc，而l_alloc的实现如果：</p>

<pre><code>static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
  	(void)ud; (void)osize;  /* not used */
  	if (nsize == 0) {
	free(ptr);
	return NULL;
  	}
  	else
return realloc(ptr, nsize);
}
</code></pre>

<p>l_alloc是利用C标准库的realloc和free来实现的内存管理器。在这里，用户可以用自己的管理器来代替默认的内存管理器。l_alloc功能上类似于C标准库的realloc，但是当时nsize为0时，提供释放内存的功能。这个内存管理接口接受额外的一个指针ud，这可以让内存管理模块工作在不同的堆上。</p>

<p>lua使用一组宏来管理单个对象、数组、可变长数组等不同类别的内存。定义在lmem.h中：</p>

<pre><code>#define luaM_reallocv(L,b,on,n,e) 
  		(((sizeof(n) &gt;= sizeof(size_t) &amp;&amp; cast(size_t, (n)) + 1 &gt; MAX_SIZET/(e)) 
  	? luaM_toobig(L) : cast_void(0)) , 
   		luaM_realloc_(L, (b), (on)*(e), (n)*(e)))
</code></pre>

   	/*
<pre><code>** Arrays of chars do not need any test
*/
#define luaM_reallocvchar(L,b,on,n)  
	cast(char *, luaM_realloc_(L, (b), (on)*sizeof(char), (n)*sizeof(char)))

#define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
#define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
#define luaM_freearray(L, b, n)   luaM_realloc_(L, (b), (n)*sizeof(*(b)), 0)

#define luaM_malloc(L,s)	luaM_realloc_(L, NULL, 0, (s))
#define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
#define luaM_newvector(L,n,t) 
	cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))

#define luaM_newobject(L,tag,s)	luaM_realloc_(L, NULL, tag, (s))

#define luaM_growvector(L,v,nelems,size,t,limit,e) 
     if ((nelems)+1 &gt; (size)) 
    ((v)=cast(t *, luaM_growaux_(L,v,&amp;(size),sizeof(t),limit,e)))

#define luaM_reallocvector(L, v,oldn,n,t) 
   		((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
</code></pre>

<p>这组宏实际调用luaM_realloc_和luaM_growaux_这两个内部API，它们不会被直接调用。实现如下：</p>

<pre><code>void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
  		void *newblock;
  		global_State *g = G(L);
  		size_t realosize = (block) ? osize : 0;
  		lua_assert((realosize == 0) == (block == NULL));
#if defined(HARDMEMTESTS)
  		if (nsize &gt; realosize &amp;&amp; g-&gt;gcrunning)
		luaC_fullgc(L, 1);  /* force a GC whenever possible */
#endif
  		newblock = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);
  		if (newblock == NULL &amp;&amp; nsize &gt; 0) {
		lua_assert(nsize &gt; realosize);  /* cannot fail when shrinking a block */
		if (g-&gt;version) {  /* is state fully built? */
  		luaC_fullgc(L, 1);  /* try to free some memory... */
  		newblock = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);  /* try again */
		}
		if (newblock == NULL)
  			luaD_throw(L, LUA_ERRMEM);
  		}
  		lua_assert((nsize == 0) == (newblock == NULL));
  		g-&gt;GCdebt = (g-&gt;GCdebt + nsize) - realosize;
  		return newblock;
}
</code></pre>

<p>luaM_realloc_调用保存在global_State中的内存管理器来管理内存。主要工作包括分配新的内存、释放不用的内存、扩展不够用的内存，还有通过realloc试图释放掉申请过大的内存的后半部分（取决于用户提供的内存管理器能不能缩小内存块）。</p>

<pre><code>void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems, int limit, const char *what) {
  	void *newblock;
  	int newsize;
  	if (*size &gt;= limit/2) {  /* cannot double it? */
	if (*size &gt;= limit)  /* cannot grow even a little? */
  		luaG_runerror(L, "too many %s (limit is %d)", what, limit);
	newsize = limit;  /* still have at least one free place */
  	}
  	else {
	newsize = (*size)*2;
	if (newsize &lt; MINSIZEARRAY)
  	newsize = MINSIZEARRAY;  /* minimum size */
  	}
  	newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
  	*size = newsize;  /* update only when everything else is OK */
  	return newblock;
}
</code></pre>

<p>luaM_growaux_是用来管理可变长数组的。其主要策略是当数组空间不够时，扩大为原来的两倍。</p>

<h2 id="section-1">2. 全局状态机</h2>

<p>global_State对于lua使用者是不可见的，无法用公开的API取到它的指针，也不需要引用它。global_State里面有对主线程的引用，有注册表管理所有全局数据，有全局字符串表，有内存管理函数，GC相关的信息以及一切lua工作时需要的工作内存。</p>

<p>创建一个新的lua虚拟机时，第一块申请的内存将用来保存主线程和这个全局状态机。利用一个LG结构，把主线程lua_Statet和global_State分配在一起。具体如下：</p>

<pre><code>/*
** thread state + extra space
*/
typedef struct LX {
  	lu_byte extra_[LUA_EXTRASPACE];
  	lua_State l;
} LX;


/*
** Main thread combines a thread state and the global state
*/
typedef struct LG {
  	LX l;
  	global_State g;
} LG;
</code></pre>

<p>lua_newstate初始化所有global_State中将引用的数据。lua_newstate()利用用户传进来的内存分配器分配主线程和global_State的内存，然后把内存分配器赋给global_State的frealloc来管理虚拟机内在的所有内存。把主线程和global_State关联上以及处理GC等相关的初始化。下面看一下它的具体实现：</p>

<pre><code>lua_State *lua_newstate (lua_Alloc f, void *ud) {
  	int i;
  	lua_State *L;
  	global_State *g;
  	LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
  	if (l == NULL) return NULL;
  	L = &amp;l-&gt;l.l;
  	g = &amp;l-&gt;g;
  	L-&gt;next = NULL;
 	L-&gt;tt = LUA_TTHREAD;
  	g-&gt;currentwhite = bitmask(WHITE0BIT);
  	L-&gt;marked = luaC_white(g);
  	preinit_thread(L, g);
  	g-&gt;frealloc = f;
  	g-&gt;ud = ud;
  	g-&gt;mainthread = L;
  	g-&gt;seed = makeseed(L);
  	g-&gt;gcrunning = 0;  /* no GC while building state */
  	g-&gt;GCestimate = 0;
  	g-&gt;strt.size = g-&gt;strt.nuse = 0;
  	g-&gt;strt.hash = NULL;
  	setnilvalue(&amp;g-&gt;l_registry);
  	luaZ_initbuffer(L, &amp;g-&gt;buff);
  	g-&gt;panic = NULL;
  	g-&gt;version = NULL;
  	g-&gt;gcstate = GCSpause;
  	g-&gt;gckind = KGC_NORMAL;
  	g-&gt;allgc = g-&gt;finobj = g-&gt;tobefnz = g-&gt;fixedgc = NULL;
  	g-&gt;sweepgc = NULL;
  	g-&gt;gray = g-&gt;grayagain = NULL;
  	g-&gt;weak = g-&gt;ephemeron = g-&gt;allweak = NULL;
  	g-&gt;twups = NULL;
  	g-&gt;totalbytes = sizeof(LG);
  	g-&gt;GCdebt = 0;
  	g-&gt;gcfinnum = 0;
  	g-&gt;gcpause = LUAI_GCPAUSE;
  	g-&gt;gcstepmul = LUAI_GCMUL;
  	for (i=0; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = NULL;
  	if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
	/* memory allocation error: free partial state */
	close_state(L);
	L = NULL;
  	}
  	return L;
}
</code></pre>

<p>下面主要看f_luaopen()，此函数主要初始化了主线程的数据栈、初始化注册表、初始化字符串表和字符串cache、初始化元表用的字符串、初始化词法分析用的token串等等。由于初始化中会分配内存，有可能会引起内存错误。在lua_newstate中把g-&gt;version = NULL，在f_luaopen()中把所有的初始化完成后，如果没有错误才给版本号赋值g-&gt;version = lua_version(NULL)。我们通过’g-&gt;version’ != NULL来检测虚拟机是否正确建立起来。</p>

<pre><code>/*
** open parts of the state that may cause memory-allocation errors.
** ('g-&gt;version' != NULL flags that the state was completely build)
*/
static void f_luaopen (lua_State *L, void *ud) {
global_State *g = G(L);
UNUSED(ud);
  	stack_init(L, L);  /* init stack */
  	init_registry(L, g);
  	luaS_init(L);
  	luaT_init(L);
  	luaX_init(L);
  	g-&gt;gcrunning = 1;  /* allow gc */
  	g-&gt;version = lua_version(NULL);
  	luai_userstateopen(L);
}
</code></pre>