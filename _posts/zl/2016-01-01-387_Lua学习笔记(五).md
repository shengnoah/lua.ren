---
layout: post
title: Lua学习笔记(五) 
tags: [lua文章]
categories: [topic]
---
<ul>
<li><a href="#错误处理">错误处理</a><ul>
<li><a href="#assert">assert</a></li>
<li><a href="#error">error</a></li>
<li><a href="#pcall">pcall</a></li>
<li><a href="#xpcall">xpcall</a></li>
<li><a href="#debug">debug</a></li>
</ul>
</li>
<li><a href="#调试">调试</a></li>
<li><a href="#垃圾回收">垃圾回收</a><ul>
<li><a href="#垃圾回收函数">垃圾回收函数</a></li>
</ul>
</li>
</ul>

<h2><span id="错误处理">错误处理</span></h2><p>平时写代码的时候出现错误其实是一件十分平常的事情，自然，如何处理错误也是需要联系的方法。</p>
<p>一般在Lua中可以使用<strong>assert</strong>和<strong>error</strong>来处理错误。</p>
<h3><span id="assert">assert</span></h3><p>简单实例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line">local function add(a,b)</span><br/><span class="line">    assert(type(a)==&#34;number&#34;,&#34;a不是数字&#34;)</span><br/><span class="line">    assert(type(b)==&#34;number&#34;,&#34;b不是数字&#34;)</span><br/><span class="line">    return a+b</span><br/><span class="line">end</span><br/><span class="line">add(10)</span><br/></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<p><img src="https://thbelief.github.io//2019/04/29/Lua学习笔记-五/assert输出.jpg" alt=""/></p>
<p>在这个过程中，assert先检查第一个参数，如果没问题什么也不做，如果有问题的话，就把第二个参数作为错误信息抛出来。</p>
<h3><span id="error">error</span></h3><p>语法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">error (message [, level])</span><br/></pre></td></tr></tbody></table></figure>
<p>error的功能主要就是<strong>终止在执行的函数，</strong>同时返回message的内容作为错误信息（error永远不会返回），一般情况就是，error附加一些错误位置的信息到message的头部。</p>
<p>level参数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">Level=1[默认]：为调用error位置(文件+行号)</span><br/><span class="line">Level=2：指出哪个调用error的函数的函数</span><br/><span class="line">Level=0:不添加错误位置信息</span><br/></pre></td></tr></tbody></table></figure>
<h3><span id="pcall">pcall</span></h3><p>Lua中处理错误，可以使用<strong>函数pcall（protected call）来包装需要执行的代码。</strong></p>
<p><strong>pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo。</strong></p>
<p>语法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">if pcall(function_name, ….) then</span><br/><span class="line">-- 没有错误</span><br/><span class="line">else</span><br/><span class="line">-- 一些错误</span><br/><span class="line">end</span><br/></pre></td></tr></tbody></table></figure>
<p>值得注意的是，由于pcall是使用<strong>保护模式</strong>来调用第一个参数，所以可以捕获函数中执行时所有的错误。</p>
<h3><span id="xpcall">xpcall</span></h3><p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经<strong>销毁了调用桟的部分内容。</strong></p>
<p>Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取<strong>关于错误的额外信息</strong>了。</p>
<h3><span id="debug">debug</span></h3><p>debug库提供的两个方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">debug.debug：提供一个Lua提示符，让用户来检查错误的原因</span><br/><span class="line">debug.traceback：根据调用桟来构建一个扩展的错误消息</span><br/></pre></td></tr></tbody></table></figure>
<h2><span id="调试">调试</span></h2><p><strong>Lua中提供了debug库用于用户自定义调试器。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1.</td>
<td style="text-align:left"><strong>debug():</strong>进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。  输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。</td>
</tr>
<tr>
<td style="text-align:left">2.</td>
<td style="text-align:left"><strong>getfenv(object):</strong>返回对象的环境变量。</td>
</tr>
<tr>
<td style="text-align:left">3.</td>
<td style="text-align:left"><strong>gethook(optional thread):</strong>返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数</td>
</tr>
<tr>
<td style="text-align:left">4.</td>
<td style="text-align:left"><strong>getinfo ([thread,] f [, what]):</strong>返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。</td>
</tr>
<tr>
<td style="text-align:left">5.</td>
<td style="text-align:left"><strong>debug.getlocal ([thread,] f, local):</strong>此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。</td>
</tr>
<tr>
<td style="text-align:left">6.</td>
<td style="text-align:left"><strong>getmetatable(value):</strong>把给定索引指向的值的元表压入堆栈。如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西。</td>
</tr>
<tr>
<td style="text-align:left">7.</td>
<td style="text-align:left"><strong>getregistry():</strong>返回注册表表，这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。</td>
</tr>
<tr>
<td style="text-align:left">8.</td>
<td style="text-align:left"><strong>getupvalue (f, up)</strong>此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。  以 ‘(‘ （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）。</td>
</tr>
<tr>
<td style="text-align:left">10.</td>
<td style="text-align:left"><strong>sethook ([thread,] hook, mask [, count]):</strong>将一个函数作为钩子函数设入。 字符串 mask 以及数字 count 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义：<strong>‘c’:</strong> 每当 Lua 调用一个函数时，调用钩子；<strong>‘r’:</strong> 每当 Lua 从一个函数内返回时，调用钩子；<strong>‘l’:</strong> 每当 Lua 进入新的一行时，调用钩子。</td>
</tr>
<tr>
<td style="text-align:left">11.</td>
<td style="text-align:left"><strong>setlocal ([thread,] level, local, value):</strong>这个函数将 value 赋给 栈上第 level 层函数的第 local 个局部变量。 如果没有那个变量，函数返回 nil 。 如果 level 越界，抛出一个错误。</td>
</tr>
<tr>
<td style="text-align:left">12.</td>
<td style="text-align:left"><strong>setmetatable (value, table):</strong>将 value 的元表设为 table （可以是 nil）。 返回 value。</td>
</tr>
<tr>
<td style="text-align:left">13.</td>
<td style="text-align:left"><strong>setupvalue (f, up, value):</strong>这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。</td>
</tr>
<tr>
<td style="text-align:left">14.</td>
<td style="text-align:left"><strong>traceback ([thread,] [message [, level]]):</strong>如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。 否则，它返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。</td>
</tr>
</tbody>
</table>
<h2><span id="垃圾回收">垃圾回收</span></h2><p>Lua中有<strong>自动内存管理</strong>功能，不需要主动释放内存，十分的方便。</p>
<p>Lua 运行了一个<strong>垃圾收集器</strong>来收集所有<strong>死对象</strong> （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。</p>
<h3><span id="垃圾回收函数">垃圾回收函数</span></h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line">collectgarbage(&#34;collect&#34;): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</span><br/><span class="line"></span><br/><span class="line">collectgarbage(&#34;count&#34;): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</span><br/><span class="line"></span><br/><span class="line">collectgarbage(&#34;restart&#34;): 重启垃圾收集器的自动运行。</span><br/><span class="line"></span><br/><span class="line">collectgarbage(&#34;setpause&#34;): 将 arg 设为收集器的 间歇率 （参见 §2.5）。 返回 间歇率 的前一个值。</span><br/><span class="line"></span><br/><span class="line">collectgarbage(&#34;setstepmul&#34;): 返回 步进倍率 的前一个值。</span><br/><span class="line"></span><br/><span class="line">collectgarbage(&#34;step&#34;): 单步运行垃圾收集器。 步长&#34;大小&#34;由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</span><br/><span class="line"></span><br/><span class="line">collectgarbage(&#34;stop&#34;): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。</span><br/></pre></td></tr></tbody></table></figure>
<p>简单实例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line">--这是一个简单的垃圾回收实例</span><br/><span class="line">array={&#34;hello&#34;,&#34;world&#34;,&#34;thbelief&#34;}</span><br/><span class="line"></span><br/><span class="line">print(collectgarbage(&#34;count&#34;))</span><br/><span class="line"></span><br/><span class="line">array=nil</span><br/><span class="line"></span><br/><span class="line">print(collectgarbage(&#34;count&#34;))</span><br/><span class="line"></span><br/><span class="line">print(collectgarbage(&#34;collect&#34;))</span><br/><span class="line"></span><br/><span class="line">print(collectgarbage(&#34;count&#34;))</span><br/></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<p><img src="https://thbelief.github.io//2019/04/29/Lua学习笔记-五/垃圾回收.jpg" alt=""/></p>