---
layout: post
title: Lua 学习 chapter7  
tags: [lua文章]
categories: [topic]
---
<h3 id="目录">目录</h3>
<ol>
  <li>简单I/O模型</li>
  <li>完整I/O模型</li>
  <li>其它文件操作</li>
  <li>其它系统调用</li>
</ol>

<blockquote>
  <p>I want to have a talk with you my heart.</p>
</blockquote>

<h2 id="简单io模型">简单I/O模型</h2>

<p>对于文件操作，I/O提供了两种不同的模型。简单模型虚拟了一个当前输入流和一个当前的输出流，其I/O是通过这些流实现的。</p>

<p>I/O库把当前的输入流初始化为进程的标准输入(C中的stdin),将当前的输出流初始化进程的标准输出(C中的stdout)。因此当执行io.read()这样的语句的时候就可以从标准的输入中读取一行。</p>

<p>函数的io.input和函数io.output用来改变当前的输入输出流。</p>

<p>io.input(fileName)会以只读的方式打开指定的文件，并将文件设置为当前的输入流。之后所有的输入都将来自于这个文件，除非重新调用io.input函数来改变。对于输出与之类似。</p>

<p><strong>函数write()</strong>:</p>

<p>由于调用该函数可以传入多个参数，所以应该避免使用io.write(a..b..b),而是使用write(a,b,c)。</p>

<p>作为原则应该只在用后<strong>即弃</strong>的代码或者调试代码的时候调用print输出，当需要完全控制输出是，应该使用io.write()输出，和print不同，</p>

<p>函数io.write最终的输出不会添加诸如制表符或者换行符这样的额外内容。</p>

<p>此外函数io.write允许对输出进行重定向，而函数print只能使用标准输出。函数print会为其参数调用tostring函数。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nb">io.write</span><span class="p">(</span><span class="s2">&#34;sin(3)=&#34;</span><span class="p">,</span><span class="nb">math.sin</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="s2">&#34;</span><span class="se">n</span><span class="s2">&#34;</span><span class="p">)</span> <span class="c1">-- &gt;sin(3) = 0.1411200080</span>
<span class="nb">io.write</span><span class="p">(</span><span class="nb">string.format</span><span class="p">(</span><span class="s2">&#34;sin(3)=%.4fn&#34;</span><span class="p">,</span><span class="nb">math.sin</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span> <span class="c1">-- &gt;sin(3) = 0.1411</span>

<span class="nb">io.read</span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">)</span> <span class="c1">--&gt;从当前位置开始的读取当前输入文件的全部内容</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>函数io.read可以从当前的输入流中读取字符串，其参数决定了其要读取的数据：</p>

<ol>
  <li>“a”  读取整个文件</li>
  <li>“l”  读取下一行 （丢弃换行符）  默认参数</li>
  <li>“L”  读取下一行（保留换行符）</li>
  <li>“n”  读取一个数值(number 类型)</li>
  <li>num  以字符串读取num个字符</li>
</ol>

<p>获取一个文件的所有行数可以使用 io.lines() 函数</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kd">local</span> <span class="n">lines</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="nb">io.lines</span><span class="p">()</span> <span class="k">do</span>
    <span class="n">lines</span><span class="p">[</span><span class="o">#</span><span class="n">lines</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
<span class="k">end</span>

<span class="nb">table.sort</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">do</span>
    <span class="nb">io.write</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&#34;</span><span class="se">n</span><span class="s2">&#34;</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>io.write(n) 从当前的输入流中最多读取n个字符，如果没有字符返回nil,io.write(0)是一个特烈，它常用于测试是否达到了文件末尾。如果仍然有数据可供读取，他就会返回一个空字符串，否则返回nil。</p>

<h2 id="完整io模型">完整I/O模型</h2>

<p>可以使用io.open来打开一个文件。该函数拥有两个参数，一个是文件名，一个是打开的模式。</p>

<blockquote>
  <p>file = io.open (filename [, mode])</p>
</blockquote>

<ol>
  <li>“r”  只读</li>
  <li>“w”  只写(可以用来删除文件中原来的内容)</li>
  <li>“a”  追加,以附加的方式打开只写文件。</li>
  <li>“b”  打开二进制文件</li>
  <li>“r+” 以可读写方式打开文件，该文件必须存在。</li>
  <li>“w+” 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</li>
  <li>“a+” 与a类似，但此文件可读可写</li>
  <li>”+” 	表示对文件既可以读也可以写</li>
</ol>

<p>io.open函数打开发生错的时候会返回两个值，一个是nil另一个是系统相关错误的错误码.</p>

<p>当然我们在打开文件之后，如果要从这个文件中读写内容，需要使用这个文件流重新设置输入输出流。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="c1">-- 以只读方式打开文件</span>
<span class="n">file</span> <span class="o">=</span> <span class="nb">io.open</span><span class="p">(</span><span class="s2">&#34;test.lua&#34;</span><span class="p">,</span> <span class="s2">&#34;r&#34;</span><span class="p">)</span>

<span class="c1">-- 设置默认输入文件为 test.lua</span>
<span class="nb">io.input</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

<span class="c1">-- 输出文件第一行</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">io.read</span><span class="p">())</span>

<span class="c1">-- 关闭打开的文件</span>
<span class="nb">io.close</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

<span class="c1">-- 以附加的方式打开只写文件</span>
<span class="n">file</span> <span class="o">=</span> <span class="nb">io.open</span><span class="p">(</span><span class="s2">&#34;test.lua&#34;</span><span class="p">,</span> <span class="s2">&#34;a&#34;</span><span class="p">)</span>

<span class="c1">-- 设置默认输出文件为 test.lua</span>
<span class="nb">io.output</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

<span class="c1">-- 在文件最后一行添加 Lua 注释</span>
<span class="nb">io.write</span><span class="p">(</span><span class="s2">&#34;--  test.lua 文件末尾注释&#34;</span><span class="p">)</span>

<span class="c1">-- 关闭打开的文件</span>
<span class="nb">io.close</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>检测错误的一种典型方法是使用函数assert:</p>

<p>local f = assert(io.open(fileName,mode))  发生错的时候错误信息会作为函数assert的第二个餐宿被传入。 然后assert会将错误信息展示出来。</p>

<p>文件打开之后可以使用从流中读取和写入。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">local</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">assert</span><span class="p">(</span><span class="nb">io.open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="s2">&#34;r&#34;</span><span class="p">))</span>
<span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="n">f</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">)</span>
<span class="n">f</span><span class="p">:</span><span class="n">close</span><span class="p">()</span>
<span class="c1">-- io.stdin, io.stdout, io.stderr</span>
<span class="nb">io.stderr</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Io库提供了三个预定义的C语言流的句柄，可以直接调用。</p>

<p>可以通过io.input 和 io.output 来改变的当前的输入输出流</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">local</span> <span class="n">temp</span> <span class="o">=</span> <span class="nb">io.input</span><span class="p">()</span>
<span class="nb">io.input</span><span class="p">(</span><span class="s2">&#34;newInput&#34;</span><span class="p">)</span>
<span class="c1">--对新的输入流进行操作</span>
<span class="nb">io.input</span><span class="p">():</span><span class="n">close</span>
<span class="nb">io.input</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>  <span class="c1">--恢复之前的输入流</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>注意：</strong> io.read(args) 实际上是io.input():read(args)，同样的io.write(args)和io.output():write(args)的简写。</p>

<p>io.lines() 函数可以带参数，filename,读取文件中的内容，不带参数就是从当前输入流中读，现在次函数还可以接收像read函数一样的参数。</p>

<h2 id="其他文件操作">其他文件操作</h2>
<p>io.tmpfile返回一个操作临时文件的句柄，该句柄是以读写模式打开的，当程序运行完成后，该句柄就会被回收。</p>

<p>函数flush将所有的缓冲数据写入到文件中。与函数write一样，我们也可以把它当作io.flush()使用，以刷新当前的输出流，或者f:flush()，用来刷新当前流。</p>

<p>函数setvbuf用于设置流的缓冲模式。</p>

<ol>
  <li>“no” 不缓冲</li>
  <li>“full” 缓冲区满或者显示刷新文件时才写入数据</li>
  <li>“line” 遇到换行符或从特定文件中读到了数据</li>
</ol>

<p>对于后面两个模式，可以跟第二个参数来设置缓冲区大小。</p>

<p>一般情况下:io.stderr 是不缓冲的，io.stdout是按行缓冲的。</p>

<p>函数seek用来获取和设置文件当前位置。常使用f:seek(whence,offset)的形式来调用。whence有一下三种模式：</p>

<ol>
  <li>“set”  文件开头</li>
  <li>“cur”  文件当前位置</li>
  <li>“end”  文件结尾</li>
</ol>

<p>偏移是以字节为单位的。</p>

<p>whence默认值为”cur”,offset的默认值是0。file:seek() 返回当前位置且不改变当前位置。file:seek(“set”)会将位置重置到文件开头并返回0，file:seek(“end”)会将文件当前位置重置到文件结尾，并返回文件的大小。</p>

<p>os.rename改变文件名字 os.remove删除文件。</p>

<h2 id="其它系统调用">其它系统调用</h2>

<p>os.exit用于终止程序的执行。</p>

<p>os.getev用于获取环境变量。</p>

<p>os.execute用来运行系统命令，等价于c中的system。还用io.popen也是运行一条系统命令,但是该函数可以重定向命令的输入输出流。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">function</span> <span class="nf">create</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
	<span class="nb">os.execute</span><span class="p">(</span><span class="s2">&#34;mkdir &#34;</span><span class="o">...</span><span class="n">dirname</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">io.popen</span><span class="p">(</span><span class="s2">&#34;dir /B&#34;</span><span class="p">,</span><span class="s2">&#34;r&#34;</span><span class="p">)</span> <span class="c1">-- 只读</span>
<span class="kd">local</span> <span class="n">dir</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">entry</span> <span class="k">in</span> <span class="n">f</span><span class="p">:</span><span class="n">lines</span><span class="p">()</span> <span class="k">do</span>
	<span class="n">dir</span><span class="p">[</span><span class="o">#</span><span class="n">dir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div></div>



                <hr style="visibility: hidden;"/>
                
                <hr style="visibility: hidden;"/>