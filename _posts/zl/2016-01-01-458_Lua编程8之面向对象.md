---
layout: post
title: Lua编程8之面向对象 
tags: [lua文章]
categories: [topic]
---
<p>思考并回答以下问题：<br/>1.如何创建一个空表？</p>


<p>之前学习了table，Lua中table很重要的一个功能就是实现面向对象的架构。因为lua本身并不是面向对象的语言，但是通过table可以实现。</p>
<p>面向对象编程（Object Oriented Programming，OOP）是一种非常流行的计算机编程架构。</p>
<p>以下几种编程语言都支持面向对象编程：C# C++ Java Objective-C Ruby</p>
<h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a><span style="color:#EF7060;">面向对象特征</span></h2><p>1）** <span style="color:red">封装</span> ** ：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。</p>
<p>2）** <span style="color:red">继承</span> ** ：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。</p>
<p>3）** <span style="color:red">多态</span> ** ：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</p>
<p>4）** <span style="color:red">抽象</span> ** ：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。</p>
<h2 id="Lua-中面向对象"><a href="#Lua-中面向对象" class="headerlink" title="Lua 中面向对象"></a><span style="color:#EF7060;">Lua 中面向对象</span></h2><p>我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。</p>
<p>lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。</p>
<p>Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。</p>
<p>但是如果直接使用table仍然会存在大量的问题，见如下代码：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line">Account = {balance = <span class="number">0</span>}</span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(v)</span></span></span><br/><span class="line">    Account.balance = Account.balance - v</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line">Account.withdraw(<span class="number">100.00</span>)</span><br/></pre></td></tr></tbody></table></figure>

<p>在上面的withdraw函数内部依赖了全局变量Account，一旦该变量发生改变，将会导致withdraw不再能正常的工作，如：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">a = Account; Account = <span class="literal">nil</span></span><br/><span class="line">a.withdraw(<span class="number">100.00</span>)  <span class="comment">--将会导致访问空nil的错误。</span></span><br/></pre></td></tr></tbody></table></figure>

<p>这种行为明显的违反了面向对象封装性和实例独立性。要解决这一问题，我们需要给withdraw函数在添加一个参数self，等价于C#中的this，见如下修改：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(self, v)</span></span></span><br/><span class="line">    self.balance = self.balance - v</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"><span class="comment">--下面是基于修改后代码的调用：</span></span><br/><span class="line">a1 = Account</span><br/><span class="line">Account = <span class="literal">nil</span></span><br/><span class="line">a1.withdraw(a1, <span class="number">100.00</span>) <span class="comment">--正常工作</span></span><br/></pre></td></tr></tbody></table></figure>

<p>针对上述问题，Lua提供了一种更为便利的语法，即将点(.)替换为冒号(:)，这样可以在定义和调用时均隐藏self参数，如:</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:withdraw</span><span class="params">(v)</span></span></span><br/><span class="line">    self.balance = self.balance - v</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"><span class="comment">--调用代码可改为：</span></span><br/><span class="line">a:withdraw(<span class="number">100.00</span>)</span><br/></pre></td></tr></tbody></table></figure>

<p>** <span style="color:red">一个简单实例</span> **<br/>以下简单的类包含了三个属性： area, length 和 breadth，printArea方法用于打印计算结果：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Meta class</span></span><br/><span class="line">Rectangle = {area = <span class="number">0</span>, length = <span class="number">0</span>, breadth = <span class="number">0</span>}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 派生类的方法 new</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle:new</span> <span class="params">(o,length,breadth)</span></span></span><br/><span class="line">    o = o <span class="keyword">or</span> {}</span><br/><span class="line">    <span class="built_in">setmetatable</span>(o, self)</span><br/><span class="line">    self.<span class="built_in">__index</span> = self</span><br/><span class="line">    self.length = length <span class="keyword">or</span> <span class="number">0</span></span><br/><span class="line">    self.breadth = breadth <span class="keyword">or</span> <span class="number">0</span></span><br/><span class="line">    self.area = length*breadth;</span><br/><span class="line">    <span class="keyword">return</span> o</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 派生类的方法 printArea</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle:printArea</span> <span class="params">()</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;矩形面积为 &#34;</span>,self.area)</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>

<p>** 创建对象 **</p>
<p>创建对象是为类的实例分配内存的过程。每个类都有属于自己的内存并共享公共数据。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">r = Rectangle:new(<span class="literal">nil</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br/></pre></td></tr></tbody></table></figure>

<p>内存在对象初始化时分配。</p>
<p>** 访问属性 **<br/>我们可以使用点号(.)来访问类的属性：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(r.length)</span><br/></pre></td></tr></tbody></table></figure>

<p>** 访问成员函数 **<br/>我们可以使用冒号 : 来访问类的成员函数：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">r:printArea()</span><br/></pre></td></tr></tbody></table></figure>

<p>** <span style="color:red">完整实例</span> **<br/>以下我们演示了 Lua 面向对象的完整实例：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Meta class</span></span><br/><span class="line">Shape = {area = <span class="number">0</span>}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 基础类方法 new</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:new</span> <span class="params">(o,side)</span></span></span><br/><span class="line">    o = o <span class="keyword">or</span> {}</span><br/><span class="line">    <span class="built_in">setmetatable</span>(o, self)</span><br/><span class="line">    self.<span class="built_in">__index</span> = self</span><br/><span class="line">    side = side <span class="keyword">or</span> <span class="number">0</span></span><br/><span class="line">    self.area = side*side;</span><br/><span class="line">    <span class="keyword">return</span> o</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 基础类方法 printArea</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:printArea</span> <span class="params">()</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;面积为 &#34;</span>,self.area)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 创建对象</span></span><br/><span class="line">myshape = Shape:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br/><span class="line"></span><br/><span class="line">myshape:printArea()</span><br/></pre></td></tr></tbody></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">面积为     100</span><br/></pre></td></tr></tbody></table></figure>

<p>** <span style="color:red">Lua 继承</span> **<br/>继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。</p>
<p>以下演示了一个简单的继承实例：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- Meta class</span></span><br/><span class="line">Shape = {area = <span class="number">0</span>}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 基础类方法 new</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:new</span> <span class="params">(o,side)</span></span></span><br/><span class="line">    o = o <span class="keyword">or</span> {}</span><br/><span class="line">    <span class="built_in">setmetatable</span>(o, self)</span><br/><span class="line">    self.<span class="built_in">__index</span> = self</span><br/><span class="line">    side = side <span class="keyword">or</span> <span class="number">0</span></span><br/><span class="line">    self.area = side*side;</span><br/><span class="line">    <span class="keyword">return</span> o</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 基础类方法 printArea</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:printArea</span> <span class="params">()</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;面积为 &#34;</span>,self.area)</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>

<p>接下来的实例，Square 对象继承了 Shape 类:</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line">Square = Shape:new()</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 派生类的new方法</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square:new</span> <span class="params">(o,side)</span></span></span><br/><span class="line">    o = o <span class="keyword">or</span> Shape:new(o,side)</span><br/><span class="line">    <span class="built_in">setmetatable</span>(o, self)</span><br/><span class="line">    self.<span class="built_in">__index</span> = self</span><br/><span class="line">    <span class="keyword">return</span> o</span><br/><span class="line"><span class="keyword">end</span></span><br/></pre></td></tr></tbody></table></figure>

<p>** 完整实例 **<br/>以下实例我们继承了一个简单的类，来扩展派生类的方法，派生类中保留了继承类的成员变量和方法：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- Meta class</span></span><br/><span class="line">Shape = {area = <span class="number">0</span>}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 基础类方法 new</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:new</span> <span class="params">(o,side)</span></span></span><br/><span class="line">    o = o <span class="keyword">or</span> {}</span><br/><span class="line">    <span class="built_in">setmetatable</span>(o, self)</span><br/><span class="line">    self.<span class="built_in">__index</span> = self</span><br/><span class="line">    side = side <span class="keyword">or</span> <span class="number">0</span></span><br/><span class="line">    self.area = side*side;</span><br/><span class="line">    <span class="keyword">return</span> o</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 基础类方法 printArea</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:printArea</span> <span class="params">()</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;面积为 &#34;</span>,self.area)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 创建对象</span></span><br/><span class="line">myshape = Shape:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br/><span class="line">myshape:printArea()</span><br/><span class="line"></span><br/><span class="line">Square = Shape:new()</span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 派生类方法 new</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square:new</span> <span class="params">(o,side)</span></span></span><br/><span class="line">    o = o <span class="keyword">or</span> Shape:new(o,side)</span><br/><span class="line">    <span class="built_in">setmetatable</span>(o, self)</span><br/><span class="line">    self.<span class="built_in">__index</span> = self</span><br/><span class="line">    <span class="keyword">return</span> o</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 派生类方法 printArea</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square:printArea</span> <span class="params">()</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;正方形面积为 &#34;</span>,self.area)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 创建对象</span></span><br/><span class="line">mysquare = Square:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br/><span class="line">mysquare:printArea()</span><br/><span class="line"></span><br/><span class="line">Rectangle = Shape:new()</span><br/><span class="line"><span class="comment">-- 派生类方法 new</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle:new</span> <span class="params">(o,length,breadth)</span></span></span><br/><span class="line">    o = o <span class="keyword">or</span> Shape:new(o)</span><br/><span class="line">    <span class="built_in">setmetatable</span>(o, self)</span><br/><span class="line">    self.<span class="built_in">__index</span> = self</span><br/><span class="line">    self.area = length * breadth</span><br/><span class="line">    <span class="keyword">return</span> o</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 派生类方法 printArea</span></span><br/><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle:printArea</span> <span class="params">()</span></span></span><br/><span class="line">    <span class="built_in">print</span>(<span class="string">&#34;矩形面积为 &#34;</span>,self.area)</span><br/><span class="line"><span class="keyword">end</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">-- 创建对象</span></span><br/><span class="line">myrectangle = Rectangle:new(<span class="literal">nil</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br/><span class="line">myrectangle:printArea()</span><br/></pre></td></tr></tbody></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">面积为     100</span><br/><span class="line">正方形面积为     100</span><br/><span class="line">矩形面积为     200</span><br/></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span style="color:#039BE5;">总结</span></h1><p>刚刚学习了如何在lua中通过table模拟面向对象编程。Lua中的继承虽然可以通过metetable模拟出来，但是不推荐用，只模拟最基本的对象大部分时间够用了。</p>