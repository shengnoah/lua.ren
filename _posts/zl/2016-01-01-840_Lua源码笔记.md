---
layout: post
title: Lua源码笔记 
tags: [lua文章]
categories: [topic]
---
<p>用Lua开发游戏已经有一段时间了，但是对Lua的理解还一直停留在浅层。最近想深入研究下，于是着手开始看Lua源码，并在本文记录知识点。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1.基本数据结构"></a>1.基本数据结构</h4><p>Lua的基本数据结构是一个类型union+type。相关的核心代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line"><span class="comment">** Common type for all collectable objects</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  ;</span></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br/><span class="line"><span class="comment">** included in other objects)</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"></span><br/><span class="line">	GCObject *next;  </span><br/><span class="line">	lu_byte tt;      </span><br/><span class="line">	lu_byte marked</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="comment">** Common type has only the common header</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br/><span class="line"><span class="class">{</span></span><br/><span class="line">	CommonHeader;</span><br/><span class="line">};</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua,</span></span><br/><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line"><span class="comment">** Union of all Lua values</span></span><br/><span class="line"><span class="comment">*/</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Value {</span><br/><span class="line">	GCObject *gc;	<span class="comment">/* collectable objects */</span></span><br/><span class="line">	<span class="keyword">void</span> *p;		 <span class="comment">/* light userdata */</span></span><br/><span class="line">	<span class="keyword">int</span> b;			 <span class="comment">/* booleans */</span></span><br/><span class="line">	lua_CFunction f; <span class="comment">/* light C functions */</span></span><br/><span class="line">	lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br/><span class="line">	lua_Number n;	<span class="comment">/* float numbers */</span></span><br/><span class="line">} Value;</span><br/><span class="line"></span><br/><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields </span></span><br/><span class="line">	Value value_;    </span><br/><span class="line">	<span class="keyword">int</span> tt_</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span></span></span><br/><span class="line"><span class="class">{</span></span><br/><span class="line">	TValuefields;</span><br/><span class="line">} TValue;</span><br/></pre></td></tr></tbody></table></figure>

<h4 id="2-GC算法和流程"><a href="#2-GC算法和流程" class="headerlink" title="2.GC算法和流程"></a>2.GC算法和流程</h4><ol>
<li><p>双色标记清除算法</p>
<p>在Lua5.0中的GC，是一次性不可被打断的操作，执行的算法是Mark-and-sweep算法，在执行GC操作的时候，会设置2种颜色，黑色和白色，然后执行GC的流程，大体的伪代码流程如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/></pre></td><td class="code"><pre><span class="line">每个新创建的对象为白色</span><br/><span class="line"></span><br/><span class="line">//初始化阶段</span><br/><span class="line">遍历root链表中的对象，并将其加入到对象链表中    </span><br/><span class="line"></span><br/><span class="line">//标记阶段   </span><br/><span class="line">当前对象链表中还有未被扫描的元素:    </span><br/><span class="line">    从中取出对象并将其标记为黑色   </span><br/><span class="line">    遍历这个对象关联的其他所有对象: </span><br/><span class="line">        标记为黑色</span><br/><span class="line">        </span><br/><span class="line">//回收阶段</span><br/><span class="line">遍历所有对象:   </span><br/><span class="line">    如果为白色:   </span><br/><span class="line">        这些对象没有被引用，则执行回收</span><br/><span class="line">    否则: </span><br/><span class="line">        这些对象仍然被引用，需要保留</span><br/></pre></td></tr></tbody></table></figure>

<p>整个过程是不能被打断的，这是为了避免一种情况：<br/>如果可以被打断，在GC的过程中新创建一个对象<br/>那么如果标记为白色，此时处于回收阶段，那么这个对象没有被扫描就会被回收；<br/>如果标记为黑色，此时处于回收阶段，那么这个对象没有被扫描就会被保留<br/>两种情况都不适合，所以只有让整个过程不可被打断，带来的问题就是造成gc的时候卡顿</p>
</li>
<li><p>三色标记清除算法</p>
<p>虽然是三色，本质是四色，颜色分为三种:</p>
<p><strong>白色:</strong> 当前对象为待访问状态，表示对象还未被gc标记过，也就是对象创建的初始状态； 同理，如果在gc完成后，仍然为白色，则说明当前对象没有被引用，则可以被清除回收</p>
<p><strong>灰色:</strong> 当前对象为待扫描状态，当前对象已经被扫描过，但是其引用的其他对象没有被扫描</p>
<p><strong>黑色:</strong> 当前对象已经扫描过，并且其引用的其他对象也被扫描过</p>
<p>其流程伪代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/></pre></td><td class="code"><pre><span class="line">每个新创建的对象为白色</span><br/><span class="line"></span><br/><span class="line">//初始化阶段   </span><br/><span class="line">遍历root阶段中引用的对象，从白色设置为灰色，并放入到灰色节点列表中   </span><br/><span class="line"></span><br/><span class="line">//标记阶段    </span><br/><span class="line">当灰色链表中还有未被扫描的元素:    </span><br/><span class="line">    从中去除一个对象并将其标记为黑色   </span><br/><span class="line">    遍历这个对象关联的其他所有对象:   </span><br/><span class="line">        如果是白色:</span><br/><span class="line">            标记为灰色，并加入灰色链表中   </span><br/><span class="line">            </span><br/><span class="line">//回收阶段  </span><br/><span class="line">遍历所有对象:   </span><br/><span class="line">    如果为白色: </span><br/><span class="line">        这些对象没有被引用，需要被回收</span><br/><span class="line">    否则:</span><br/><span class="line">        重新加入对象链表中等待下次gc</span><br/></pre></td></tr></tbody></table></figure>

<p>整个标记过程是可以被打断的，被打断后回来只需要接着执行标记过程即可，回收阶段是不可被打断的。</p>
<p>如何解决在标记阶段之后创建的对象为白色的问题?<br/>分裂白色为两种白色，一种为当前白色 currentwhite， 一种为非当前白色 otherwhite，新创建的对象都为otherwhite，则在执行回收的时候，如果为otherwhite则不执行回收操作，等待下次gc的时候，会执行白色的轮换，则新创建的对象会进入下一轮GC。</p>
</li>
</ol>