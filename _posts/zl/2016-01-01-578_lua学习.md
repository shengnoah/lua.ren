---
layout: post
title: lua学习 
tags: [lua文章]
categories: [topic]
---
<h2 id="一、注释">一、注释</h2><p>单行注释：两个破折号<br/>多行注释：[[ … ]]</p>
<h2 id="二、变量和流程控制">二、变量和流程控制</h2><p>所有的数字类型都是double</p>
<pre><code>num=<span class="number">42</span>
</code></pre><p>字符串是Immutable的，和python一样</p>
<pre><code>s = <span class="string">&#39;walternate&#39;</span>
t = <span class="string">&#34;double-quotes are also fine&#34;</span>
u = <span class="string">[[ Double brackets
          start and end
          multi-line strings.]]</span>
</code></pre><p>lua有垃圾回收机制，t是undefined</p>
<pre><code><span class="literal">t</span> = <span class="literal">nil</span>
</code></pre><p>语句块用关键字do/end标示</p>
<pre><code><span class="keyword">while</span> <span class="built_in">num</span> &lt; <span class="number">50</span> <span class="built_in">do</span>
    <span class="built_in">num</span> = <span class="built_in">num</span> + <span class="number">1</span>       
<span class="function"><span class="keyword">end</span>

 语句:</span>
    <span class="keyword">if</span> <span class="built_in">num</span> &gt; <span class="number">40</span> <span class="keyword">then</span>
          print(<span class="string">&#39;over 40&#39;</span>)
    elseif s ~= <span class="string">&#39;walternate&#39;</span> <span class="keyword">then</span>  <span class="comment">-- ~= 是不等号.</span>
<span class="comment">-- 等号是== 对字符串也适用.</span>
      io.<span class="built_in">write</span>(<span class="string">&#39;not over 40n&#39;</span>)  <span class="comment">-- 默认输出到stdout.</span>
    <span class="keyword">else</span>
  <span class="comment">-- 变量默认是全局的.</span>
      thisIsGlobal = <span class="number">5</span>  <span class="comment">-- 常用Camel样式.</span>

  <span class="comment">-- 局部变量如下定义:</span>
      <span class="built_in">local</span> <span class="built_in">line</span> = io.<span class="built_in">read</span>()  <span class="comment">-- 读取下一个stdin 行.</span>

  <span class="comment">-- 字符串连接使用 .. 操作符:</span>
      print(<span class="string">&#39;Winter is coming, &#39;</span> .. <span class="built_in">line</span>)
    <span class="function"><span class="keyword">end</span>

未定义的变量返回<span class="title">nil</span></span>
    foo = anUnknownVariable  <span class="comment">-- Now foo = nil.</span>
    aBoolValue = <span class="constant">false</span>
<span class="comment">-- 只有nil 和 false 是 falsy; 0 和 &#39;&#39; 是 true!</span>
    <span class="keyword">if</span> <span class="operator">not</span> aBoolValue <span class="keyword">then</span> print(<span class="string">&#39;twas false&#39;</span>) <span class="function"><span class="keyword">end</span>
-- &#39;<span class="title">or</span>&#39; <span class="title">and</span> &#39;<span class="title">and</span>&#39; 是短路的.</span>
<span class="comment">-- 这和 C/js中的 a?b:c 相似:</span>
    ans = aBoolValue <span class="operator">and</span> <span class="string">&#39;yes&#39;</span> <span class="operator">or</span> <span class="string">&#39;no&#39;</span>  <span class="comment">--&gt; &#39;no&#39;</span>

    karlSum = <span class="number">0</span>
    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">100</span> <span class="built_in">do</span>  <span class="comment">-- 范围是闭区间.</span>
       karlSum = karlSum + i
    <span class="function"><span class="keyword">end</span>

-- 用 &#34;<span class="title">100</span>, <span class="title">1</span>, -<span class="title">1</span>&#34; 作为区间来递减:</span>
    fredSum = <span class="number">0</span>
    <span class="keyword">for</span> j = <span class="number">100</span>, <span class="number">1</span>, -<span class="number">1</span> <span class="built_in">do</span> fredSum = fredSum + j <span class="function"><span class="keyword">end</span>

-- 总体上, 区间是 <span class="title">begin</span>, <span class="title">end</span>[, <span class="title">step</span>].</span>

<span class="comment">-- 另一种循环结构:</span>
    <span class="keyword">repeat</span>
      print(<span class="string">&#39;the way of the future&#39;</span>)
      <span class="built_in">num</span> = <span class="built_in">num</span> - <span class="number">1</span>
    <span class="keyword">until</span> <span class="built_in">num</span> == <span class="number">0</span>
</code></pre><h2 id="三、函数">三、函数</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">fib</span><span class="params">(n)</span></span>
  <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">end</span>
  <span class="keyword">return</span> fib(n - <span class="number">2</span>) + fib(n - <span class="number">1</span>)
<span class="keyword">end</span>

<span class="comment">-- 也可返回闭包和匿名函数:</span>
<span class="function"><span class="keyword">function</span> <span class="title">adder</span><span class="params">(x)</span></span>
  <span class="comment">-- 当adder被调用时，返回函数就被创建，并且保存有x的值：</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span>
<span class="keyword">end</span>
a1 = adder(<span class="number">9</span>)
a2 = adder(<span class="number">36</span>)
<span class="built_in">print</span>(a1(<span class="number">16</span>))  <span class="comment">--&gt; 25</span>
<span class="built_in">print</span>(a2(<span class="number">64</span>))  <span class="comment">--&gt; 100</span>

x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>
<span class="comment">-- 赋值后 x = 1, y = 2, z = 3, 但 4 被丢弃了.</span>

<span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(a, b, c)</span></span>
  <span class="built_in">print</span>(a, b, c)
  <span class="keyword">return</span> <span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>
<span class="keyword">end</span>

x, y = bar(<span class="string">&#39;zaphod&#39;</span>)  <span class="comment">--&gt; prints &#34;zaphod  nil nil&#34;</span>
<span class="comment">-- 现在 x = 4, y = 8, 值 15..42 被丢弃了.</span>

<span class="comment">-- 函数是一等公民, 可以是 local/global.</span>
<span class="comment">-- 下面是等价的:</span>
<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span> <span class="keyword">return</span> x * x <span class="keyword">end</span>
f = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> x * x <span class="keyword">end</span>

<span class="comment">-- 下面也是等价的:</span>
<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">(x)</span></span> <span class="keyword">return</span> <span class="built_in">math</span>.sin(x) <span class="keyword">end</span>
<span class="keyword">local</span> g; g  = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="built_in">math</span>.sin(x) <span class="keyword">end</span>    

<span class="comment">-- 调用只有一个字符串的参数，不需要括号:</span>
<span class="built_in">print</span> <span class="string">&#39;hello&#39;</span>  <span class="comment">-- Works fine.</span>
</code></pre><h2 id="四、表">四、表</h2><p>Tables ： 哈希查找的关联数组，和dictionaries、map类似，是lua仅有的复合数据结构。</p>
<pre><code>Dict的的键默认是字符串的
t = {key1 = <span class="string">&#39;value1&#39;</span>, key2 = <span class="keyword">false</span>}
<span class="built_in">print</span>(t.key1)  <span class="comment">-- 输出 &#39;value1&#39;.</span>
t.newKey = {}  <span class="comment">-- 添加一个新的 key/value 对.</span>
t.key2 = <span class="keyword">nil</span>   <span class="comment">-- 从table中移除 key2.</span>

表常用的的键一般是数字或者字符串
u = {[<span class="string">&#39;@!#&#39;</span>] = <span class="string">&#39;qbert&#39;</span>, [{}] = <span class="number">1729</span>, [<span class="number">6.28</span>] = <span class="string">&#39;tau&#39;</span>}
<span class="built_in">print</span>(u[<span class="number">6.28</span>])  <span class="comment">-- 输出&#34;tau&#34;</span>
a = u[<span class="string">&#39;@!#&#39;</span>]    <span class="comment">-- a = &#39;qbert&#39;.</span>
b = u[{}]     <span class="comment">-- 误认为是1729, 其实是 nil。</span>

<span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(u) <span class="keyword">do</span>  <span class="comment">-- 表迭代.</span>
  <span class="built_in">print</span>(key, val)
<span class="keyword">end</span>

<span class="comment">-- 调用一个 one-table-param 的函数不需要括号</span>
<span class="function"><span class="keyword">function</span> <span class="title">h</span><span class="params">(x)</span></span> <span class="built_in">print</span>(x.key1) <span class="keyword">end</span>
h{key1 = <span class="string">&#39;Sonmi~451&#39;</span>}  <span class="comment">-- Prints &#39;Sonmi~451&#39;.</span>

<span class="comment">-- _G 是一个全局的特殊表.</span>
<span class="built_in">print</span>(<span class="built_in">_G</span>[<span class="string">&#39;_G&#39;</span>] == <span class="built_in">_G</span>)  <span class="comment">-- 输出 &#39;true&#39;.</span>

<span class="comment">-- 把 tables 用作 lists / arrays:</span>

<span class="comment">-- List 的键默认是整数，键是连续的整数，其实还是table:</span>
v = {<span class="string">&#39;value1&#39;</span>, <span class="string">&#39;value2&#39;</span>, <span class="number">1.21</span>, <span class="string">&#39;gigawatts&#39;</span>}
<span class="keyword">for</span> i = <span class="number">1</span>, #v <span class="keyword">do</span>  <span class="comment">-- #v 是列表v的长度.</span>
  <span class="built_in">print</span>(v[i])     <span class="comment">-- 第一个索引是1</span>
<span class="keyword">end</span>
</code></pre><p>4.1. 元表和元方法.</p>
<p>–元表给予表操作符重载的特性，类似js的prototype的特性。</p>
<pre><code>f1 = {<span class="operator">a</span> = <span class="number">1</span>, b = <span class="number">2</span>}  <span class="comment">-- 表示分数 a/b.</span>
f2 = {<span class="operator">a</span> = <span class="number">2</span>, b = <span class="number">3</span>}

<span class="comment">-- 但是下面这样会报错:</span>
<span class="comment">-- s = f1 + f2</span>

metafraction = {}
<span class="function"><span class="keyword">function</span> <span class="title">metafraction</span>.<span class="title">__add</span>(<span class="title">f1</span>, <span class="title">f2</span>)</span>
  <span class="built_in">sum</span> = {}
  <span class="built_in">sum</span>.b = f1.b * f2.b
  <span class="built_in">sum</span>.<span class="operator">a</span> = f1.<span class="operator">a</span> * f2.b + f2.<span class="operator">a</span> * f1.b
  <span class="constant">return</span> <span class="built_in">sum</span>
<span class="function"><span class="keyword">end</span>

<span class="title">setmetatable</span>(<span class="title">f1</span>, <span class="title">metafraction</span>)</span>
setmetatable(f2, metafraction)

s = f1 + f2  

<span class="comment">-- 元表上的 __index 重载 . 查找:</span>
defaultFavs = {animal = <span class="string">&#39;gru&#39;</span>, food = <span class="string">&#39;donuts&#39;</span>}
myFavs = {food = <span class="string">&#39;pizza&#39;</span>}
setmetatable(myFavs, {__index = defaultFavs})
eatenBy = myFavs.animal  <span class="comment">-- 可行! thanks, metatable</span>

一个__index值也可以是个函数(tbl, key)，有利于个性化查找。
像__index,<span class="built_in">add</span>, .. 都是元方法，下面是一个全表，这里 <span class="operator">a</span>是一个有metamethod的表

<span class="comment">-- __add(a, b)                     for a + b</span>
<span class="comment">-- __sub(a, b)                     for a - b</span>
<span class="comment">-- __mul(a, b)                     for a * b</span>
<span class="comment">-- __div(a, b)                     for a / b</span>
<span class="comment">-- __mod(a, b)                     for a % b</span>
<span class="comment">-- __pow(a, b)                     for a ^ b</span>
<span class="comment">-- __unm(a)                        for -a</span>
<span class="comment">-- __concat(a, b)                  for a .. b</span>
<span class="comment">-- __len(a)                        for #a</span>
<span class="comment">-- __eq(a, b)                      for a == b</span>
<span class="comment">-- __lt(a, b)                      for a &lt; b</span>
<span class="comment">-- __le(a, b)                      for a &lt;= b</span>
<span class="comment">-- __index(a, b)  &lt;fn or a table&gt;  for a.b</span>
<span class="comment">-- __newindex(a, b, c)             for a.b = c</span>
<span class="comment">-- __call(a, ...)                  for a(...)</span>
</code></pre><p>4.2. 类风格的表与继承 </p>
<p>类不是内置的，有多种可以使用tables和metatables的方法</p>
<pre><code>Dog = {}                                   <span class="comment">-- 1.</span>

<span class="function"><span class="keyword">function</span> <span class="title">Dog:new</span><span class="params">()</span></span>                         <span class="comment">-- 2.</span>
  newObj = {sound = <span class="string">&#39;woof&#39;</span>}                <span class="comment">-- 3.</span>
  self.__index = self                      <span class="comment">-- 4.</span>
  <span class="keyword">return</span> <span class="built_in">setmetatable</span>(newObj, self)        <span class="comment">-- 5.</span>
<span class="keyword">end</span>

<span class="function"><span class="keyword">function</span> <span class="title">Dog:makeSound</span><span class="params">()</span></span>                   <span class="comment">-- 6.</span>
  <span class="built_in">print</span>(<span class="string">&#39;I say &#39;</span> .. self.sound)
<span class="keyword">end</span>

mrDog = Dog:new()                          <span class="comment">-- 7.</span>
mrDog:makeSound()  <span class="comment">-- &#39;I say woof&#39;         -- 8.</span>
</code></pre><p>–1. Dog 像是一个class，它实际是一个表。</p>
<p>–2. 函数 tablename：fn(…) 和函数tablename.fn(self,…)一样，： 仅仅添加第一个名为self的参数。</p>
<p>–3. newObj是类Dog的实例。</p>
<p>–4. self就是被继承的类，但是继承可以改变self的值，这里是Dog，当我们设置newObj’s metatable 和 self’s __index to self时，newObj 才能使用self’s 函数。</p>
<p>–5. setmetatable 返回它的第一个参数</p>
<p>–6. 这时，self是一个实例而不是一个类。</p>
<p>–7. 和Dog.new(Dog)一样。</p>
<p>–8. 和mrDog.makeSound(mrDog)一样; 此时 self = mrDog.</p>
<p>继承的例子：</p>
<pre><code>LoudDog = Dog:new()                           <span class="comment">-- 1.    </span>
<span class="function"><span class="keyword">function</span> <span class="title">LoudDog:makeSound</span><span class="params">()</span></span>
  s = self.sound .. <span class="string">&#39; &#39;</span>                       <span class="comment">-- 2.</span>
  <span class="built_in">print</span>(s .. s .. s)
<span class="keyword">end</span>    
seymour = LoudDog:new()                       <span class="comment">-- 3.</span>
seymour:makeSound()  <span class="comment">-- &#39;woof woof woof&#39;      -- 4.</span>
</code></pre><p>– 1. LoudDog 继承了 Dog’s 的方法和变量。</p>
<p>– 2. self 有一个来自于new()的 ‘sound’键。</p>
<p>– 3. 和LoudDog.new(LoudDog)一样, 由于LoudDog没有‘new’键，将被转换为 Dog.new(LoudDog),但是它的 metatable 拥有 <strong>index = Dog。<br/>结论：seymour的 metatable是LoudDog，LoudDog.</strong>index = LoudDog. 所以 seymour.key = seymour.key, LoudDog.key, Dog.key, 任何第一个含有给定键的表。</p>
<p>– 4. ‘makeSound’ key 包含在LoudDog;这和LoudDog.makeSound(seymour)一样.</p>
<p>– 如果有需要, 一个子类的 new() 可以和基类的一样:</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">LoudDog</span>:</span><span class="keyword">new</span>()
  newObj = {}
  -- set up newObj
  <span class="variable">self</span>.__index = <span class="variable">self</span>
  <span class="keyword">return</span> setmetatable(newObj, <span class="variable">self</span>)
<span class="keyword">end</span>
</code></pre><h1 id="五、模块">五、模块</h1><p>– 假设文件mod.lua 像如下所示:</p>
<pre><code><span class="keyword">local</span> M = {}
<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sayMyName</span><span class="params">()</span></span>
  <span class="built_in">print</span>(<span class="string">&#39;Hrunkner&#39;</span>)
<span class="keyword">end</span>

<span class="function"><span class="keyword">function</span> <span class="title">M.sayHello</span><span class="params">()</span></span>
  <span class="built_in">print</span>(<span class="string">&#39;Why hello there&#39;</span>)
  sayMyName()
<span class="keyword">end</span>

<span class="keyword">return</span> M

<span class="comment">-- 另一个文件可以使用mod.lua&#39;s 的函数:</span>
<span class="keyword">local</span> mod = <span class="built_in">require</span>(<span class="string">&#39;mod&#39;</span>)  <span class="comment">-- 运行文件 mod.lua.</span>

<span class="comment">-- require 是 引用和包含 modules 的标准方法.</span>
<span class="comment">-- require 其实像下面这样工作:  （没有缓存的）   </span>
<span class="keyword">local</span> mod = (<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> 
            &lt;contents of mod.lua&gt; 
            <span class="keyword">end</span>)()
<span class="comment">-- mod.lua 像是一个函数体,所以 mod.lua内的局部变量对外不可见</span>

<span class="comment">-- 因为在mod.lua里面，这里的mod = M :</span>
mod.sayHello()   <span class="comment">-- Says hello to Hrunkner.</span>

<span class="comment">-- 错误; sayMyName 只存在于 mod.lua:</span>
mod.sayMyName()  <span class="comment">-- error</span>

<span class="comment">-- require 的返回值是经过缓存的，所以一个文件最多运行一次，无论require多少次。</span>
<span class="comment">-- 假设 mod2.lua 包含 &#34;print(&#39;Hi!&#39;)&#34;.</span>
<span class="keyword">local</span> a = <span class="built_in">require</span>(<span class="string">&#39;mod2&#39;</span>)  <span class="comment">-- 输出 Hi!</span>
<span class="keyword">local</span> b = <span class="built_in">require</span>(<span class="string">&#39;mod2&#39;</span>)  <span class="comment">-- 无输出; a=b.</span>

<span class="comment">-- dofile 就像无缓存的 require:</span>
<span class="built_in">dofile</span>(<span class="string">&#39;mod2.lua&#39;</span>)  <span class="comment">--&gt; Hi!</span>
<span class="built_in">dofile</span>(<span class="string">&#39;mod2.lua&#39;</span>)  <span class="comment">--&gt; Hi! (runs it again)</span>

<span class="comment">-- loadfile 装载一个lua 文件，但并不立即运行。</span>
f = <span class="built_in">loadfile</span>(<span class="string">&#39;mod2.lua&#39;</span>)  <span class="comment">-- 调用 f() 来运行.</span>

<span class="comment">-- loadstring 相当于strings版的loadfile.</span>
g = <span class="built_in">loadstring</span>(<span class="string">&#39;print(343)&#39;</span>)  <span class="comment">-- 返回一个函数.</span>
g()                            <span class="comment">-- 输出343; 此前无输出.</span>
</code></pre><h1 id="参考：">参考：</h1><p><a href="http://tylerneylon.com/a/learn-lua/" target="_blank" rel="external noopener noreferrer">15分钟学会lua</a></p>
<p><a href="http://nova-fusion.com/2012/08/27/lua-for-programmers-part-1/" target="_blank" rel="external noopener noreferrer">Lua编程(Part 1)：基本语法</a></p>
<p><a href="http://nova-fusion.com/2012/08/27/lua-for-programmers-part-2/" target="_blank" rel="external noopener noreferrer">Lua编程(Part 2)：数据和标准库</a></p>
<p><a href="http://nova-fusion.com/2012/09/07/lua-for-programmers-part-3/" target="_blank" rel="external noopener noreferrer">Lua编程(Part 3)：高级概念</a></p>
<p><a href="http://nova-fusion.com/2012/09/09/lua-for-programmers-part-4/" target="_blank" rel="external noopener noreferrer">Lua编程(Part 4)：技巧</a></p>
<p><a href="http://love2d.org/" target="_blank" rel="external noopener noreferrer">love 2D游戏引擎</a></p>
<p><a href="http://www.lua.org/pil/contents.html" target="_blank" rel="external noopener noreferrer">lua官方学习文档</a></p>
<p><a href="https://apaszke.github.io/torch-internals.html" target="_blank" rel="external noopener noreferrer">A quick tour of Torch internals</a></p>
<p><a href="http://apaszke.github.io/lstm-explained.html" target="_blank" rel="external noopener noreferrer">基于Torch的LSTM实现</a></p>