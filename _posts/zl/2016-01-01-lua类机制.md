---
layout: post
title: lua类机制 
tags: [lua文章]
categories: [lua文章]
---
## lua类机制的简易实现

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    42  
    43  
    44  
    45  
    46  
    47  
    48  
    49  
    50  
    51  
    52  
    53  
    54  
    55  
    56  
    57  
    58  
    59  
    60  
    61  
    62  
    63  
    64  
    65  
    66  
    67  
    68  
    69  
    70  
    71  
    72  
    73  
    74  
    75  
    76  
    

|

    
    
    local _class={}  
       
    function (super)  
    	local class_type={}  
    	class_type.ctor=false  
    	class_type.super=super  
    	class_type.new=function(...)   
    			local obj={}  
    			do  
    				local create  
    				create = function(c,...)  
    					if c.super then  
    						create(c.super,...)  
    					end  
    					if c.ctor then  
    						c.ctor(obj,...)  
    					end  
    				end  
       
    				create(class_type,...)  
    			end  
    			setmetatable(obj,{ __index=_class[class_type] })  
    			return obj  
    		end  
    	local vtbl={}  
    	_class[class_type]=vtbl  
       
    	setmetatable(class_type,{__newindex=  
    		function(t,k,v)  
    			vtbl[k]=v  
    		end  
    	})  
       
    	if super then  
    		setmetatable(vtbl,{__index=  
    			function(t,k)  
    				local ret=_class[super][k]  
    				vtbl[k]=ret  
    				return ret  
    			end  
    		})  
    	end  
       
    	return class_type  
    end  
      
      
    base_type=class()		  
       
    function base_type:ctor(x)	-- 定义 base_type 的构造函数  
    	print("base_type ctor")  
    	self.x=x  
    end  
       
    function base_type:print_x()	-- 定义一个成员函数 base_type:print_x  
    	print(self.x)  
    end  
       
    function base_type:hello()	-- 定义另一个成员函数 base_type:hello  
    	print("hello base_type")  
    end  
      
    test=class(base_type)	-- 定义一个类 test 继承于 base_type  
       
    function test:ctor()	-- 定义 test 的构造函数  
    	print("test ctor")  
    end  
       
    function test:hello()	-- 重载 base_type:hello 为 test:hello  
    	print("hello test")  
    end  
      
      
    a=test.new(1)	-- 输出两行，base_type ctor 和 test ctor 。这个对象被正确的构造了。  
    a:print_x()	-- 输出 1 ，这个是基类 base_type 中的成员函数。  
    a:hello()	-- 输出 hello test ，这个函数被重载了。  
      
  
---|---  
  
## lua类机制的简易实现–多重继承

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    42  
    43  
    44  
    45  
    46  
    47  
    48  
    49  
    50  
    51  
    52  
    53  
    54  
    55  
    56  
    57  
    58  
    59  
    60  
    61  
    62  
    63  
    64  
    65  
    66  
    67  
    68  
    69  
    70  
    71  
    72  
    73  
    74  
    75  
    76  
    77  
    78  
    79  
    80  
    81  
    82  
    83  
    84  
    85  
    86  
    87  
    88  
    89  
    90  
    91  
    92  
    93  
    94  
    95  
    96  
    97  
    98  
    99  
    100  
    101  
    102  
    103  
    104  
    105  
    106  
    107  
    108  
    109  
    110  
    

|

    
    
      
    local function search(classes, key)  
        for i = 1, #classes do  
            local value = classes[i][key];  
            if value ~= nil then  
                return value;  
            end  
        end  
    end  
      
    local function (fun,...)  
        local class_type={}  
        class_type.ctor=false  
        local parents = {...}  
        if #parents  > 0 then  
            class_type.super=parents  
        else  
            class_type.super=nil  
        end  
        class_type.fun = fun  
        class_type.new=function(...)  
            local obj  
            if class_type.fun then  
                obj = class_type.fun(...)  
            else  
                obj = {}  
            end  
            do  
                local create  
                create = function(c,...)  
                    if c.super then  
                        for i = 1, #c.super do  
                            create(c.super[i],...)  
                        end  
                    end  
                    if c.ctor then  
                        c.ctor(obj,...)  
                    end  
                end  
      
                create(class_type,...)  
            end  
            setmetatable(obj,{ __index=class_type })  
            return obj  
        end  
      
        if class_type.super then  
            setmetatable(class_type,{__index=  
                    function(t,k)  
                        local ret=search(class_type.super,k)  
                        class_type[k]=ret  
                        return ret  
                    end  
                })  
        end  
      
        return class_type  
    end  
      
      
    local base_type=class()		  
      
    function base_type:ctor(x)	-- 定义 base_type 的构造函数  
        print("base_type ctor")  
        self.x=x  
    end  
      
    function base_type:print_x()	-- 定义一个成员函数 base_type:print_x  
        print("print base_type")  
        print(self.x)  
        self:print_b()  
    end  
      
    function base_type:hello()	-- 定义另一个成员函数 base_type:hello  
        print("hello base_type")  
    end  
      
    local base_typeB=class()		  
    function base_typeB:ctor(x)	-- 定义 base_type 的构造函数  
        print("base_typeB ctor")  
    end  
      
    function base_typeB:print_b()	-- 定义一个成员函数 base_type:print_x  
        print("print base_typeB")  
        print(self.x)  
    end  
      
    function base_typeB:helloB()	-- 定义另一个成员函数 base_type:hello  
        print("hello base_typeB")  
    end  
      
    local test=class(function()  
        print("fun")  
        return {}  
    end,  
    base_typeB,base_type)	-- 定义一个类 test 继承于 base_type  
      
    function test:ctor()	-- 定义 test 的构造函数  
        print("test ctor")  
    end  
      
    function test:hello()	-- 重载 base_type:hello 为 test:hello  
        print("hello test")  
    end  
      
      
    local a=test.new(1)	-- 输出两行，base_type ctor 和 test ctor 。这个对象被正确的构造了。  
    a:print_x()	-- 输出 1 ，这个是基类 base_type 中的成员函数。  
    a:hello()	-- 输出 hello test ，这个函数被重载了。  
    a:helloB()  
      
  
---|---  
  
## 参考

[Lua 中实现面向对象](https://blog.codingnow.com/cloud/LuaOO)