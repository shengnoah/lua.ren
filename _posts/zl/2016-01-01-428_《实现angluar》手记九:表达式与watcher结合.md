---
layout: post
title: 《实现angluar》手记九:表达式与watcher结合 
tags: [lua文章]
categories: [topic]
---
<h2 id="表达式与watcher结合"><a href="#表达式与watcher结合" class="headerlink" title="表达式与watcher结合"></a>表达式与watcher结合</h2><p>在前面的章节中, <code>Scope.$watch</code>函数接受的<code>watchFn</code>仅仅是一个返回值的普通函数, 而本章节中表达式与watcher连接的关键点是将watcher中的<code>watchFn</code>替换成<code>parse(watchFn)</code>, 将parse生成的新函数作为watchFn, 当然,我们也需要对应的对<code>$watchCollection</code>,<code>$eval</code>,<code>$apply</code>, <code>evalAsync</code>等方法做处理</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line">Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) {</span><br/><span class="line">    var self = this;</span><br/><span class="line">    var watcher = {</span><br/><span class="line">        watchFn: parse(watchFn), // wathcCollection等方法也需要做一并处理</span><br/><span class="line">        listenerFn: listenerFn || function() { },</span><br/><span class="line">        last: initWatchVal,</span><br/><span class="line">        valueEq: !!valueEq</span><br/><span class="line">    };</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>

<p>当然，parse需要对传入的参数做处理， 如果已经是一个函数的话就直接返回</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">expr</span>) </span>{</span><br/><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> expr) {</span><br/><span class="line">    <span class="keyword">case</span> <span class="string">&#39;string&#39;</span>:</span><br/><span class="line">      <span class="keyword">var</span> lexer = <span class="keyword">new</span> Lexer();</span><br/><span class="line">      <span class="keyword">var</span> parser = <span class="keyword">new</span> Parser(lexer);</span><br/><span class="line">      <span class="keyword">return</span> parser.parse(expr);</span><br/><span class="line">    <span class="keyword">case</span> <span class="string">&#39;function&#39;</span>:</span><br/><span class="line">      <span class="keyword">return</span> expr;</span><br/><span class="line">    <span class="keyword">default</span>:</span><br/><span class="line">      <span class="keyword">return</span> _.noop;</span><br/><span class="line">  }</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>

<h2 id="字面量与常量表达式"><a href="#字面量与常量表达式" class="headerlink" title="字面量与常量表达式"></a>字面量与常量表达式</h2><p>优化： 标记watcher检测的表达式为常量还是变量(比如渲染一个列表)， 在第一次被触发的时候， 如果是常量就可以直接将watcher移除，这样在digest的过程中就不会遍历该watcher(Vue在编译的过程中也有相应的静态节点标记)</p>
<p>为此,我们明确两个概念: </p>
<ul>
<li>字面量, 如42, [42, ‘abc’], [42, ‘abc’, aVariable]</li>
<li>常量,42, [42, ‘abc’]是常量,而[42, ‘abc’, aVariable]不是, 因为aVarible的存在</li>
</ul>
<p>实现的方式是为parse生成的函数添加额外的参数, <code>literal</code>, <code>constant</code>,</p>
<h3 id="literal"><a href="#literal" class="headerlink" title="literal"></a>literal</h3><p>先来看literal</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"></span><br/><span class="line">ASTCompiler.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>{</span><br/><span class="line">  ....</span><br/><span class="line">  fn.literal = isLiteral(ast);</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>

<p>这里, isLiteral函数进行以下检测</p>
<ul>
<li>一个空的program(函数的body为空)是字面量</li>
<li>非空的program, 其body只有一个表达式, 且表达式的类型为<code>array</code>或者<code>object</code></li>
</ul>
<h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><p>常量的判断比较复杂, 需要递归地对每一个节点做判断, 只有当所有的节点都为常量的时候才是常量</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">ASTCompiler.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>{</span><br/><span class="line">  markConstantExpressions(ast);</span><br/><span class="line">  ....</span><br/><span class="line">  fn.constant = ast.constant;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>

<p>markConstantExpression函数针对每类节点进行标记</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markConstantAndWatchExpressions</span>(<span class="params">ast</span>) </span>{</span><br/><span class="line">  <span class="keyword">var</span> allConstants;</span><br/><span class="line">  <span class="keyword">var</span> argsToWatch;</span><br/><span class="line">  <span class="keyword">switch</span> (ast.type) {</span><br/><span class="line">  <span class="keyword">case</span> AST.Program:</span><br/><span class="line">    allConstants = <span class="literal">true</span>;</span><br/><span class="line">    _.forEach(ast.body, <span class="function"><span class="keyword">function</span>(<span class="params">expr</span>) </span>{</span><br/><span class="line">      markConstantAndWatchExpressions(expr);</span><br/><span class="line">      allConstants = allConstants &amp;&amp; expr.constant;</span><br/><span class="line">    });</span><br/><span class="line">    ast.constant = allConstants;</span><br/><span class="line">    <span class="keyword">break</span>;</span><br/><span class="line">  <span class="keyword">case</span> AST.Literal:</span><br/><span class="line">    ast.constant = <span class="literal">true</span>;</span><br/><span class="line">    ast.toWatch = [];</span><br/><span class="line">    <span class="keyword">break</span>;</span><br/><span class="line">    ....</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>

<h2 id="优化常量表达式的监测"><a href="#优化常量表达式的监测" class="headerlink" title="优化常量表达式的监测"></a>优化常量表达式的监测</h2><p>常量表达式永远返回相同的值, 这也意味着常量表达式第一次被触发之后再也不会变”脏”,因此我们可以移除相应的watcher</p>
<p><code>watch delegate</code>, 当Scope.$watch中出现watcher delegate中的表达式的时候， 该代理会绕过正常的watcher创建的过程。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constantWatchDelegate</span>(<span class="params">scope, listenerFn, valueEq, watchFn</span>) </span>{</span><br/><span class="line">    <span class="keyword">var</span> unwatch = scope.$watch(</span><br/><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br/><span class="line">            <span class="keyword">return</span> watchFn(scope);</span><br/><span class="line">        },</span><br/><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue, scope</span>) </span>{</span><br/><span class="line">            <span class="keyword">if</span> (_.isFunction(listenerFn)) {</span><br/><span class="line">                listenerFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br/><span class="line">            }</span><br/><span class="line">            unwatch();</span><br/><span class="line">        },</span><br/><span class="line">        valueEq</span><br/><span class="line">    );</span><br/><span class="line">    <span class="keyword">return</span> unwatch;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure>

<h2 id="One-Time-Expressions"><a href="#One-Time-Expressions" class="headerlink" title="One-Time Expressions"></a>One-Time Expressions</h2><p>只执行一次的表达式: 比如列表项, 里面的内容一旦渲染之后就不会发生变化</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">&lt;li ng-repeat=<span class="string">&#34;user in users&#34;</span>&gt;</span><br/><span class="line">{{::user.firstName}} {{::user.lastName}}</span><br/><span class="line">&lt;<span class="regexp">/li&gt;</span></span><br/></pre></td></tr></tbody></table></figure>

<h2 id="input-tracking"><a href="#input-tracking" class="headerlink" title="input-tracking"></a>input-tracking</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br/><span class="line"><span class="string"></span></span><br/><span class="line"><span class="string">## stateful Filters</span></span><br/><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br/></pre></td></tr></tbody></table></figure>

<h2 id="External-Assignment"><a href="#External-Assignment" class="headerlink" title="External Assignment"></a>External Assignment</h2><pre><code class="js"></code></pre>