---
layout: post
title: 150.逆波兰表达式求值（evaluate reverse polish notation） 
tags: [lua文章]
categories: [topic]
---
<p>根据逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>说明：</strong></p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<p>示例 1：</p>
<pre><code>输入: [&#34;2&#34;, &#34;1&#34;, &#34;+&#34;, &#34;3&#34;, &#34;*&#34;]
输出: 9
解释: ((2 + 1) * 3) = 9</code></pre><p>示例 2：</p>
<pre><code>输入: [&#34;4&#34;, &#34;13&#34;, &#34;5&#34;, &#34;/&#34;, &#34;+&#34;]
输出: 6
解释: (4 + (13 / 5)) = 6</code></pre><p>示例 3：</p>
<pre><code>输入: [&#34;10&#34;, &#34;6&#34;, &#34;9&#34;, &#34;3&#34;, &#34;+&#34;, &#34;-11&#34;, &#34;*&#34;, &#34;/&#34;, &#34;*&#34;, &#34;17&#34;, &#34;+&#34;, &#34;5&#34;, &#34;+&#34;]
输出: 22
解释:
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>暂无</p>
<h2 id="其他题解"><a href="#其他题解" class="headerlink" title="其他题解"></a>其他题解</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><p><strong>思路：</strong></p>
<pre><code>class Solution {
    public int evalRPN(String[] tokens) {
        int[] stack = new int[tokens.length];
        int k= -1;
        for(String s : tokens) {
            switch(s) {
                case &#34;+&#34;:
                    stack[k-1] += stack[k];
                    k--;
                    break;
                case &#34;-&#34;:
                    stack[k-1] -= stack[k];
                    k--;
                    break;
                case &#34;*&#34;:
                    stack[k-1] *= stack[k];
                    k--;
                    break;
                case &#34;/&#34;:
                    stack[k-1] /= stack[k];
                    k--;
                    break;
                default:
                    stack[++k] = Integer.parseInt(s);
            }
        }
        return stack[0];
    }
}

</code></pre><h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h3><p><strong>思路：</strong></p>
<pre><code>class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        for (String s : tokens) {
            if (s.equals(&#34;+&#34;)) {
                stack.push(stack.pop() + stack.pop());
            } else if (s.equals(&#34;-&#34;)) {
                stack.push(-stack.pop() + stack.pop());
            } else if (s.equals(&#34;*&#34;)) {
                stack.push(stack.pop() * stack.pop());
            } else if (s.equals(&#34;/&#34;)) {
                int num1 = stack.pop();
                stack.push(stack.pop() / num1);
            } else {
                stack.push(Integer.parseInt(s));
            }
        }
        return stack.pop();
    }

}
</code></pre><hr/>
<p><strong><em>参考：<br/><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/" target="_blank" rel="noopener noreferrer">LeetCode</a><br/><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/java-yi-dong-yi-jie-xiao-lu-gao-by-spirit-9-19/" target="_blank" rel="noopener noreferrer">StackOverflow-</a></em></strong></p>

      
       <hr/><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1136075279@qq.com </span>