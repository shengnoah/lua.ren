---
layout: post
title: Lua标准库阅读总结（官方文档） 
tags: [lua文章]
categories: [topic]
---
**Contents**

Lua的标准库直接通过C语言的API进行实现的。有一些函数对于这个语言提供的功能是必不可少的（例如getmetatable和type又元表是lua的一个重要语言特性，还会总结哒）其他的提供了一些输出到外部的功能（例如IO）还有一些很有用的但是用lua自身进行实现的一些函数（例如table.sort）

## 库的大纲

所有的库都是通过官方的C语言的API就像C的API的一样的进行分离。

    
    
    1.basic library 
    2.coroutine library 
    3.package library 
    4.string manipulation 
    5.basic UTF-8 support 
    6.table manipulation 
    7.mathematical functions 
    8.input and output 
    9.operating system facilities 
    10.debug facilities 
    

还有一堆废话告诉你这些库使用什么调用的。

## 1.Basic Functions

basic library是lua的核心，如果你并没有使用他们的话，你得自己去实现这些功能才可以

### 1.1 assert (v [, message])

功能：相当于C的断言，  
参数：  
v：当表达式v为nil或false将触发错误,  
message：发生错误时返回的信息，默认为”assertion failed!”

### 1.2 collectgarbage (opt [, arg])

功能：是垃圾收集器的通用接口，用于操作垃圾收集器  
参数：

1.opt：操作方法标志

2.”Stop”: 停止垃圾收集器

3.”Restart”: 重启垃圾收集器

4.”Collect”: 执行一次全垃圾收集循环

5.”Count”: 返回当前Lua中使用的内存量(以KB为单位)

6.”Step”: 单步执行一个垃圾收集. 步长 “Size” 由参数arg指定
(大型的值需要多步才能完成)，如果要准确指定步长，需要多次实验以达最优效果。如果步长完成一次收集循环，将返回True

7.”Setpause”: 设置 arg/100 的值作为暂定收集的时长

8.”Setstepmul”: 设置 arg/100 的值，作为步长的增幅(即新步长＝旧步长*arg/100)  
“isrunning”: 返回一个bool值告诉你，垃圾回收器是否正在运行

### 1.3 dofile (filename)

功能：打开并且执行一个lua块,当忽略参数filename时，将执行标准输入设备(stdin)的内容。返回所有块的返回值。当发生错误时，dofile将错误反射给调用者  
注：dofile不能在保护模式下运行

### 1.4 error (message [, level])

功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)  
通常情况下，error会附加一些错误位置的信息到message头部.

Level参数指示获得错误的位置,  
Level=1[默认]：为调用error位置(文件+行号)  
Level=2：指出哪个调用error的函数的函数  
Level=0:不添加错误位置信息

### 1.5 _G全局环境表(全局变量)

功能：记录全局环境的变量值的表 _G._G = _G

### 1.6 getmetatable(object)

功能：返回指定对象的元表(若object的元表有 **metatable这个字段，则返回object的元表.**
metatable的值)，当object没有元表时将返回nil  
若指定对象有元表，但是没有__metatable这个字段，则返回给定的对象的元表

### 1.7 ipairs (t)

功能：返回三个值 迭代函数、表、0  
多用于穷举表的键名和键值对  
如：for i,v in ipairs(t) do  
[body]  
end  
每次循环将索引赋级i，键值赋给v  
就是得到(1,t[1]), (2,t[2])，一直到出现了第一个为nil的值

### 1.7 load (chunk [, chunkname [, mode [, env]]])

功能：如果chunk是字符串则就是字符串，如果是函数则装载一个块中的函数，每次调用func将返回一个连接前一结的字串，在块结尾处将返回nil  
当没有发生错误时，将返回一个编译完成的块作为函数,否则返回nil加上错误信息，此函数的环境为全局环境  
chunkname用于错误和调试信息

### 1.8 loadfile ([filename [, mode [, env]]])

跟load类似，但装载的是文件或当没有指定filename时装载标准输入(stdin)的内容

### 1.9 next (table [, index])

功能：允许程序遍历表中的每一个字段，返回下一索引和该索引的值。  
参数：table：要遍历的表  
index：要返回的索引的前一索中的号，当index为nil[]时，将返回第一个索引的值，当索引号为最后一个索引或表为空时将返回nil  
注：可以用next(t)来检测表是否为空(此函数只能用于以数字索引的表与ipairs相类似)

### 1.10 pairs (t)

如果t有元方法__pairs,把t当作变量调用它并且从这个调用中返回第一个有三个results  
否则，返回三个值，next函数，表t，和空  
for k,v in pairs(t) do body end  
看见next，则要小心遍历中修改表的状况

### 1.11 pcall (f [, arg1, ···])

功能：在保护模式下调用函数(即发生的错误将不会反射给调用者)  
当调用函数成功能返回true,失败时将返回false加错误信息

### 1.12 print (···)

功能：简单的以tostring方式格式化输出参数的内容

### 1.13 rawequal (v1, v2)

检查v1是否等于v2，并且不会调用__eq元表方法，返回一个bool值

### 1.14 rawget (table, index)

得到一个table[index]的真正的值，并且不会调用__index的元表方法，table必须是一个表，index可以是任何值

### 1.15 rawlen (v)

返回v的长度，v可以是一个表也可以是一个字符串也不会调用__len元表方法，返回一个整型

### 1.16 rawset (table, index, value)

把value给table[index]，不会调用__newindex元表方法，table必须是一个表，index可以是不同于nil和NaN的任何值，value可以是任何lua的value。这个函数返回一个表

### 1.17 select (index, ···)

功能：当index为数字将返回所有index大于index的参数:如：select(2,”a”,”b”) 返回 “b”  
当index为”#”，则返回参数的总个数(不包括index)

### 1.18 setmetatable (table, metatable)

功能：为指定的table设置元表metatable，如果metatable为nil则取消table的元表，当metatable有__metatable字段时，将触发错误  
这个函数返回表  
注：只能为LUA_TABLE 表类型指定元表

### 1.19 tonumber (e [, base])

功能：尝试将参数e转换为数字，当不能转换时返回nil  
base(2~36)指出参数e当前使用的进制，默认为10进制，如tonumber(11,2)=3

### 1.20 tostring (v)

功能：将参数e转换为字符串，此函数将会触发元表的__tostring事件  
type(v)  
功能：返回参数的类型名(“nil”，”number”, “string”, “boolean”, “table”, “function”,
“thread”, “userdata”)

### 1.21 _VERSION

功能：返回当前Lua的版本号”Lua 5.3”.  
xpcall (f, err)  
功能：与pcall类似，在保护模式下调用函数(即发生的错误将不会反射给调用者)  
但可指定一个新的错误处理函数句柄  
当调用函数成功能返回true,失败时将返回false加err返回的结果

## 2.Coroutine Manipulation

这个库函数包括了对于协同程序的操作，在表内进行协同  
文档中包含对于协同 程序的描述，自行查找吧

### 2.1 coroutine.create (f)

创建一个包含f的新的协程，f必须是函数，返回一个新的协程，对象类型为thread

### 2.2 coroutine.isyieldable ()

如果正在运行的协程可以让出，则返回真。值得注意的是，只有主协程（线程）和C函数中是无法让出的。

### 2.3 coroutine.resume (co [, val1, ···])

这是一个非常重要的函数。用来启动或再次启动一个协程，使其由挂起状态变成运行状态。

可以这么说，resume函数相当于在执行协程中的方法。参数Val1…是执行协程co时传递给协程的方法。

首次执行协程co时，参数Val1…会传递给协程co的函数；

再次执行协程co时，参数Val1…会作为给协程co中上一次yeild的返回值。

不知道这句话大家理解了没，这是协程的核心。如果没理解也不用急，继续往下看，稍后我会详细解释。

resume函数返回什么呢？有3种情况：

1）、如果协程co的函数执行完毕，协程正常终止，resume 返回 true和函数的返回值。

2）、如果协程co的函数执行过程中，协程让出了（调用了yeild()方法），那么resume返回true和协程中调用yeild传入的参数。

3）、如果协程co的函数执行过程中发生错误，resume返回false与错误消息。

可以看到resume无论如何都不会导致程序崩溃。它是在保护模式下执行的。

### 2.4 coroutine.running ()

用来判断当前执行的协程是不是主线程，如果是，返回运行的协程和true。

### 2.5 coroutine.status (co)

返回一个字符串，表示协程的状态。有4种状态：

1）、running。如果在协程的函数中调用status，传入协程自身的句柄，那么执行到这里的时候才会返回running状态。

2）、suspended。如果协程还未结束，即自身调用了yeild或还没开始运行，那么就是suspended状态。

3）、normal。如果协程Aresume协程B时，协程A处于的状态为normal。在协程B的执行过程中，协程A就一直处于normal状态。因为它这时候既不是挂起状态、也不是运行状态。

4）、dead。如果一个协程发生错误结束，或正常终止。那么就处于dead状态。如果这时候对它调用resume，将返回false和错误消息。

### 2.6 coroutine.wrap (f)

wrap()也是用来创建协程的。只不过这个协程的句柄是隐藏的。跟create()的区别在于：

1）、wrap()返回的是一个函数，每次调用这个函数相当于调用coroutine.resume()。

2）、调用这个函数相当于在执行resume()函数。

3）、调用这个函数时传入的参数，就相当于在调用resume时传入的除协程的句柄外的其他参数。

4）、调用这个函数时，跟resume不同的是，它并不是在保护模式下执行的，若执行崩溃会直接向外抛出。

### 2.7 coroutine.yield (···)

使正在执行的函数挂起。

传递给yeild的参数会作为resume的额外返回值。

## 3\. Modules

这个库提供一个了一些加载module的基本工具方法在lua中。由require、module方法及package表组成

### 3.1 require (modname)

功能：加载指定的模块。

此函数先检测package.loaded表中是否存在modname，存在则直接返回当中的值，没有则通过定义的加载器加载modname。  
1) require机制相关的数据和函数  
package.path:保存加载外部模块(lua中”模块”和”文件”这两个概念的分界比较含糊，因为这个值在不同的时刻会扮演不同的角色)的搜索
路径，这种路径是”模板式的路径”，它里面会包含可替代符号”?”,这个符号会被替换，然后lua查找这个文件是否存在，如果存在就会调用其中特定的接
口。典型的值为:  
“./?.lua;./?.lc;/usr/local/?/init.lua”  
如果lua代码中调用:require(“hello.world”)  
那么lua会依次查找：  
./hello/world.lua ==>这里”hello.world”变成了”hello/world”,并替换了模型”./?.lua”  
./hello/world.lc  
…..  
(这种处理方式和python类似，只不过不需要 **init**.py,也有调用python中的 **init**.py)  
package.path在虚拟机启动的时候设置，如果存在环境变量LUA_PATH，那么就用该环境变量作为  
它的值，并把这个环境变量中的”;;”替换为luaconf.h中定义的默认值，如果不存在该变量就直接使用  
luaconf.h定义的默认值

package.cpath:作用和packag.path一样,但它是用于加载第三方c库的。它的初始值可以通过环境变量  
LUA_CPATH来设置  
package.loadlib(libname, func):相当与手工打开c库libname,
并导出函数func返回，loadlib其实是ll_loadlib

2) 查找加载器顺序：

require(在lua中它是ll_require函数)的查找顺序如下：  
a.首先在package.loaded查找modelname,如果该模块已经存在，就直接返回它的值  
b.在package.preload查找modelname, 如果preload存在，那么就把它作为loader，调用loader(L)  
c.根据package.path的模式查找lua库modelname，这个库是通过module函数定义的，对于顶层的lua库，文件名和库名是一
样的而且不需要调用显式地在lua文件中调用module函数(在ll_require函数中可以看到处理方式)，也就是说lua会根据lua文件直接完
成一个loader的初始化过程。  
d.根据package.cpath查找c库，这个库是符合lua的一些规范的(export具有一定特征的函数接口)，lua先已动态的方式加载该c库，然后在库中查找并调用相应名字的接口，例如:luaopen_hello_world  
e.已第一个”.”为分割，将模块名划分为:(main,
sub)的形式，根据package.cpath查找main，如果存在，就加载该库并查询相应的接口:luaopen_main_sub，例如：先查找
hello库，并查询luaopen_hello_world接口  
f.得到loder后，用modname作为唯一的参数调用该loader函数。当然参数是通过lua的栈传递的，所以loader的原型必须符合lua的规范:int
LUA_FUNC(lua_State *L)

ll_require会将这个loader的返回值符给package.loaded[modelname],如果loader不返回值同时
package.loaded[modelname]不存在时,
ll_require就会把package.loaded[modelname]设为true。最后ll_reuqire把package.loaded
[modelname]返回给调用者。当加载失败时，require将触发错误

3)
require的另一个功能是避免重复加载同一个文件两次。Lua保留一张所有已经加载的文件的列表（使用table保存）。如果一个加载的文件在表中存在require简单的返回；表中保留加载的文件的虚名，而不是实文件名。所以如果你使用不同的虚文件名require同一个文件两次，将会加载两次该文件。比如require
“foo”和require
“foo.lua”，路径为”?;?.lua”将会加载foo.lua两次。我们也可以通过全局变量_LOADED访问文件名列表，这样我们就可以判断文件是否被加载过；同样我们也可以使用一点小技巧让require加载一个文件两次。比如，require
“foo”之后_LOADED[“foo”]将不为nil，我们可以将其赋值为nil，require”foo.lua”将会再次加载该文件。

### 3.2 package.cpath

功能：用于require C loader的搜索路径

可以通过修改LUA_CPATH变量(luaconf.h)修改此值

### 3.3 package.loaded

功能：一个用于让require知道哪些模块已加载的记录表，如果package.loaded已经有require要的值，则直接返回此值

### 3.4 package.loadlib (libname, funcname)

功能：通过动态连接C函数库方式加载Lua扩展库

libname为库文件名，funcname为入口函数(此函数必须为纯C接口函数 c++则需用 extern “C” {} 进行限制)

### 3.5 package.path

功能：用于require Lua loader的搜索路径

可以通过修改LUA_PATH变量(luaconf.h)修改此值

### 3.6 package.preload

功能：一个用于保存特殊模块加载器的表

### 3.7 package.seeall(module)

功能：为module设置一个元表，此元表的__index字段的值为全局环境_G。所以module可以访问全局环境

注：以此函数作为module()的一个选项(详细见module())

### 3.8 package.searchers

  
一个使用require去控制加载modules的表，这个表的每一个入欧都是searcher函数，当寻找一个module的时候，require使用升序排列调用每一个searchers根据module的name（参数必须失由require给的）作为他自己唯一的参数。这个函数可以返回另一个函数（loader的module）加上一个额外的值。经由那个loader传递的值，或者一个为什么没有找到那个module的解释的字符串（如果没有什么说的就输出nil）lua初始化一个表需要四个searcher的函数  
第一个searcher 就是loader这个package.preload 表  
第二个搜索器就是查找一个加载起作为lua的库，使用package.path.这个路径进行存储的，这个seach工作完成使用package.searchpath.进行描述  
第三个搜索器查找一个C的库的加载器，使用给定的变量的路径package.cpath.
进行加载。这个seach工作完成使用package.searchpath.进行描述  
。。。  
所有的搜索器除了第一个是返回一个preload作为一个额外的值当被找到的时候，其他的都返回package.searchpath和一个额外的值。第一个搜索器不返回任何额外的值

### 3.9 package.searchpath (name, path [, sep [, rep]])

根据给定的名字和路径进行查找

## 4.String Manipulation

  1. string库中所有的字符索引从前往后是1,2,…;从后往前是-1,-2,…
  2. string库中所有的function都不会直接操作字符串，而是返回一个结果

### 4.1 string.byte(string [,pos])

返回第pos个字符的整数表示形式.如a为97.

### 4.2 string.char(i1,i2…)

i1,i2为整型,将i1,i2..等转化为对应的字符然后连接成字符串,并返回.如i1=97则返回a.

### 4.3 string.dump(functoin)

返回一个参数函数的2进制代码.(疑问)

### 4.4 string.find(s,pattern [,init [,plain]])

查找pattern在s中的位置,返回pattern在s中的开始位置和结束位置.init是开始查找的位置.plain未知.

### 4.5 string.format (formatstring, ···)

返回一个具有相应格式的字符串

### 4.6 string.gmatch (s, pattern)

这个函数基本就是用来配合for循环使用的，返回一个迭代器函数，每次调用这个迭代器函数都会返回一个匹配该字符串的值。

    
    
    s = "hello world from Lua"
         for w in string.gmatch(s, "%a+") do
       print(w)
         end
    
    string.gsub (s, pattern, repl [, n])
    

这个函数用来进行字符替换的。将每个匹配的字符串替换成指定的字符串repl。返回替换完毕的字符串和替换的次数。个人觉得这个函数非常有意思。

若repl为函数则会用匹配到的参数作为参数调用这个函数，若repl为table，则会用匹配到的参数作为键去查找这个表。

### 4.7 string.len(s):

返回字符串的长度.

### 4.8 string.lower(s):

变小写.

### 4.9 string.match (s, pattern [, init])

这个函数与find()函数类似，不同的是，find返回匹配的索引，这个函数返回第一个匹配的内容本身，

### 4.10 string.pack (fmt, v1, v2, ···)

返回一个fmt格式的二进制的包含v1和v2的字符串

### 4.11 string.packsize (fmt)

返回上面那个给定格式的size

### 4.12 string.upper(s):

变大写.

### 4.13 string.rep (s, n [, sep])

这个函数就是用来将某个字符串自我复制链接起来。

### 4.14 string.sub(s,i [,j])

取s中从i开始到j为止的自字符串.默认j为长度.-i表示倒数.

### 4.15 string.reverse (s)

反转字符串

### 4.16 string.sub (s, i [, j])

这个函数就是用来截取字符串。

### 4.17 string.unpack (fmt, s [, pos])

返回一个以fmt格式包装了的s。pos为可选参数，从s开始。读取值，也返回第一个没有从s读取的byte的功能

## 5\. Table Manipulation

### 5.1 table.concat(table, sep, start, end)

concat是concatenate(连锁, 连接)的缩写.
table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素,
元素间以指定的分隔符(sep)隔开。除了table外, 其他的参数都不是必须的, 分隔符的默认值是空字符, start的默认值是1,
end的默认值是数组部分的总长.

sep, start, end这三个参数是顺序读入的, 所以虽然它们都不是必须参数, 但如果要指定靠后的参数, 必须同时指定前面的参数.  
table.insert(table, pos, value)

### 5.2 table.insert()

函数在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.

### 5.3 table.remove(table, pos)

table.remove()函数删除并返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度,
即从最后一个元素删起.  
table.sort(table, comp)

### 5.4 table.sort()

函数对给定的table进行升序排序.

## 6\. Math

    
    
      | 函数名    描述        | 示例    |  结果  |
       | --------                    | -----:     | :----:   |
       | pi        圆周率    | math.pi      |   3.1415926535898    |
    |abs    取绝对值    | math.abs(-2012)|    2012|
    |ceil    向上取整    | math.ceil(9.1)    |10|
    |floor    向下取整    | math.floor(9.9)    |9|
    |max    取参数最大值|     math.max(2,4,6,8)|8|
    |min    取参数最小值    | math.min(2,4,6,8)    |2|
    |pow    计算x的y次幂|     math.pow(2,16)    |65536|
    |sqrt    开平方|     math.sqrt(65536)    |256|
    |mod    取模|     math.mod(65535,2)    |1|
    |modf    取整数和小数部分|     math.modf(20.12)    |20   0.12|
    |randomseed    设随机数种子|     math.randomseed(os.time())|     
    |random    取随机数|     math.random(5,90)    |5~90|
    |rad    角度转弧度|     math.rad(180)|3.1415926535898|
    |deg    弧度转角度|     math.deg(math.pi)    |180|
    |exp    e的x次方|     math.exp(4)|     |54.598150033144|
    |log    计算x的自然对数|     math.log(54.598150033144)|    4|
    |log10    计算10为底，x的对数|     math.log10(1000)|    3|
    |frexp    将参数拆成x * (2 ^ y)的形式|     math.frexp(160)|    0.625    8|
    |ldexp    计算x * (2 ^ y)|    math.ldexp(0.625,8)|    160|
    |sin          正弦|     math.sin(math.rad(30))|    0.5|
    |cos    余弦|     math.cos(math.rad(60))|    0.5|
    |tan    正切|     math.tan(math.rad(45))|    1|
    |asin    反正弦|     math.deg(math.asin(0.5))|    30|
    |acos    反余弦    | math.deg(math.acos(0.5))|    60|
    |atan    反正切|     math.deg(math.atan(1))|    45|
    

## 7.IO库

1、io表调用方式：使用io表，io.open将返回指定文件的描述，并且所有的操作将围绕这个文件描述

io表同样提供三种预定义的文件描述io.stdin,io.stdout,io.stderr

2、文件句柄直接调用方式,即使用file:XXX()函数方式进行操作,其中file为io.open()返回的文件句柄

多数I/O函数调用失败时返回nil加错误信息,有些函数成功时返回nil

### 7.1 io.close ([file])

功能：相当于file:close()，关闭默认的输出文件

### 7.2、io.flush ()

功能：相当于file:flush(),输出所有缓冲中的内容到默认输出文件  
io.input ([file])  
就是输入文件啊

### 7.3、io.lines ([filename])

功能：打开指定的文件filename为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件

若不带参数时io.lines() <=> io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件

如：  
  
for line in io.lines(“main.lua”) do

print(line)

end

### 7.4 io.open (filename [, mode])

功能：按指定的模式打开一个文件，成功则返回文件句柄，失败则返回nil+错误信息

mode:

“r”: 读模式 (默认);

“w”: 写模式;

“a”: 添加模式;

“r+”: 更新模式，所有之前的数据将被保存

“w+”: 更新模式，所有之前的数据将被清除

“a+”: 添加更新模式，所有之前的数据将被保存,只允许在文件尾进行添加

“b”: 某些系统支持二进制方式

### 7.5、io.output ([file])

功能：相当于io.input，但操作在默认输出文件上

### 7.6、io.popen ([prog [, mode]])

功能：开始程序prog于额外的进程,并返回用于prog的文件句柄(并不支持所有的系统平台)

### 7.7、io.read (…)

功能：相当于io.input():read

### 7.8、io.tmpfile ()

功能：返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除

### 7.9、io.type (obj)

功能：检测obj是否一个可用的文件句柄

返回：

“file”：为一个打开的文件句柄

“closed file”：为一个已关闭的文件句柄

nil:表示obj不是一个文件句柄

### 7.10、io.write (…)

功能：相当于io.output():write

### 7.11、file:close()

功能：关闭文件

注：当文件句柄被垃圾收集后，文件将自动关闭。句柄将变为一个不可预知的值

### 7.12、file:flush()

功能：向文件写入缓冲中的所有数据

### 7.13、file:lines()

功能：返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件

如：for line in file:lines() do body end

### 7.14、file:read(…)

功能：按指定的格式读取一个文件,按每个格式函数将返回一个字串或数字,如果不能正确读取将返回nil,若没有指定格式将指默认按行方式进行读取

格式：

“*n”: 读取一个数字

“*a”: 从当前位置读取整个文件,若为文件尾，则返回空字串

“*l”: [默认]读取下一行的内容,若为文件尾，则返回nil

number: 读取指定字节数的字符,若为文件尾，则返回nil;如果number为0则返回空字串,若为文件尾，则返回nil;

### 7.15、file:seek([whence][,offset])

功能：设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息

参数

whence:

“set”: 从文件头开始

“cur”: 从当前位置开始[默认]

“end”: 从文件尾开始

offset:默认为0

不带参数file:seek()则返回当前位置,file:seek(“set”)则定位到文件头,file:seek(“end”)则定位到文件尾并返回文件大小

### 7.16、file:setvbuf(mode,[,size])

功能：设置输出文件的缓冲模式

参数

mode:

“no”: 没有缓冲，即直接输出

“full”: 全缓冲，即当缓冲满后才进行输出操作(也可调用flush马上输出)

“line”: 以行为单位，进行输出(多用于终端设备)

最后两种模式,size可以指定缓冲的大小(按字节)，忽略size将自动调整为最佳的大小

### 7.17、file:write(…)

## 8.OS库

### 8.1 os.clock ()

功能：返回一个程序使用CPU时间的一个近似值  
os.date ([format [, time]])  
功能：返回一个按format格式化日期、时间的字串或表  
若设置time参数，则按time指定的时间格式化，否则按当前时间格式化  
参数：  
format:  
“!”:按格林尼治时间进行格式化。  
“ _t”:将返一个带year(4位),month(1-12), day (1–31), hour (0-23), min (0-59), sec
(0-61), wday (星期几, 星期天为1), yday (年内天数), and isdst (是否为日光节约时间true/false)的带键名的表;
若没有”_ t”则返回一个按C的strftime函数格式化的字符串  
若不带参数，则按当前系统的设置返回格式化的字符串 os.date() <=> os.date(“%c”)

### 8.2 os.difftime (t2, t1)

功能：返回t1到t2相差的秒数

### 8.3 os.execute ([command])

功能：相当于C的system函数,返回系统状态码

### 8.4 os.exit()

功能：相当于C的exit函数,终止主程序,code为返回值

### 8.5 os.getenv (varname)-

功能：返回当前进程的环境变量varname的值,若变量没有定义时返回nil

### 8.6 os.remove (filename)

功能：删除文件或一个空目录,若函数调用失败则返加nil加错误信息

### 8.7 os.rename (oldname, newname)

功能：更改一个文件或目录名,若函数调用失败则返加nil加错误信息

### 8.8os.setlocale (locale [, category])

功能：设置程序的当前设置,函数返回最新的值，失败则返回nil  
参数：  
locale：一个指定当前设置的字串  
“”:一个空字串，当前设置被视为本地设置  
“c”:当前设置被视为标准c设置  
nil:返回category指示设置名的当前值  
category：一个描述要更改的设置名  
“all”[默认], “collate”, “ctype”, “monetary”, “numeric”, “time”

### 8.9 os.time ([table])

功能：按table的内容返回一个时间值(数字),若不带参数则返回当前时间table的字段：

### 8.10 os.tmpname()

功能：返回一个临时文件名