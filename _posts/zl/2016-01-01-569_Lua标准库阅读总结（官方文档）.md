---
layout: post
title: Lua标准库阅读总结（官方文档） 
tags: [lua文章]
categories: [topic]
---
<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
		</div>
		
		<p>Lua的标准库直接通过C语言的API进行实现的。有一些函数对于这个语言提供的功能是必不可少的（例如getmetatable和type又元表是lua的一个重要语言特性，还会总结哒）其他的提供了一些输出到外部的功能（例如IO）还有一些很有用的但是用lua自身进行实现的一些函数（例如table.sort）</p>
<h2 id="库的大纲"><a href="#库的大纲" class="headerlink" title="库的大纲"></a>库的大纲</h2><p>所有的库都是通过官方的C语言的API就像C的API的一样的进行分离。</p>
<pre><code>1.basic library 
2.coroutine library 
3.package library 
4.string manipulation 
5.basic UTF-8 support 
6.table manipulation 
7.mathematical functions 
8.input and output 
9.operating system facilities 
10.debug facilities 
</code></pre><p>还有一堆废话告诉你这些库使用什么调用的。</p>
<h2 id="1-Basic-Functions"><a href="#1-Basic-Functions" class="headerlink" title="1.Basic Functions"></a>1.Basic Functions</h2><p>basic library是lua的核心，如果你并没有使用他们的话，你得自己去实现这些功能才可以</p>
<h3 id="1-1-assert-v-message"><a href="#1-1-assert-v-message" class="headerlink" title="1.1 assert (v [, message])"></a>1.1 assert (v [, message])</h3><p>功能：相当于C的断言，<br/>参数：<br/>v：当表达式v为nil或false将触发错误,<br/>message：发生错误时返回的信息，默认为”assertion failed!”</p>
<h3 id="1-2-collectgarbage-opt-arg"><a href="#1-2-collectgarbage-opt-arg" class="headerlink" title="1.2 collectgarbage (opt [, arg])"></a>1.2 collectgarbage (opt [, arg])</h3><p>功能：是垃圾收集器的通用接口，用于操作垃圾收集器<br/>参数：</p>
<p>1.opt：操作方法标志</p>
<p>2.”Stop”: 停止垃圾收集器 </p>
<p>3.”Restart”: 重启垃圾收集器 </p>
<p>4.”Collect”: 执行一次全垃圾收集循环</p>
<p>5.”Count”: 返回当前Lua中使用的内存量(以KB为单位)</p>
<p>6.”Step”: 单步执行一个垃圾收集. 步长 “Size” 由参数arg指定　(大型的值需要多步才能完成)，如果要准确指定步长，需要多次实验以达最优效果。如果步长完成一次收集循环，将返回True</p>
<p>7.”Setpause”: 设置 arg/100 的值作为暂定收集的时长 </p>
<p>8.”Setstepmul”: 设置 arg/100 的值，作为步长的增幅(即新步长＝旧步长*arg/100)<br/>“isrunning”: 返回一个bool值告诉你，垃圾回收器是否正在运行</p>
<h3 id="1-3-dofile-filename"><a href="#1-3-dofile-filename" class="headerlink" title="1.3 dofile (filename)"></a>1.3 dofile (filename)</h3><p>功能：打开并且执行一个lua块,当忽略参数filename时，将执行标准输入设备(stdin)的内容。返回所有块的返回值。当发生错误时，dofile将错误反射给调用者<br/>注：dofile不能在保护模式下运行</p>
<h3 id="1-4-error-message-level"><a href="#1-4-error-message-level" class="headerlink" title="1.4 error (message [, level])"></a>1.4 error (message [, level])</h3><p>功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)<br/>通常情况下，error会附加一些错误位置的信息到message头部.</p>
<p>Level参数指示获得错误的位置,<br/>Level=1[默认]：为调用error位置(文件+行号)<br/>Level=2：指出哪个调用error的函数的函数<br/>Level=0:不添加错误位置信息</p>
<h3 id="1-5-G全局环境表-全局变量"><a href="#1-5-G全局环境表-全局变量" class="headerlink" title="1.5 _G全局环境表(全局变量)"></a>1.5 _G全局环境表(全局变量)</h3><p>功能：记录全局环境的变量值的表 _G._G = _G</p>
<h3 id="1-6-getmetatable-object"><a href="#1-6-getmetatable-object" class="headerlink" title="1.6 getmetatable(object)"></a>1.6 getmetatable(object)</h3><p>功能：返回指定对象的元表(若object的元表有<strong>metatable这个字段，则返回object的元表.</strong>metatable的值)，当object没有元表时将返回nil<br/>若指定对象有元表，但是没有__metatable这个字段，则返回给定的对象的元表</p>
<h3 id="1-7-ipairs-t"><a href="#1-7-ipairs-t" class="headerlink" title="1.7 ipairs (t)"></a>1.7 ipairs (t)</h3><p>功能：返回三个值 迭代函数、表、0<br/>多用于穷举表的键名和键值对<br/>如：for i,v in ipairs(t) do<br/>[body]<br/>end<br/>每次循环将索引赋级i，键值赋给v<br/>就是得到(1,t[1]), (2,t[2])，一直到出现了第一个为nil的值</p>
<h3 id="1-7-load-chunk-chunkname-mode-env"><a href="#1-7-load-chunk-chunkname-mode-env" class="headerlink" title="1.7 load (chunk [, chunkname [, mode [, env]]])"></a>1.7 load (chunk [, chunkname [, mode [, env]]])</h3><p>功能：如果chunk是字符串则就是字符串，如果是函数则装载一个块中的函数，每次调用func将返回一个连接前一结的字串，在块结尾处将返回nil<br/>当没有发生错误时，将返回一个编译完成的块作为函数,否则返回nil加上错误信息，此函数的环境为全局环境<br/>chunkname用于错误和调试信息</p>
<h3 id="1-8-loadfile-filename-mode-env"><a href="#1-8-loadfile-filename-mode-env" class="headerlink" title="1.8 loadfile ([filename [, mode [, env]]])"></a>1.8 loadfile ([filename [, mode [, env]]])</h3><p>跟load类似，但装载的是文件或当没有指定filename时装载标准输入(stdin)的内容</p>
<h3 id="1-9-next-table-index"><a href="#1-9-next-table-index" class="headerlink" title="1.9 next (table [, index])"></a>1.9 next (table [, index])</h3><p>功能：允许程序遍历表中的每一个字段，返回下一索引和该索引的值。<br/>参数：table：要遍历的表<br/>　　　index：要返回的索引的前一索中的号，当index为nil[]时，将返回第一个索引的值，当索引号为最后一个索引或表为空时将返回nil<br/>注：可以用next(t)来检测表是否为空(此函数只能用于以数字索引的表与ipairs相类似)</p>
<h3 id="1-10-pairs-t"><a href="#1-10-pairs-t" class="headerlink" title="1.10 pairs (t)"></a>1.10 pairs (t)</h3><p>如果t有元方法__pairs,把t当作变量调用它并且从这个调用中返回第一个有三个results<br/>否则，返回三个值，next函数，表t，和空<br/>for k,v in pairs(t) do body end<br/>看见next，则要小心遍历中修改表的状况</p>
<h3 id="1-11-pcall-f-arg1-···"><a href="#1-11-pcall-f-arg1-···" class="headerlink" title="1.11 pcall (f [, arg1, ···])"></a>1.11 pcall (f [, arg1, ···])</h3><p>功能：在保护模式下调用函数(即发生的错误将不会反射给调用者)<br/>当调用函数成功能返回true,失败时将返回false加错误信息</p>
<h3 id="1-12-print-···"><a href="#1-12-print-···" class="headerlink" title="1.12 print (···)"></a>1.12 print (···)</h3><p>功能：简单的以tostring方式格式化输出参数的内容</p>
<h3 id="1-13-rawequal-v1-v2"><a href="#1-13-rawequal-v1-v2" class="headerlink" title="1.13 rawequal (v1, v2)"></a>1.13 rawequal (v1, v2)</h3><p>检查v1是否等于v2，并且不会调用__eq元表方法，返回一个bool值</p>
<h3 id="1-14-rawget-table-index"><a href="#1-14-rawget-table-index" class="headerlink" title="1.14 rawget (table, index)"></a>1.14 rawget (table, index)</h3><p>得到一个table[index]的真正的值，并且不会调用__index的元表方法，table必须是一个表，index可以是任何值</p>
<h3 id="1-15-rawlen-v"><a href="#1-15-rawlen-v" class="headerlink" title="1.15 rawlen (v)"></a>1.15 rawlen (v)</h3><p>返回v的长度，v可以是一个表也可以是一个字符串也不会调用__len元表方法，返回一个整型</p>
<h3 id="1-16-rawset-table-index-value"><a href="#1-16-rawset-table-index-value" class="headerlink" title="1.16 rawset (table, index, value)"></a>1.16 rawset (table, index, value)</h3><p>把value给table[index]，不会调用__newindex元表方法，table必须是一个表，index可以是不同于nil和NaN的任何值，value可以是任何lua的value。这个函数返回一个表</p>
<h3 id="1-17-select-index-···"><a href="#1-17-select-index-···" class="headerlink" title="1.17 select (index, ···)"></a>1.17 select (index, ···)</h3><p>功能：当index为数字将返回所有index大于index的参数:如：select(2,”a”,”b”) 返回 “b”<br/>当index为”#”，则返回参数的总个数(不包括index)</p>
<h3 id="1-18-setmetatable-table-metatable"><a href="#1-18-setmetatable-table-metatable" class="headerlink" title="1.18 setmetatable (table, metatable)"></a>1.18 setmetatable (table, metatable)</h3><p>功能：为指定的table设置元表metatable，如果metatable为nil则取消table的元表，当metatable有__metatable字段时，将触发错误<br/>这个函数返回表<br/>注：只能为LUA_TABLE 表类型指定元表</p>
<h3 id="1-19-tonumber-e-base"><a href="#1-19-tonumber-e-base" class="headerlink" title="1.19    tonumber (e [, base])"></a>1.19    tonumber (e [, base])</h3><p>功能：尝试将参数e转换为数字，当不能转换时返回nil<br/>base(2~36)指出参数e当前使用的进制，默认为10进制，如tonumber(11,2)=3</p>
<h3 id="1-20-tostring-v"><a href="#1-20-tostring-v" class="headerlink" title="1.20    tostring (v)"></a>1.20    tostring (v)</h3><p>功能：将参数e转换为字符串，此函数将会触发元表的__tostring事件<br/>type(v)<br/>功能：返回参数的类型名(“nil”，”number”, “string”, “boolean”, “table”, “function”, “thread”, “userdata”)</p>
<h3 id="1-21-VERSION"><a href="#1-21-VERSION" class="headerlink" title="1.21    _VERSION"></a>1.21    _VERSION</h3><p>功能：返回当前Lua的版本号”Lua 5.3”.<br/>xpcall (f, err)<br/>功能：与pcall类似，在保护模式下调用函数(即发生的错误将不会反射给调用者)<br/>但可指定一个新的错误处理函数句柄<br/>当调用函数成功能返回true,失败时将返回false加err返回的结果</p>
<h2 id="2-Coroutine-Manipulation"><a href="#2-Coroutine-Manipulation" class="headerlink" title="2.Coroutine Manipulation"></a>2.Coroutine Manipulation</h2><p>这个库函数包括了对于协同程序的操作，在表内进行协同<br/>文档中包含对于协同 程序的描述，自行查找吧</p>
<h3 id="2-1-coroutine-create-f"><a href="#2-1-coroutine-create-f" class="headerlink" title="2.1    coroutine.create (f)"></a>2.1    coroutine.create (f)</h3><p>创建一个包含f的新的协程，f必须是函数，返回一个新的协程，对象类型为thread</p>
<h3 id="2-2-coroutine-isyieldable"><a href="#2-2-coroutine-isyieldable" class="headerlink" title="2.2    coroutine.isyieldable ()"></a>2.2    coroutine.isyieldable ()</h3><p> 如果正在运行的协程可以让出，则返回真。值得注意的是，只有主协程（线程）和C函数中是无法让出的。</p>
<h3 id="2-3-coroutine-resume-co-val1-···"><a href="#2-3-coroutine-resume-co-val1-···" class="headerlink" title="2.3    coroutine.resume (co [, val1, ···])"></a>2.3    coroutine.resume (co [, val1, ···])</h3><p>这是一个非常重要的函数。用来启动或再次启动一个协程，使其由挂起状态变成运行状态。</p>
<p>　　可以这么说，resume函数相当于在执行协程中的方法。参数Val1…是执行协程co时传递给协程的方法。</p>
<p>　　首次执行协程co时，参数Val1…会传递给协程co的函数；</p>
<p>　　再次执行协程co时，参数Val1…会作为给协程co中上一次yeild的返回值。</p>
<p>　　不知道这句话大家理解了没，这是协程的核心。如果没理解也不用急，继续往下看，稍后我会详细解释。</p>
<p>　　resume函数返回什么呢？有3种情况：</p>
<p>　　1）、如果协程co的函数执行完毕，协程正常终止，resume 返回 true和函数的返回值。</p>
<p>　　2）、如果协程co的函数执行过程中，协程让出了（调用了yeild()方法），那么resume返回true和协程中调用yeild传入的参数。</p>
<p>　　3）、如果协程co的函数执行过程中发生错误，resume返回false与错误消息。</p>
<p>　　可以看到resume无论如何都不会导致程序崩溃。它是在保护模式下执行的。</p>
<h3 id="2-4-coroutine-running"><a href="#2-4-coroutine-running" class="headerlink" title="2.4    coroutine.running ()"></a>2.4    coroutine.running ()</h3><p> 用来判断当前执行的协程是不是主线程，如果是，返回运行的协程和true。</p>
<h3 id="2-5-coroutine-status-co"><a href="#2-5-coroutine-status-co" class="headerlink" title="2.5    coroutine.status (co)"></a>2.5    coroutine.status (co)</h3><p>　返回一个字符串，表示协程的状态。有4种状态：</p>
<p>　　1）、running。如果在协程的函数中调用status，传入协程自身的句柄，那么执行到这里的时候才会返回running状态。</p>
<p>　　2）、suspended。如果协程还未结束，即自身调用了yeild或还没开始运行，那么就是suspended状态。</p>
<p>　　3）、normal。如果协程Aresume协程B时，协程A处于的状态为normal。在协程B的执行过程中，协程A就一直处于normal状态。因为它这时候既不是挂起状态、也不是运行状态。</p>
<p>　　4）、dead。如果一个协程发生错误结束，或正常终止。那么就处于dead状态。如果这时候对它调用resume，将返回false和错误消息。</p>
<h3 id="2-6-coroutine-wrap-f"><a href="#2-6-coroutine-wrap-f" class="headerlink" title="2.6    coroutine.wrap (f)"></a>2.6    coroutine.wrap (f)</h3><p>wrap()也是用来创建协程的。只不过这个协程的句柄是隐藏的。跟create()的区别在于：</p>
<p>　　1）、wrap()返回的是一个函数，每次调用这个函数相当于调用coroutine.resume()。</p>
<p>　　2）、调用这个函数相当于在执行resume()函数。</p>
<p>　　3）、调用这个函数时传入的参数，就相当于在调用resume时传入的除协程的句柄外的其他参数。</p>
<p>　　4）、调用这个函数时，跟resume不同的是，它并不是在保护模式下执行的，若执行崩溃会直接向外抛出。</p>
<h3 id="2-7-coroutine-yield-···"><a href="#2-7-coroutine-yield-···" class="headerlink" title="2.7     coroutine.yield (···)"></a>2.7     coroutine.yield (···)</h3><p>　　使正在执行的函数挂起。</p>
<p>　　传递给yeild的参数会作为resume的额外返回值。</p>
<h2 id="3-Modules"><a href="#3-Modules" class="headerlink" title="3. Modules"></a>3. Modules</h2><p>这个库提供一个了一些加载module的基本工具方法在lua中。由require、module方法及package表组成</p>
<h3 id="3-1-require-modname"><a href="#3-1-require-modname" class="headerlink" title="3.1    require (modname)"></a>3.1    require (modname)</h3><p>功能：加载指定的模块。</p>
<p>　　此函数先检测package.loaded表中是否存在modname，存在则直接返回当中的值，没有则通过定义的加载器加载modname。<br/>　　    1) require机制相关的数据和函数<br/>    package.path:保存加载外部模块(lua中”模块”和”文件”这两个概念的分界比较含糊，因为这个值在不同的时刻会扮演不同的角色)的搜索 路径，这种路径是”模板式的路径”，它里面会包含可替代符号”?”,这个符号会被替换，然后lua查找这个文件是否存在，如果存在就会调用其中特定的接 口。典型的值为:<br/>    “./?.lua;./?.lc;/usr/local/?/init.lua”<br/>    如果lua代码中调用:require(“hello.world”)<br/>    那么lua会依次查找：<br/>    ./hello/world.lua ==&gt;这里”hello.world”变成了”hello/world”,并替换了模型”./?.lua”<br/>    ./hello/world.lc<br/>    …..<br/>    (这种处理方式和python类似，只不过不需要<strong>init</strong>.py,也有调用python中的<strong>init</strong>.py)<br/>    package.path在虚拟机启动的时候设置，如果存在环境变量LUA_PATH，那么就用该环境变量作为<br/>    它的值，并把这个环境变量中的”;;”替换为luaconf.h中定义的默认值，如果不存在该变量就直接使用<br/>    luaconf.h定义的默认值</p>
<p>   package.cpath:作用和packag.path一样,但它是用于加载第三方c库的。它的初始值可以通过环境变量<br/>    LUA_CPATH来设置<br/>    package.loadlib(libname, func):相当与手工打开c库libname, 并导出函数func返回，loadlib其实是ll_loadlib</p>
<p>　　2) 查找加载器顺序：</p>
<p>　　 require(在lua中它是ll_require函数)的查找顺序如下：<br/>       a.首先在package.loaded查找modelname,如果该模块已经存在，就直接返回它的值<br/>       b.在package.preload查找modelname, 如果preload存在，那么就把它作为loader，调用loader(L)<br/>       c.根据package.path的模式查找lua库modelname，这个库是通过module函数定义的，对于顶层的lua库，文件名和库名是一 样的而且不需要调用显式地在lua文件中调用module函数(在ll_require函数中可以看到处理方式)，也就是说lua会根据lua文件直接完 成一个loader的初始化过程。<br/>       d.根据package.cpath查找c库，这个库是符合lua的一些规范的(export具有一定特征的函数接口)，lua先已动态的方式加载该c库，然后在库中查找并调用相应名字的接口，例如:luaopen_hello_world<br/>       e.已第一个”.”为分割，将模块名划分为:(main, sub)的形式，根据package.cpath查找main，如果存在，就加载该库并查询相应的接口:luaopen_main_sub，例如：先查找 hello库，并查询luaopen_hello_world接口<br/>       f.得到loder后，用modname作为唯一的参数调用该loader函数。当然参数是通过lua的栈传递的，所以loader的原型必须符合lua的规范:int LUA_FUNC(lua_State *L)</p>
<p>  ll_require会将这个loader的返回值符给package.loaded[modelname],如果loader不返回值同时 package.loaded[modelname]不存在时, ll_require就会把package.loaded[modelname]设为true。最后ll_reuqire把package.loaded [modelname]返回给调用者。当加载失败时，require将触发错误</p>
<p>　　3) require的另一个功能是避免重复加载同一个文件两次。Lua保留一张所有已经加载的文件的列表（使用table保存）。如果一个加载的文件在表中存在require简单的返回；表中保留加载的文件的虚名，而不是实文件名。所以如果你使用不同的虚文件名require同一个文件两次，将会加载两次该文件。比如require “foo”和require “foo.lua”，路径为”?;?.lua”将会加载foo.lua两次。我们也可以通过全局变量_LOADED访问文件名列表，这样我们就可以判断文件是否被加载过；同样我们也可以使用一点小技巧让require加载一个文件两次。比如，require “foo”之后_LOADED[“foo”]将不为nil，我们可以将其赋值为nil，require”foo.lua”将会再次加载该文件。
　　</p>
<h3 id="3-2-package-cpath"><a href="#3-2-package-cpath" class="headerlink" title="3.2　　package.cpath"></a>3.2　　package.cpath</h3><p>　　功能：用于require　C loader的搜索路径</p>
<p>　　可以通过修改LUA_CPATH变量(luaconf.h)修改此值
　　    </p>
<h3 id="3-3-package-loaded"><a href="#3-3-package-loaded" class="headerlink" title="3.3　　package.loaded"></a>3.3　　package.loaded</h3><p>　　功能：一个用于让require知道哪些模块已加载的记录表，如果package.loaded已经有require要的值，则直接返回此值</p>
<h3 id="3-4-package-loadlib-libname-funcname"><a href="#3-4-package-loadlib-libname-funcname" class="headerlink" title="3.4　　package.loadlib (libname, funcname)"></a>3.4　　package.loadlib (libname, funcname)</h3><p>　　功能：通过动态连接C函数库方式加载Lua扩展库</p>
<p>　　libname为库文件名，funcname为入口函数(此函数必须为纯C接口函数 c++则需用 extern “C” {} 进行限制)</p>
<h3 id="3-5-package-path"><a href="#3-5-package-path" class="headerlink" title="3.5　　package.path"></a>3.5　　package.path</h3><p>　　功能：用于require　Lua loader的搜索路径</p>
<p>　　可以通过修改LUA_PATH变量(luaconf.h)修改此值</p>
<h3 id="3-6-package-preload"><a href="#3-6-package-preload" class="headerlink" title="3.6     package.preload"></a>3.6     package.preload</h3><p>　　功能：一个用于保存特殊模块加载器的表
　　</p>
<h3 id="3-7-package-seeall-module"><a href="#3-7-package-seeall-module" class="headerlink" title="3.7　　package.seeall(module)"></a>3.7　　package.seeall(module)</h3><p>　　功能：为module设置一个元表，此元表的__index字段的值为全局环境_G。所以module可以访问全局环境</p>
<p>　　注：以此函数作为module()的一个选项(详细见module())
　　</p>
<h3 id="3-8-package-searchers"><a href="#3-8-package-searchers" class="headerlink" title="3.8　　package.searchers"></a>3.8　　package.searchers</h3><p>　　<br/>　　一个使用require去控制加载modules的表，这个表的每一个入欧都是searcher函数，当寻找一个module的时候，require使用升序排列调用每一个searchers根据module的name（参数必须失由require给的）作为他自己唯一的参数。这个函数可以返回另一个函数（loader的module）加上一个额外的值。经由那个loader传递的值，或者一个为什么没有找到那个module的解释的字符串（如果没有什么说的就输出nil）lua初始化一个表需要四个searcher的函数<br/>　　第一个searcher 就是loader这个package.preload 表<br/>　　第二个搜索器就是查找一个加载起作为lua的库，使用package.path.这个路径进行存储的，这个seach工作完成使用package.searchpath.进行描述<br/>　　第三个搜索器查找一个C的库的加载器，使用给定的变量的路径package.cpath. 进行加载。这个seach工作完成使用package.searchpath.进行描述<br/>　　。。。<br/>　　所有的搜索器除了第一个是返回一个preload作为一个额外的值当被找到的时候，其他的都返回package.searchpath和一个额外的值。第一个搜索器不返回任何额外的值</p>
<h3 id="3-9-package-searchpath-name-path-sep-rep"><a href="#3-9-package-searchpath-name-path-sep-rep" class="headerlink" title="3.9　　package.searchpath (name, path [, sep [, rep]])"></a>3.9　　package.searchpath (name, path [, sep [, rep]])</h3><p>根据给定的名字和路径进行查找
　　</p>
<h2 id="4-String-Manipulation"><a href="#4-String-Manipulation" class="headerlink" title="4.String Manipulation"></a>4.String Manipulation</h2><ol>
<li>string库中所有的字符索引从前往后是1,2,…;从后往前是-1,-2,…</li>
<li>string库中所有的function都不会直接操作字符串，而是返回一个结果</li>
</ol>
<h3 id="4-1-string-byte-string-pos"><a href="#4-1-string-byte-string-pos" class="headerlink" title="4.1        string.byte(string [,pos])"></a>4.1        string.byte(string [,pos])</h3><p>返回第pos个字符的整数表示形式.如a为97.</p>
<h3 id="4-2-string-char-i1-i2…"><a href="#4-2-string-char-i1-i2…" class="headerlink" title="4.2        string.char(i1,i2…)"></a>4.2        string.char(i1,i2…)</h3><p>i1,i2为整型,将i1,i2..等转化为对应的字符然后连接成字符串,并返回.如i1=97则返回a.</p>
<h3 id="4-3-string-dump-functoin"><a href="#4-3-string-dump-functoin" class="headerlink" title="4.3        string.dump(functoin)"></a>4.3        string.dump(functoin)</h3><p>返回一个参数函数的2进制代码.(疑问)</p>
<h3 id="4-4-string-find-s-pattern-init-plain"><a href="#4-4-string-find-s-pattern-init-plain" class="headerlink" title="4.4 string.find(s,pattern [,init [,plain]])"></a>4.4 string.find(s,pattern [,init [,plain]])</h3><p>查找pattern在s中的位置,返回pattern在s中的开始位置和结束位置.init是开始查找的位置.plain未知.</p>
<h3 id="4-5-string-format-formatstring-···"><a href="#4-5-string-format-formatstring-···" class="headerlink" title="4.5        string.format (formatstring, ···)"></a>4.5        string.format (formatstring, ···)</h3><p>返回一个具有相应格式的字符串</p>
<h3 id="4-6-string-gmatch-s-pattern"><a href="#4-6-string-gmatch-s-pattern" class="headerlink" title="4.6    string.gmatch (s, pattern)"></a>4.6    string.gmatch (s, pattern)</h3><p>这个函数基本就是用来配合for循环使用的，返回一个迭代器函数，每次调用这个迭代器函数都会返回一个匹配该字符串的值。</p>
<pre><code>s = &#34;hello world from Lua&#34;
     for w in string.gmatch(s, &#34;%a+&#34;) do
   print(w)
     end

string.gsub (s, pattern, repl [, n])
</code></pre><p>这个函数用来进行字符替换的。将每个匹配的字符串替换成指定的字符串repl。返回替换完毕的字符串和替换的次数。个人觉得这个函数非常有意思。</p>
<p>若repl为函数则会用匹配到的参数作为参数调用这个函数，若repl为table，则会用匹配到的参数作为键去查找这个表。</p>
<h3 id="4-7-string-len-s"><a href="#4-7-string-len-s" class="headerlink" title="4.7 string.len(s):"></a>4.7 string.len(s):</h3><p>返回字符串的长度.</p>
<h3 id="4-8-string-lower-s"><a href="#4-8-string-lower-s" class="headerlink" title="4.8 string.lower(s):"></a>4.8 string.lower(s):</h3><p>变小写.</p>
<h3 id="4-9-string-match-s-pattern-init"><a href="#4-9-string-match-s-pattern-init" class="headerlink" title="4.9 string.match (s, pattern [, init])"></a>4.9 string.match (s, pattern [, init])</h3><p>这个函数与find()函数类似，不同的是，find返回匹配的索引，这个函数返回第一个匹配的内容本身，</p>
<h3 id="4-10-string-pack-fmt-v1-v2-···"><a href="#4-10-string-pack-fmt-v1-v2-···" class="headerlink" title="4.10 string.pack (fmt, v1, v2, ···)"></a>4.10 string.pack (fmt, v1, v2, ···)</h3><p>返回一个fmt格式的二进制的包含v1和v2的字符串</p>
<h3 id="4-11-string-packsize-fmt"><a href="#4-11-string-packsize-fmt" class="headerlink" title="4.11 string.packsize (fmt)"></a>4.11 string.packsize (fmt)</h3><p>返回上面那个给定格式的size</p>
<h3 id="4-12-string-upper-s"><a href="#4-12-string-upper-s" class="headerlink" title="4.12 string.upper(s):"></a>4.12 string.upper(s):</h3><p>变大写.</p>
<h3 id="4-13-string-rep-s-n-sep"><a href="#4-13-string-rep-s-n-sep" class="headerlink" title="4.13 string.rep (s, n [, sep])"></a>4.13 string.rep (s, n [, sep])</h3><p>这个函数就是用来将某个字符串自我复制链接起来。</p>
<h3 id="4-14-string-sub-s-i-j"><a href="#4-14-string-sub-s-i-j" class="headerlink" title="4.14    string.sub(s,i [,j])"></a>4.14    string.sub(s,i [,j])</h3><p>取s中从i开始到j为止的自字符串.默认j为长度.-i表示倒数.</p>
<h3 id="4-15-string-reverse-s"><a href="#4-15-string-reverse-s" class="headerlink" title="4.15    string.reverse (s)"></a>4.15    string.reverse (s)</h3><p>反转字符串</p>
<h3 id="4-16-string-sub-s-i-j"><a href="#4-16-string-sub-s-i-j" class="headerlink" title="4.16    string.sub (s, i [, j])"></a>4.16    string.sub (s, i [, j])</h3><p>这个函数就是用来截取字符串。</p>
<h3 id="4-17-string-unpack-fmt-s-pos"><a href="#4-17-string-unpack-fmt-s-pos" class="headerlink" title="4.17    string.unpack (fmt, s [, pos])"></a>4.17    string.unpack (fmt, s [, pos])</h3><p>返回一个以fmt格式包装了的s。pos为可选参数，从s开始。读取值，也返回第一个没有从s读取的byte的功能</p>
<h2 id="5-Table-Manipulation"><a href="#5-Table-Manipulation" class="headerlink" title="5. Table Manipulation"></a>5. Table Manipulation</h2><h3 id="5-1-table-concat-table-sep-start-end"><a href="#5-1-table-concat-table-sep-start-end" class="headerlink" title="5.1    table.concat(table, sep,  start, end)"></a>5.1    table.concat(table, sep,  start, end)</h3><p>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。除了table外, 其他的参数都不是必须的, 分隔符的默认值是空字符, start的默认值是1, end的默认值是数组部分的总长.</p>
<p>sep, start, end这三个参数是顺序读入的, 所以虽然它们都不是必须参数, 但如果要指定靠后的参数, 必须同时指定前面的参数.<br/>table.insert(table, pos, value)</p>
<h3 id="5-2-table-insert"><a href="#5-2-table-insert" class="headerlink" title="5.2    table.insert()"></a>5.2    table.insert()</h3><p>函数在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</p>
<h3 id="5-3-table-remove-table-pos"><a href="#5-3-table-remove-table-pos" class="headerlink" title="5.3    table.remove(table, pos)"></a>5.3    table.remove(table, pos)</h3><p>table.remove()函数删除并返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起.<br/>table.sort(table, comp)</p>
<h3 id="5-4-table-sort"><a href="#5-4-table-sort" class="headerlink" title="5.4    table.sort()"></a>5.4    table.sort()</h3><p>函数对给定的table进行升序排序.</p>
<h2 id="6-Math"><a href="#6-Math" class="headerlink" title="6. Math"></a>6. Math</h2><pre><code>  | 函数名    描述        | 示例    |  结果  |
   | --------                    | -----:     | :----:   |
   | pi        圆周率    | math.pi      |   3.1415926535898    |
|abs    取绝对值    | math.abs(-2012)|    2012|
|ceil    向上取整    | math.ceil(9.1)    |10|
|floor    向下取整    | math.floor(9.9)    |9|
|max    取参数最大值|     math.max(2,4,6,8)|8|
|min    取参数最小值    | math.min(2,4,6,8)    |2|
|pow    计算x的y次幂|     math.pow(2,16)    |65536|
|sqrt    开平方|     math.sqrt(65536)    |256|
|mod    取模|     math.mod(65535,2)    |1|
|modf    取整数和小数部分|     math.modf(20.12)    |20   0.12|
|randomseed    设随机数种子|     math.randomseed(os.time())|     
|random    取随机数|     math.random(5,90)    |5~90|
|rad    角度转弧度|     math.rad(180)|3.1415926535898|
|deg    弧度转角度|     math.deg(math.pi)    |180|
|exp    e的x次方|     math.exp(4)|     |54.598150033144|
|log    计算x的自然对数|     math.log(54.598150033144)|    4|
|log10    计算10为底，x的对数|     math.log10(1000)|    3|
|frexp    将参数拆成x * (2 ^ y)的形式|     math.frexp(160)|    0.625    8|
|ldexp    计算x * (2 ^ y)|    math.ldexp(0.625,8)|    160|
|sin          正弦|     math.sin(math.rad(30))|    0.5|
|cos    余弦|     math.cos(math.rad(60))|    0.5|
|tan    正切|     math.tan(math.rad(45))|    1|
|asin    反正弦|     math.deg(math.asin(0.5))|    30|
|acos    反余弦    | math.deg(math.acos(0.5))|    60|
|atan    反正切|     math.deg(math.atan(1))|    45|
</code></pre><h2 id="7-IO库"><a href="#7-IO库" class="headerlink" title="7.IO库"></a>7.IO库</h2><p>1、io表调用方式：使用io表，io.open将返回指定文件的描述，并且所有的操作将围绕这个文件描述</p>
<p>　　io表同样提供三种预定义的文件描述io.stdin,io.stdout,io.stderr</p>
<p>2、文件句柄直接调用方式,即使用file:XXX()函数方式进行操作,其中file为io.open()返回的文件句柄</p>
<p>　　多数I/O函数调用失败时返回nil加错误信息,有些函数成功时返回nil</p>
<h3 id="7-1-io-close-file"><a href="#7-1-io-close-file" class="headerlink" title="7.1 io.close ([file])"></a>7.1 io.close ([file])</h3><p>　　功能：相当于file:close()，关闭默认的输出文件</p>
<h3 id="7-2、io-flush"><a href="#7-2、io-flush" class="headerlink" title="7.2、io.flush ()"></a>7.2、io.flush ()</h3><p>　　功能：相当于file:flush(),输出所有缓冲中的内容到默认输出文件<br/>io.input ([file])<br/>就是输入文件啊</p>
<h3 id="7-3、io-lines-filename"><a href="#7-3、io-lines-filename" class="headerlink" title="7.3、io.lines ([filename])"></a>7.3、io.lines ([filename])</h3><p>　　功能：打开指定的文件filename为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件</p>
<p>　　若不带参数时io.lines() &lt;=&gt; io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件</p>
<p>　　如：<br/>　　<br/>　　    for line in io.lines(“main.lua”) do</p>
<p>　　    print(line)</p>
<p>　　    end</p>
<h3 id="7-4-io-open-filename-mode"><a href="#7-4-io-open-filename-mode" class="headerlink" title="7.4 io.open (filename [, mode])"></a>7.4 io.open (filename [, mode])</h3><p>　　功能：按指定的模式打开一个文件，成功则返回文件句柄，失败则返回nil+错误信息</p>
<p>　　mode:</p>
<p>　　“r”: 读模式 (默认);</p>
<p>　　“w”: 写模式;</p>
<p>　　“a”: 添加模式;</p>
<p>　　“r+”: 更新模式，所有之前的数据将被保存</p>
<p>　　“w+”: 更新模式，所有之前的数据将被清除</p>
<p>　　“a+”: 添加更新模式，所有之前的数据将被保存,只允许在文件尾进行添加</p>
<p>　　“b”: 某些系统支持二进制方式</p>
<h3 id="7-5、io-output-file"><a href="#7-5、io-output-file" class="headerlink" title="7.5、io.output ([file])"></a>7.5、io.output ([file])</h3><p>　　功能：相当于io.input，但操作在默认输出文件上</p>
<h3 id="7-6、io-popen-prog-mode"><a href="#7-6、io-popen-prog-mode" class="headerlink" title="7.6、io.popen ([prog [, mode]])"></a>7.6、io.popen ([prog [, mode]])</h3><p>　　功能：开始程序prog于额外的进程,并返回用于prog的文件句柄(并不支持所有的系统平台)</p>
<h3 id="7-7、io-read-…"><a href="#7-7、io-read-…" class="headerlink" title="7.7、io.read (…)"></a>7.7、io.read (…)</h3><p>　　功能：相当于io.input():read</p>
<h3 id="7-8、io-tmpfile"><a href="#7-8、io-tmpfile" class="headerlink" title="7.8、io.tmpfile ()"></a>7.8、io.tmpfile ()</h3><p>　　功能：返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除</p>
<h3 id="7-9、io-type-obj"><a href="#7-9、io-type-obj" class="headerlink" title="7.9、io.type (obj)"></a>7.9、io.type (obj)</h3><p>　　功能：检测obj是否一个可用的文件句柄</p>
<p>　　返回：</p>
<p>　　“file”：为一个打开的文件句柄</p>
<p>　　“closed file”：为一个已关闭的文件句柄</p>
<p>　　nil:表示obj不是一个文件句柄</p>
<h3 id="7-10、io-write-…"><a href="#7-10、io-write-…" class="headerlink" title="7.10、io.write (…)"></a>7.10、io.write (…)</h3><p>　　功能：相当于io.output():write</p>
<h3 id="7-11、file-close"><a href="#7-11、file-close" class="headerlink" title="7.11、file:close()"></a>7.11、file:close()</h3><p>　　功能：关闭文件</p>
<p>　　注：当文件句柄被垃圾收集后，文件将自动关闭。句柄将变为一个不可预知的值</p>
<h3 id="7-12、file-flush"><a href="#7-12、file-flush" class="headerlink" title="7.12、file:flush()"></a>7.12、file:flush()</h3><p>　　功能：向文件写入缓冲中的所有数据</p>
<h3 id="7-13、file-lines"><a href="#7-13、file-lines" class="headerlink" title="7.13、file:lines()"></a>7.13、file:lines()</h3><p>　　功能：返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件</p>
<p>　　如：for line in file:lines() do body end</p>
<h3 id="7-14、file-read-…"><a href="#7-14、file-read-…" class="headerlink" title="7.14、file:read(…)"></a>7.14、file:read(…)</h3><p>　　功能：按指定的格式读取一个文件,按每个格式函数将返回一个字串或数字,如果不能正确读取将返回nil,若没有指定格式将指默认按行方式进行读取</p>
<p>　　格式：</p>
<p>　　“*n”: 读取一个数字</p>
<p>　　“*a”: 从当前位置读取整个文件,若为文件尾，则返回空字串</p>
<p>　　“*l”: [默认]读取下一行的内容,若为文件尾，则返回nil</p>
<p>　　number: 读取指定字节数的字符,若为文件尾，则返回nil;如果number为0则返回空字串,若为文件尾，则返回nil;</p>
<h3 id="7-15、file-seek-whence-offset"><a href="#7-15、file-seek-whence-offset" class="headerlink" title="7.15、file:seek([whence][,offset])"></a>7.15、file:seek([whence][,offset])</h3><p>　　功能：设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息</p>
<p>　　参数</p>
<p>　　whence:</p>
<p>　　“set”: 从文件头开始</p>
<p>　　“cur”: 从当前位置开始[默认]</p>
<p>　　“end”: 从文件尾开始</p>
<p>　　offset:默认为0</p>
<p>　　不带参数file:seek()则返回当前位置,file:seek(“set”)则定位到文件头,file:seek(“end”)则定位到文件尾并返回文件大小</p>
<h3 id="7-16、file-setvbuf-mode-size"><a href="#7-16、file-setvbuf-mode-size" class="headerlink" title="7.16、file:setvbuf(mode,[,size])"></a>7.16、file:setvbuf(mode,[,size])</h3><p>　　功能：设置输出文件的缓冲模式</p>
<p>　　参数</p>
<p>　　mode:</p>
<p>　　“no”: 没有缓冲，即直接输出</p>
<p>　　“full”: 全缓冲，即当缓冲满后才进行输出操作(也可调用flush马上输出)</p>
<p>　　“line”: 以行为单位，进行输出(多用于终端设备)</p>
<p>　　最后两种模式,size可以指定缓冲的大小(按字节)，忽略size将自动调整为最佳的大小</p>
<h3 id="7-17、file-write-…"><a href="#7-17、file-write-…" class="headerlink" title="7.17、file:write(…)"></a>7.17、file:write(…)</h3><p>　　</p>
<h2 id="8-OS库"><a href="#8-OS库" class="headerlink" title="8.OS库"></a>8.OS库</h2><h3 id="8-1-os-clock"><a href="#8-1-os-clock" class="headerlink" title="8.1 os.clock ()"></a>8.1 os.clock ()</h3><p>功能：返回一个程序使用CPU时间的一个近似值<br/>os.date ([format [, time]])<br/>功能：返回一个按format格式化日期、时间的字串或表<br/>若设置time参数，则按time指定的时间格式化，否则按当前时间格式化<br/>参数：<br/>  format:<br/>         “!”:按格林尼治时间进行格式化。<br/>  　　　　“<em>t”:将返一个带year(4位),month(1-12), day (1–31), hour (0-23), min (0-59), sec (0-61), wday (星期几, 星期天为1), yday (年内天数), and isdst (是否为日光节约时间true/false)的带键名的表; 若没有”</em>t”则返回一个按C的strftime函数格式化的字符串<br/>  若不带参数，则按当前系统的设置返回格式化的字符串 os.date() &lt;=&gt; os.date(“%c”)</p>
<h3 id="8-2-os-difftime-t2-t1"><a href="#8-2-os-difftime-t2-t1" class="headerlink" title="8.2 os.difftime (t2, t1)"></a>8.2 os.difftime (t2, t1)</h3><p>功能：返回t1到t2相差的秒数</p>
<h3 id="8-3-os-execute-command"><a href="#8-3-os-execute-command" class="headerlink" title="8.3 os.execute ([command])"></a>8.3 os.execute ([command])</h3><p>功能：相当于C的system函数,返回系统状态码</p>
<h3 id="8-4-os-exit"><a href="#8-4-os-exit" class="headerlink" title="8.4 os.exit()"></a>8.4 os.exit()</h3><p>功能：相当于C的exit函数,终止主程序,code为返回值</p>
<h3 id="8-5-os-getenv-varname"><a href="#8-5-os-getenv-varname" class="headerlink" title="8.5 os.getenv (varname)-"></a>8.5 os.getenv (varname)-</h3><p>功能：返回当前进程的环境变量varname的值,若变量没有定义时返回nil</p>
<h3 id="8-6-os-remove-filename"><a href="#8-6-os-remove-filename" class="headerlink" title="8.6 os.remove (filename)"></a>8.6 os.remove (filename)</h3><p>功能：删除文件或一个空目录,若函数调用失败则返加nil加错误信息</p>
<h3 id="8-7-os-rename-oldname-newname"><a href="#8-7-os-rename-oldname-newname" class="headerlink" title="8.7 os.rename (oldname, newname)"></a>8.7 os.rename (oldname, newname)</h3><p>功能：更改一个文件或目录名,若函数调用失败则返加nil加错误信息</p>
<h3 id="8-8os-setlocale-locale-category"><a href="#8-8os-setlocale-locale-category" class="headerlink" title="8.8os.setlocale (locale [, category])"></a>8.8os.setlocale (locale [, category])</h3><p>功能：设置程序的当前设置,函数返回最新的值，失败则返回nil<br/>参数：<br/>　　locale：一个指定当前设置的字串<br/>　　　　　 “”:一个空字串，当前设置被视为本地设置<br/>　　　　　“c”:当前设置被视为标准c设置<br/> 　　　　 nil:返回category指示设置名的当前值<br/>　　category：一个描述要更改的设置名<br/>         “all”[默认], “collate”, “ctype”, “monetary”, “numeric”, “time”</p>
<h3 id="8-9-os-time-table"><a href="#8-9-os-time-table" class="headerlink" title="8.9 os.time ([table])"></a>8.9 os.time ([table])</h3><p>功能：按table的内容返回一个时间值(数字),若不带参数则返回当前时间table的字段：</p>
<h3 id="8-10-os-tmpname"><a href="#8-10-os-tmpname" class="headerlink" title="8.10 os.tmpname()"></a>8.10 os.tmpname()</h3><p>功能：返回一个临时文件名</p>