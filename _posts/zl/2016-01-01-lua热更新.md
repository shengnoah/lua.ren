---
layout: post
title: lua热更新 
tags: [lua文章]
categories: [lua文章]
---
#### 单纯热更新

Lua热更新  
最简单粗暴的热更新就是将package.loaded[modelname]的值置为nil，强制重新加载：

    
    
    function reload_module(module_name)
        package.loaded[modulename] = nil
        require(modulename)
    end
    

这样做虽然能完成热更，但问题是已经引用了该模块的地方不会得到更新， 因此我们需要将引用该模块的地方的值也做对应的更新。

    
    
    function reload_module(module_name)
        local old_module = _G[module_name]
        package.loaded[module_name] = nil
        require (module_name)
    
        local new_module = _G[module_name]
        for k, v in pairs(new_module) do
          old_module[k] = v
        end
    
        package.loaded[module_name] = old_module
    end
    

### 用途

>
> 在生产环境上，总有可能出现不可预知的Bug，而通常修改好Bug仅仅又修改几句，停机维护的成本又太高，对于游戏来说，通常每个服就是单独的进程，也做不到像分布式环境下，关掉一部分机器，先升级一部分，再升级另一部分的无缝升级。这时候如果有热更就可以迅速的把Bug修复方案通过热更新进行修复，不会对用户任何的影响。例如：

>   1. 业务逻辑有Bug
>   2. 配置的数据有误
>   3. 需求发生变更
>

### 热更新的原则

1、热更新不破坏原有数据

> 热更新更新的基本内容就是更新服务的逻辑，通常只是逻辑发生变化，但原有的值并不能被改变，例如：
    
    
    local a = 1
    function get_a()
        return a
    end
    

此时，我们调用get_a()返回是的1，我们将热更成

    
    
    local a = 2
    function get_a()
        print("get_a function")
        return a
    end
    

此时我们改变了a的初始值，但我们并不知道之前服务a的值是不是被重新赋过值，假设热更前a的值仍然为1，那么我们热更后调用get_a()返回的应该是1，而不应受新的初始值影响，而且同能打印出了”get_a
function”，这时候则认为热更正常。

2、不为热更新写更多的代码

>
> 热更新可以通过很多种方法实现，比如说模块为了支持数据不变的特性，需要在模块里额外写一些代码来记录旧值，热更新之后再把旧值copy过来，或者用一些特殊的语法来支撑。这种方法将会对项目增加很多的负担，而且一旦发生意料之外的Bug，热更系统几乎处于半瘫痪状态。应该来说，代码原本该怎么实现就怎么实现，对于99%的lua代码都是支持的，不需要修改来迎合热更新。通常热更新不改变原有变量值的类型。

### 热更新的实现，代码适用于5.2以上

#### 原理

> 利用_ENV环境，在加载的时候把数据加载到_ENV下，然后再通过对比的方式修改_G底下的值，从而实现热更新，函数
    
    
    function hotfix(chunk, check_name)
    

定义env的table，并为env设置_G访问权限，然后调用load实现把数据重新加载进来

    
    
    local env = {}
    setmetatable(env, { __index = _G })
    local _ENV = env
    local f, err = load(chunk, check_name,  't', env)
    assert(f,err)
    local ok, err = pcall(f)
    assert(ok,err)
    

此时env我们可以得到新函数有变更的部分，我们替换的为可见变量，也就是可直接访问的变量

    
    
    for name,value in pairs(env) do
        local g_value = _G[name]
        if type(g_value) ~= type(value) then
            _G[name] = value
        elseif type(value) == 'function' then
            update_func(value, g_value, name, 'G'..'  ')
            _G[name] = value
        elseif type(value) == 'table' then
            update_table(value, g_value, name, 'G'..'  ')
        end
    end
    

> 通过env当前的值和_G当前的值进行对比

>   1. 如果类型不同我们直接覆盖原值，此时value不为nil，不会出现原则被覆盖成nil的情况
>   2. 如果当前值为函数，我们进行函数的upvalue值比对
>

    
    
    function update_func(env_f, g_f, name, deep)
        --取得原值所有的upvalue，保存起来
        local old_upvalue_map = {}
        for i = 1, math.huge do
            local name, value = debug.getupvalue(g_f, i)
            if not name then break end
            old_upvalue_map[name] = value
        end
        --遍历所有新的upvalue，根据名字和原值对比，如果原值不存在则进行跳过，如果为其它值则进行遍历env类似的步骤
        for i = 1, math.huge do
            local name, value = debug.getupvalue(env_f, i)
            if not name then break end
            local old_value = old_upvalue_map[name]
            if old_value then
                if type(old_value) ~= type(value) then
                    debug.setupvalue(env_f, i, old_value)
                elseif type(old_value) == 'function' then
                    update_func(value, old_value, name, deep..'  '..name..'  ')
                elseif type(old_value) == 'table' then
                    update_table(value, old_value, name, deep..'  '..name..'  ')
                    debug.setupvalue(env_f, i, old_value)
                else
                    debug.setupvalue(env_f, i, old_value)
                end
            end
        end
    end
    

>   1. 如果当前值为table，我们遍历table值进行对比
>

    
    
    local protection = {
        setmetatable = true,
        pairs = true,
        ipairs = true,
        next = true,
        require = true,
        _ENV = true,
    }
    --防止重复的table替换，造成死循环
    local visited_sig = {}
    function update_table(env_t, g_t, name, deep)
        --对某些关键函数不进行比对
        if protection[env_t] or protection[g_t] then return end
        --如果原值与当前值内存一致，值一样不进行对比
        if env_t == g_t then return end
        local signature = tostring(g_t)..tostring(env_t)
        if visited_sig[signature] then return end
        visited_sig[signature] = true
        --遍历对比值，如进行遍历env类似的步骤
        for name, value in pairs(env_t) do
            local old_value = g_t[name]
            if type(value) == type(old_value) then
                if type(value) == 'function' then
                    update_func(value, old_value, name, deep..'  '..name..'  ')
                    g_t[name] = value
                elseif type(value) == 'table' then
                    update_table(value, old_value, name, deep..'  '..name..'  ')
                end
            else
                g_t[name] = value
            end
        end
        --遍历table的元表，进行对比
        local old_meta = debug.getmetatable(g_t)
        local new_meta = debug.getmetatable(env_t)
        if type(old_meta) == 'table' and type(new_meta) == 'table' then
            update_table(new_meta, old_meta, name..'s Meta', deep..'  '..name..'s Meta'..'  ' )
        end
    end
    

#### 更新

1、可以调用hotfix_file对整个文件进行热更

    
    
    function hotfix_file(name)
        local file_str
        local fp = io.open(name)
        if fp then
            io.input(name)
            file_str = io.read('*all')
            io.close(fp)
        end
    
        if not file_str then
            return -1
        end
        return hotfix(file_str, name)
    end
    

2、可以通过hotfix进行代码的更新

    
    
    function hotfix(chunk, check_name)
    

#### 关于坑

> 这里有一个注意事项，lua的module模块，如：
    
    
    module("AA", package.seeall)
    

当我们加载lua模块的时候，这时候这个模块信息并不像初始化全局代码一样，就算提前设置了package.loaded[“AA”] = nil,
也不会出现在env中同时也不会调用_G的__newindex函数，也就是说env[“AA”]为空，故这种写法无法进行热更新，所以通常模块的写法改成如下

    
    
    --定义模块AA
    AA = {}
    --相当于package.seeall
    setmetatable(AA, {__index = _G})
    --环境隔离
    local _ENV = AA