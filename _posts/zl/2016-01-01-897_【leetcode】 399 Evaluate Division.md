---
layout: post
title: 【leetcode】 399 Evaluate Division 
tags: [lua文章]
categories: [topic]
---
<p class="description">给出一些等式，求给定表达式的结果</p>

<p><img src="https://whutweihuan.github.io//2018/10/27/2018-10-27-blog/raindrop-3629132_640.jpg" alt="" width="100%"/><br/></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>方程式以A/B=k格式给出，其中A和B是用字符串表示的变量，k是实数（浮点数）。给定一些查询，返回答案。如果答案不存在，返回-1。</p>
<p>比如给定: A / B = 2.0，B / C = 3.0。<br/>要求: A / C = ？ B / A = ？ A / E = ？A / A = ？，X / X  = ？ …</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">输入: [ [&#34;a&#34;, &#34;b&#34;], [&#34;b&#34;, &#34;c&#34;] ],[2.0, 3.0],[ [&#34;a&#34;, &#34;c&#34;], [&#34;b&#34;, &#34;a&#34;], [&#34;a&#34;, &#34;e&#34;], [&#34;a&#34;, &#34;a&#34;], [&#34;x&#34;, &#34;x&#34;] ]</span><br/><span class="line">输出: [6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br/></pre></td></tr></tbody></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>初期想直接按照实体数字，比如将 a 设定成 1 ，就可以求出 b ， 递推求出其他的字母，后来发现这样做之后遇到之前两个字母都没有记录的数字会很麻烦，于是想用一个 rest 集合先保存这些两个字母都没被记录的，等第一轮结束后再进行 rest 集合的处理，后来发现这样也不行，原因在于 rest 集合中也会有两个同时没有出现的，难道再创建一个 rest 2 号吗 ? 显然这样十分的不合理。参考了一份代码，采用的是深度优先搜索，很厉害。注意对集合map&lt;string,&lt;string,map&gt; &gt;的理解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>代码</span><a href="https://github.com/haoel/leetcode/blob/master/algorithms/cpp/evaluateDivision/EvaluateDivision.cpp" target="_blank" rel="noopener noreferrer">来自</a></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  {</span></span><br/><span class="line"><span class="keyword">private</span>:</span><br/><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; &gt; &amp;m, </span></span></span><br/><span class="line"><span class="function"><span class="params">        <span class="built_in">string</span> startvalue, <span class="built_in">string</span> endvalue, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt; &amp;visited, <span class="keyword">double</span> &amp; res)</span> </span>{</span><br/><span class="line">        <span class="keyword">if</span> (m.find(startvalue) == m.end() || m.find(endvalue) == m.end()) { <span class="keyword">return</span> <span class="literal">false</span>;}</span><br/><span class="line">        <span class="keyword">if</span> (startvalue == endvalue) { <span class="keyword">return</span> <span class="literal">true</span>; }</span><br/><span class="line"></span><br/><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = m[startvalue].begin(); iter != m[startvalue].end(); iter++) {</span><br/><span class="line">            <span class="keyword">if</span> (visited.find(iter-&gt;first) != visited.end()) { <span class="keyword">continue</span>; }</span><br/><span class="line">            visited[iter-&gt;first] = <span class="literal">true</span>;</span><br/><span class="line">            <span class="keyword">double</span> old = res;</span><br/><span class="line">            res *= m[startvalue][iter-&gt;first];</span><br/><span class="line">            <span class="keyword">if</span> (dfs(m, iter-&gt;first, endvalue, visited, res)) { <span class="keyword">return</span> <span class="literal">true</span>; }</span><br/><span class="line">            visited.erase(iter-&gt;first);</span><br/><span class="line">            res = old;</span><br/><span class="line">        }</span><br/><span class="line"></span><br/><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">public</span>:</span><br/><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; calcEquation(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; queries) {</span><br/><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; result;</span><br/><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; &gt; m;</span><br/><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size();i++) {</span><br/><span class="line">            <span class="built_in">string</span> first = equations[i].first;</span><br/><span class="line">            <span class="built_in">string</span> second = equations[i].second;</span><br/><span class="line">            m[first][second] = values[i];</span><br/><span class="line">            m[second][first] = <span class="number">1.0</span> / values[i];</span><br/><span class="line">        }</span><br/><span class="line"></span><br/><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) {</span><br/><span class="line">            <span class="built_in">string</span> start = queries[i].first;</span><br/><span class="line">            <span class="built_in">string</span> end = queries[i].second;</span><br/><span class="line">            <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br/><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; visited;</span><br/><span class="line">            visited[start] = <span class="literal">true</span>;</span><br/><span class="line"></span><br/><span class="line">            <span class="keyword">if</span> (dfs(m, start, end, visited, res)) { result.push_back(res);}</span><br/><span class="line">            <span class="keyword">else</span> { result.push_back(<span class="number">-1.0</span>);}</span><br/><span class="line"></span><br/><span class="line">        }</span><br/><span class="line">        <span class="keyword">return</span> result;</span><br/><span class="line">    }</span><br/><span class="line">};</span><br/></pre></td></tr></tbody></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">原题链接</a></p>
<hr/>