---
layout: post
title: Lua GC 参数的含义 
tags: [lua文章]
categories: [topic]
---
<p>lua实现了简单的incremental mark-and-sweep collector，有两个参数会影响GC的工作方式：<strong>pause</strong>和<strong>step multiplier</strong>。</p>

<h2 id="概念">概念</h2>

<p>GC完整地清理一次内存的过程(“full gc”或”cycle”)由”标记内存是否垃圾”(<em>mark</em>)和”释放垃圾内存”(<em>sweep</em>“)两个阶段构成。一个cycle的开销通常比较大，理想情况下应该分割成多个开销较小的step。lua的GC引入一个变量<strong>debt</strong>,用以分割step，单位和内存是等比例的。如果debt是无穷大，一个step就会完成一个cycle的工作。debt&lt;=0时，GC停止工作。分配内存时debt会等比例的增大。在mark过程中，每标记一个正在使用的object，就会根据这个object的大小从debt减去一个等比例的数值。在sweep过程中，每释放一个object，就会根据这个object的大小从debt减去一个等比例的数值。在一个cycle完成后，GC会根据当前使用的内存和pause的值计算一个新的debt。</p>

<h2 id="数量关系">数量关系</h2>

<p>声明以下变量：</p>

<ul>
  <li>TotalMemory: Lua占用的内存。</li>
  <li>TotalMemoryInUse : 正在被使用的对象的内存总和。</li>
  <li>MemoryAllocatedInMark : Mark过程中分配的内存。</li>
  <li>MemoryMarked : Mark过程中已标记的内存</li>
  <li>MemoryAllocatedInSweep: Sweep过程中分配的内存。</li>
  <li>MemoryFreed： 释放的对象的内存总和。</li>
</ul>

<p>在Mark过程中，TotalMemory增加MemoryAllocatedInMark，debt的变化量是MemoryAllocatedInMark - MemoryMarked ；在Sweep过程中，TotalMemory的变化量是MemoryAllocatedInSweep - MemoryFreed，debt的变化量是 MemoryAllocatedInSweep - MemoryFreed。
在一个cycle完成之后，GC将debt的值重新设置为 TotalMemory * (1 - pause) * stepmul
内存增加时，debt也会相应的增加，step multiplier是两者的比例。</p>

<h2 id="示例分析">示例分析：</h2>

<h3 id="现象">现象</h3>

<p>在青柳谷中什么都不做，TotalMemory会有规律的波动，缓慢地增长到一个最大值(MemoryMax)后，快速地降低到一个最小值(MemoryBase)。设置不同的pause和set multiplier，统计数据如下：</p>

<table>
  <thead>
    <tr>
      <th>pause(%)</th>
      <th>stepmul(下面的值/200)</th>
      <th>MemoryBase(M)</th>
      <th>MemoryMax(M)</th>
      <th>内存增长时间(s)</th>
      <th>内存减少时间(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10</td>
      <td>200</td>
      <td>34</td>
      <td>37</td>
      <td>25.4</td>
      <td>4.6</td>
    </tr>
    <tr>
      <td>20</td>
      <td>200</td>
      <td>35</td>
      <td>41</td>
      <td>51.4</td>
      <td>6.5</td>
    </tr>
    <tr>
      <td>90</td>
      <td>200</td>
      <td>38</td>
      <td>64</td>
      <td>235.8</td>
      <td>28.7</td>
    </tr>
    <tr>
      <td>10</td>
      <td>100</td>
      <td>44</td>
      <td>70</td>
      <td>246</td>
      <td>73</td>
    </tr>
  </tbody>
</table>

<h3 id="原因">原因</h3>

<p>在游戏中什么都不做，所以TotalMemoryInUse是基本固定的，测试数据33M。内存缓慢增长是因为每个Tick都会分配少量(大约3~4k)垃圾内存。一个cycle跑完时内存达到最小值 MemoryBase = TotalMemoryInUse + MemoryAllocatedInSweep；Mark过程中内存会持续增长，所以Mark完成时达到最大值 MemoryMax = MemoryBase + MemoryAllocatedInMark。debt累积超过34M才能完成Mark，完成前一个cycle时会设置初始debt = TotalMemory * (1 - pause) * stepmul，如果debt &gt;= TotalMemoryInUse，GC会在下一个step完成Mark，进入Sweep；否则GC会停留在Mark阶段，等待内存分配。
以第二行数据为例，初始debt = 34 * (1 - 0.2) 即27.2M，不足以完成Mark，还缺少6.8M。内存增长到41M后，完成Mark。进入Sweep阶段后，开始释放内存，时长6.5秒，Tick分配的内存大约为  6.5* (41-35)/51.4约等于0.76M。</p>