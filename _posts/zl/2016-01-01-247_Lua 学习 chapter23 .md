---
layout: post
title: Lua 学习 chapter23  
tags: [lua文章]
categories: [topic]
---


                
                

				<h3 id="目录">目录</h3>
<ol>
  <li>弱引用表</li>
  <li>记忆函数</li>
  <li>环境和模块</li>
  <li>垃圾收集器</li>
</ol>



<h2 id="弱引用表">弱引用表</h2>
<p>弱引用表是用来告知lua语言一个引用不应该阻止对一个对象回收的机制。所谓弱引用是一种不在垃圾收集器考虑范围内的对象引用。如果一个对象都是所有的引用都是弱引用，那么垃圾回收器就可以回收这个对象，并把所有引用都删除了。
表是由键值对组成，一般情况下垃圾收集器不会回收一个在可访问表中作为值或者键的对象，键和值都是强引用。
在一个弱引用表中，键和值都可以是弱引用。</p>

<p>一个表是否为弱引用表是由原表中的__mode字段决定的，这个字段存在时，其值应该为一个字符串:这个字符串的值为”k”,那么表的键为弱引用，如果是”v”，值为弱应用，”kv”，表示这个表的键和值都是弱引用。</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">mt</span> <span class="o">=</span> <span class="p">{</span><span class="n">__mode</span> <span class="o">=</span> <span class="s2">"k"</span><span class="p">}</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
<span class="n">key</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">key</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">a</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nb">collectgarbage</span><span class="p">()</span><span class="c1">--第一个key就被回收了</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="记忆函数">记忆函数</h2>
<p>lua语言中处理全局变量的方式：</p>
<ul>
  <li>编译器在编译所有代码之前，在外层创建局部变量_ENV</li>
  <li>编译器将所有自由名称变换为_ENV.var;</li>
  <li>函数load(or loadfile)使用全局环境初始化代码段的第一个上值，即lua语言内部维护的一个普通表。</li>
</ul>

<p>_ENV只是一个普通的变量，将其赋值为nil会使得后续的代码不能直接访问全局变量。
我们还可以使用_ENV来绕过局部声明的变量，直接访问全局变量。</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="kd">local</span> <span class="nb">print</span><span class="p">,</span> <span class="n">sin</span> <span class="o">=</span> <span class="nb">print</span><span class="p">,</span> <span class="nb">math.sin</span>
<span class="n">_ENV</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span> <span class="c1">--error 访问不到全局</span>

<span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
<span class="kd">local</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">_ENV</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="c1">--访问全局的a，当然也可以使用_G来访问全局的a</span>

<span class="n">_ENV</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">--print is a nil</span>

<span class="n">a</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">_ENV</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="o">=</span> <span class="nb">_G</span><span class="p">}</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">g</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">_ENV</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">g</span><span class="p">.</span><span class="n">a</span><span class="p">}</span> <span class="c1">-- 1 , 15</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>通常_G和_ENV指向的是同一个表。但是，尽管如此，他们是很不一样的实体。_ENV是一个局部变量，所以对“全局变量”的访问实际上访问的都是_ENV。_G则是一个在任何情况下都没有任何特殊状态的全局变量。_ENV永远指向的是当前的环境；而假设在可见且无人改变过其值的前提下，_G通常指向的是全局变量。</p>

<p>_ENV的主要作用就是改变当前的环境。</p>

<h2 id="环境和模块">环境和模块</h2>
<p>为了防止污染全局环境：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kd">local</span> <span class="n">M</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_ENV</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">function</span> <span class="nf">hello</span><span class="p">()</span>
	<span class="nb">print</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">function</span> <span class="nf">sayHello</span><span class="p">()</span>
	<span class="n">hello</span><span class="p">()</span> <span class="c1">--M.hello</span>
<span class="k">end</span>

<span class="kd">local</span> <span class="n">M</span> <span class="o">=</span> <span class="p">{}</span>
<span class="kd">local</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="nb">math.sqrt</span>
<span class="kd">local</span> <span class="k">in</span> <span class="o">=</span> <span class="n">io</span>
<span class="n">_ENV</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="c1">--这样就不能进行外部访问了</span>


</pre></td></tr></tbody></table></code></pre></div></div>

<p>load函数通常被加载代码段的上值_ENV初始化为全局变量。</p>

<p>在lua中，<strong>一个具有弱引用的键和一个强引用的值的表是一个瞬表。</strong></p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">o</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="s2">"hi"</span><span class="p">}</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">{</span><span class="n">__gc</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="k">end</span><span class="p">})</span>
<span class="n">o</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="nb">collectgarbage</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>元函数__gc表示析构函数，在垃圾回收这个对象的时候会自动调用函数。</p>

<h2 id="垃圾收集器">垃圾收集器</h2>
<p>每一个垃圾回收周期由四个阶段组成：标记、清理、清除和析构。</p>
<ul>
  <li>标记阶段：把可达对象标记为活跃；</li>
  <li>清理阶段处：理析构器和弱引用表，这些没有被标记为活跃状态的对象会被标记为活跃（复苏），并放在一个单独的列表中，这个列表将在析构阶段使用。然后，lua遍历弱引用表并从中移除键或者值未被标记的元素。</li>
  <li>清除阶段：遍历所有对象，对象未被标记为活跃就回收，否则标记为清理标记，然后准备下一个清理周期。</li>
  <li>析构阶段：调用清理阶段被分离出来的对象的析构器。</li>
</ul>



                
                
                <hr style="visibility: hidden;">