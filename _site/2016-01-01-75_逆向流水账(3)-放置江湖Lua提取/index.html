<p>巧了，又有“江湖”。</p>

<p>这个江湖比爆炒江湖要复杂一点，不光是手动能做的事情更多<del>不是纯放置</del>，而且逆向流程也更长，还颇走了点弯路……</p>

<h2 id="不弯的路">不弯的路</h2>

<h3 id="frida-native-hook">Frida Native Hook</h3>

<p>关键函数长这样：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nm -DC libcocos2dlua.so | grep -i lual_load
# Signature是手动加的
0072f41c T luaL_loadbufferx(Lua_State *, char *lua_loadable, uint size, char *chunkname)
</code></pre></div></div>

<p>要用到后面三个参数：</p>

<ul>
  <li>lua_loadable: LuaJIT能认的Lua脚本或Bytecode，本文中是后者</li>
  <li>size: lua_loadable的长度</li>
  <li>chunkname: 可能是文件名也可能是其他，另存文件时候用得上</li>
</ul>

<p>Frida Hook：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var func = Module.findBaseAddress(&#34;libcocos2dlua.so&#34;).add(0x72f41c);
Interceptor.attach(func, {
  onEnter: function (args) {
    # 这里理论上应该用replace(all)而不是split和join..
    this.fileout = &#34;/sdcard/lua/&#34; + Memory.readCString(args[3]).split(&#34;/&#34;).join(&#34;.&#34;);
    console.log(&#34;read file from: &#34;+this.fileout);
    var tmp = Memory.readByteArray(args[1], args[2].toInt32());
    var file = new File(this.fileout, &#34;w&#34;);
    file.write(tmp);
    file.flush();
    file.close();
  }
});
</code></pre></div></div>

<h3 id="ljd-decompile-bytecode-to-pseudo-but-valid-lua">LJD Decompile Bytecode To Pseudo-but-valid Lua</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># clone这个fork
git clone https://github.com/Aussiemon/ljd
cd ljd

adb pull /sdcard/lua .
python3 main.py -r ../lua -d output
</code></pre></div></div>

<p><code class="highlighter-rouge">output/</code>里就是想要的东西了。</p>

<h2 id="弯路">弯路</h2>

<p>本来10分钟的工作量……</p>

<h3 id="用现成代码解密">用现成代码解密</h3>

<p>找到一个<a href="https://github.com/crazyyao0/codearchive/tree/master/reverse/%E6%94%BE%E7%BD%AE%E6%B1%9F%E6%B9%96">前辈帖子</a>，帖子说Signature是六位，当前版本已经有8位了，果然跑不出结果。然后又找了几个其他版本的xxtea_decrypt，浪费了不少时间。</p>

<p>帖子提到密钥长度是128bit（实际上他代码里用了个<a href="https://github.com/crazyyao0/codearchive/blob/master/reverse/%E6%94%BE%E7%BD%AE%E6%B1%9F%E6%B9%96/decode_lua/xxtea.cpp#L63">fix_key_length取前16位</a>），这和IDA里看到的、后来Frida观察内存里的，相互都不一样。。</p>

<h3 id="写一份代码解密">写一份代码解密</h3>

<p>仗着IDA和写过几行C++，直接忽略了网上的<a href="https://www.52pojie.cn/thread-682778-1-1.html">Hook教程</a>，直接准备从libcocos2dlua.so里翻译个decrypt.c来做这事——万一有些文件游戏不load咋办？而且，硬核玩家怎么会用Hook这么粗暴的手段呢？<del>还有到哪能找个Android 4.4真机来用Substrate？</del></p>

<p>写完没花多久，就是没写对，解不出东西来。不过写的过程中发现了xxtea_decrypt魔改过，.so里还遗留着许多对比文件签名根本不会跳进去的branch。</p>

<p>调bug陆陆续续用了好几天，最后还有个Overflow没什么头绪就先放着了，如果有人对此有研究或者感兴趣可以邮件/开Issue联系…… </p>

<h3 id="frida使用">Frida使用</h3>

<p>Frida文档倒是挺长的，就是参考价值不大，只能当函数列表用，所有的类型都要自己猜。其中有个Hook方法叫做findExportByName(“xxx.so”, “symbol”)，用它没找到loadbuffer，也没有看到错误日志，可能是因为直接把nm demangle的symbol传进去了……</p>

<p>另外本来应该<a href="https://github.com/frida/frida-node/blob/master/examples/hook_function.js">用Nodejs来跑</a>，这样有语法高亮和自动indent，而不是在Python里拼字符串，写流水账的时候才反应过来。</p>

<h3 id="luajit">LuaJIT</h3>

<p>找到LuaJIT版本编译之后，一开始想法是按游戏加载顺序把这些加载到内存里去，然后导出成表或者写几个函数直接查。试着按游戏原本顺序依次loadfile，有些许报错，但是接下来的操作就不会了。</p>

<p>跑去看了看文档，比Frida还简陋，又不想读它源代码，放弃。</p>

<h3 id="ljd年久失修">LJD年久失修</h3>

<p><a href="https://bbs.pediy.com/thread-216800-1.htm">这个帖子</a>说<a href="https://github.com/NightNord/ljd">LJD</a>要手动加Opcode，加完一跑报异常了，修修补补好一会儿，才想起肯定有前人干过这事，看了看<a href="https://github.com/NightNord/ljd/network/members">fork</a>，找到上文里那个能用的版本。</p>

<h2 id="接下来">接下来</h2>

<p>前端太不熟练了，不然（感觉）可以很快搭个查询页面出来……现在指针/ID类型太多，编辑器里查着挺麻烦的。</p>
