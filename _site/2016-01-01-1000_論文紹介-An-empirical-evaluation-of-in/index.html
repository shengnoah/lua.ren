<h2>論文紹介: An empirical evaluation of in-memory multi-version concurrency control</h2>

<p>書いた人: @nikezono</p>

<p>この解説記事はあまりに内容が粗雑だった．<br />
別の機会に作成したスライドを貼っておく．<br />
これを読めばこの記事の本文を読む必要はそれほどない．<br />
(そもそも論文を読めば解説記事など読む必要はないのだが)</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/key/hcUrSTeZyZLgHU" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""> </iframe>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/nikezono/an-empirical-evaluation-of-inmemory-multiversion-concurrency-control-84134634" title="論文紹介: An empirical evaluation of in-memory multi-version concurrency control" target="_blank" rel="noopener noreferrer">論文紹介: An empirical evaluation of in-memory multi-version concurrency control</a> </strong> from <strong><a href="https://www.slideshare.net/nikezono" target="_blank" rel="noopener noreferrer">Sho Nakazono</a></strong> </div>

<h1 id="要約">要約</h1>

<p><strong>マルチバージョン同時実行制御(MVCC)</strong> は昨今のDBMSにおいて最も使われている同時実行制御手法である．<br />
OracleやMySQL, PostgreSQLといった多くのデータベースがトランザクション処理の実装にMVCCを採用している．</p>

<p>しかし，MVCCという言葉は「マルチバージョンで実装すること」以上の意味を持っていない．MVCCという概念が包含するコンポーネントは非常に多く，その種類と組み合わせも膨大である．<br />
「MySQLとPostgreSQLはともにMVCCだからトランザクション性能は同じ」という言い方は明らかに乱暴であるように，MVCCの中での設計上の選択は数多く存在する．</p>

<p>この論文では，MVCCの設計と実装における重要な要素を四分類し，それぞれについてインメモリ・メニーコア環境でのベンチマークを行っている．</p>

<h1 id="acm-refs">ACM Refs</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Yingjun Wu, Joy Arulraj, Jiexi Lin, Ran Xian, and Andrew Pavlo. 2017.
An empirical evaluation of in-memory multi-version concurrency control.
Proc. VLDB Endow. 10, 7 (March 2017), 781-792.
DOI: https://doi.org/10.14778/3067421.3067427
</code></pre></div></div>

<h1 id="なぜこの論文を紹介するのか">なぜこの論文を紹介するのか</h1>

<p>近年，トランザクション処理の研究領域において前提となる環境は，メニーコアを持つインメモリデータベースである．<br />
このとき最大のボトルネックはディスクI/Oではなくキャッシュ競合や <code class="highlighter-rouge">malloc/free</code> といったメモリアクセスである．このため，単一バージョンの<a href="https://the-weekly-paper.github.io/jekyll/update/2017/06/11/on-optimistic-concurrency-control.html">OCC</a>が手法として選択されることが多い．</p>

<p>しかし，現実に市場で扱われているDBMSはといえば，PostgreSQLやMySQLといったオープンソースのDBMSから，SAP HANA, Oracleといったエンタープライズ系DBMSに至るまで，<br />
ほぼ全てがマルチバージョン同時実行制御(MVCC)を用いている．</p>

<p>ここにアカデミアとインダストリアルのギャップがある．</p>

<p>さて，MVCCとは何か? という点について少し説明する．大枠は<a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Wikipedia</a>の説明を読むと良い．</p>

<p>理論的な定式化が厳密になされている分野ではあるのだが，あえてざっくりした表現で説明すると，MVCCとは，その名の通り，「マルチバージョンのデータ構造を用いて同時実行制御を行う」ことである．</p>

<p>たとえば, 単純な配列の各要素に直接構造体を詰め込んでデータを管理するのが単一バージョンの同時実行制御だとする．ハッシュテーブルのようなものを想定すればよい．以下のような構造である．</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Monoversion
T1 : w(x)
T2 : w(y)
T3 : w(x)w(z)

[x3][y2][z3]...
</code></pre></div></div>

<p>対して，配列の各要素がポインタになっていて，そこから線形リストで各更新ごとのバージョンを辿れるデータ構造がMVCCである．<br />
 <em>(もちろん，MVCCは理論的にはデータ構造の制約は存在しない．一例として線形リストを挙げた．）</em></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Multiversion
T1 : w(x)
T2 : w(y)
T3 : w(x)w(z)

[x*][y*][z*]...
 |   |   |
[x1][y2][z3]
 |
[x3]
</code></pre></div></div>

<p>MVCCでは，更新がin-placeに行えないため，書き込み時に必ずメモリ上に新しい領域を必要とする．また，不要に線形リストを更新するため，キャッシュミス回数も増える．<br />
MVCCのほうが空間的にも時間的にも計算量が多いことは明らかである．</p>

<p>しかしMVCCはより<a href="http://d.hatena.ne.jp/okachimachiorz/20160104/1451904249">広いトランザクションのスケジュール空間</a>を許容する．仮に</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T4: r(x)r(y)r(z)
</code></pre></div></div>
<p>というトランザクションが同時に走っているとしよう．<br />
単一バージョンの同時実行制御であれば <code class="highlighter-rouge">T1</code> と <code class="highlighter-rouge">T3</code> はともに <code class="highlighter-rouge">x</code> を更新しているため，<br />
<code class="highlighter-rouge">T1</code>と<code class="highlighter-rouge">T3</code>の実行の間に <code class="highlighter-rouge">T4</code> が実行された場合は，他のトランザクションとの兼ね合いで直列化可能性(Serializability)に違反する可能性が出てくる．</p>

<p>これを安全に実行するためには，ロックを取るために待つか， <code class="highlighter-rouge">T4</code> はアボートしなければならない．<br />
どちらも性能に影響を与えることは言うまでもない．</p>

<p>さて， <code class="highlighter-rouge">T4</code> のようなクエリはデータベース運用の現場では一般的なものである．<code class="highlighter-rouge">SELECT COUNNT(*) FROM...</code> といったクエリはしばしばこういった実行に展開される．<br />
これが全てロックを取るかアボートする恐れがある，というのはかなり実用的ではない．</p>

<p>研究者にとっては無用なオーバヘッドが大きいとされるMVCCが，しかし依然として市場の大多数を支配していることにはこういった理由があるのではと考えることもできる．state-of-the-artのトランザクション性能は出なくとも，多様なクエリに対応できるスケジュール空間の広さがある．</p>

<p>さて一方で，MVCCのDBMSを実装する際には，MVCCの理論からは直交した実装上の選択がいくつか存在する．<br />
こうした選択は各DBMSの実装内部に留まる話であり，研究の世界で議論されてはこなかったものである．<br />
アカデミアとインダストリアルの壁を埋める同時実行手法がやはりMVCCしかないなら，MVCCの高すぎるオーバヘッドをどう削減していくか？というテーマこそが真に実用的な研究領域になる，ということもありえる．</p>

<p>以上の理由により，MVCCの特に実装面に注目して評価を行ったこの論文を紹介する．</p>

<h2 id="1-introduction">1. Introduction</h2>

<p>MVCCの手法は1970年代に確立されており，生成されるスケジュール空間についても既に証明されている．<br />
が，本格的に実装され用いられ始めたのはこの１０年のことである．</p>

<p>MVCCの強みは，一言で言うと理論的なスケジュール空間の広さ(<a href="http://d.hatena.ne.jp/okachimachiorz/20160104/1451904249">CSRに対するMVSR</a>[0])にある．</p>

<p>より実装に倒した言い方をすると，MVCCには<strong>in-placeに更新をしない</strong>ことによる恩恵がある．<br />
特に, Read-Only Transactionの場合はどれだけクエリが重かろうが必ずAbortしない，という特性が非常に強い．</p>

<p>たとえば，シンプルなKVS上で単一バージョン(Monoversion)とMVCCの実装を比較すると以下のようになる.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Monoversion
[x=2|10 &lt; TS &lt; INFINITY]

## Multiversion
[x=1|TS &lt; 3] -&gt; [x=2|TS &lt; 5] -&gt; [x=3|TS &lt; 10] -&gt; [x=2|TS &lt; INFINITY]

x: key
TS: トランザクションのタイムスタンプ(論理的な実行順序)
</code></pre></div></div>

<p>in-placeにデータを書き換えるmonoversionの同時実行制御方式というのは，チェーン末尾のデータしか見えないものと同等だ．<br />
つまり <code class="highlighter-rouge">10&lt;TS</code>のトランザクションしか <code class="highlighter-rouge">read(x)</code> 命令は成功しない．</p>

<p>一方でMVCCであれば，この場合いかなるタイムスタンプを割り当てられたトランザクションでも <code class="highlighter-rouge">read(x)</code> が成功する．</p>

<p>勿論，このチェーンをいつGC/コンパクションするか？という問題はある．<br />
もし，”最新のデータ以外をGCする”というスレッドがバックグラウンドで走っているとすれば，<br />
<code class="highlighter-rouge">read</code> が失敗することもありえるだろう．しかし，GCやロックを度外視すれば，理論的にはMVCCにおける <code class="highlighter-rouge">read</code> は必ず成功する．</p>

<p>この特性が，MVCCで<strong>”Read-Only Transactionはどれだけクエリが重かろうと必ずAbortしない”</strong> ことを保証している．</p>

<p>さて，ここ10年で一気に使われるようになったMVCCであるが、歴史はもっと古い.</p>

<ul>
  <li>1979: 初論文が出る</li>
  <li>1981: InterBase(現在のFirebird)で実装される</li>
  <li>1984: Oracle登場. いつからかは不明だがSIを使っている.</li>
  <li>1985: PostgreSQL登場. MVCC. 初期は<a href="https://www.postgresql.org/docs/6.3/static/c0503.htm">Time-traveling</a>[1]という機能もあった.</li>
  <li>2001: MySQL InnoDB登場. MVCCを使っている.</li>
  <li>そこからHekaton(SQL Server), SAP HANA, MemSQL, NuoDB, HYRISE, HyPerとMVCCの春が来た.</li>
</ul>

<p>これほど普及している手法にもかかわらずMVCCには <strong>“Standard implementation” がない</strong>．<br />
MVCCの実装手法にはいくつか設計上の選択があり，それぞれに非常に興味深いのだが，過去にそれを評価した文献を探すと80年代まで遡る. もちろんこれはディスクベースでシングルコアの環境でのベンチマークであり，現在のトランザクション研究の前提となるインメモリ・メニーコア環境での結果とは大きく異なる可能性がある．</p>

<p>ここがこの論文のContributionである．全ての実装上の設計と選択をインメモリ・メニーコア環境上で比較している．</p>

<p>しかし，ただ実装の効率性で殴るようなベンチマークになるとフェアではないので、<br />
既存の各DBMSのアプローチを全て<a href="https://github.com/cmu-db/peloton">Peloton</a>[2]に実装している．</p>

<h2 id="2-background">2. Background</h2>

<p>ここで既存のMVCCの実装を整理する.<br />
<img src="https://gyazo.com/bc1a2dc16f4f9dc880bcfe69d649e990.png" alt="" /></p>

<p>この図表は非常に面白い．<br />
今後ドラスティックな変更が各DBMSに無い限り，数年間にわたって使い回せる表である．</p>

<p>ベンチマークにおける実装の話をすると，本論文におけるMVCCでは</p>

<p><img src="https://gyazo.com/8933468a0a2fdafc3f383b55f579a98c.png" alt="" /></p>

<p>という構造体を使いまわす．この構造体はインメモリDBにおけるMVCCの実装を最初に示した(と思われる)<a href="http://dl.acm.org/citation.cfm?id=2095689">Hekaton</a>[3]にならっている.<br />
おおむね構造体の各メンバの命名通りの役割をしているため，説明は省く．</p>

<p>が，実装上の細かいポイントを述べると，ここでは <code class="highlighter-rouge">txn-id</code> の下位0bit目を排他ロックに用いる．<br />
すなわち<code class="highlighter-rouge">txn-id</code>をCompare-And-Swap(CAS)命令で書き換えることで，そのレコードの読み書き権限を得る．</p>

<p>なお，この実装はHekatonで提案されているそれとは異なる．Hekatonでは<code class="highlighter-rouge">begin-ts</code>や<code class="highlighter-rouge">end-ts</code>の下位0bit目をロックに用いており，構造体が少しコンパクトである．この論文では，複数の同時実行制御手法に対応する実装を行うために少し冗長な設計になっていると思われる．</p>

<h2 id="3-concurrencycontrol-protocols">3. ConcurrencyControl Protocols</h2>

<p>この章では同時実行制御手法を複数検討している．</p>

<p>前提として</p>

<ul>
  <li>Serializable</li>
  <li>tuple-level lock</li>
  <li>No range Query
    <ul>
      <li>MVCCであることはphantom問題の解決とは直交しているため，ベンチを取る意味がない</li>
    </ul>
  </li>
</ul>

<p>を置いている．</p>

<h3 id="31-mvto">3.1 MVTO</h3>

<p>1979に発明された<a href="http://dl.acm.org/citation.cfm?id=1286918">Timestamp Ordering</a>[4]のMVCC版.<br />
Timestamp Orderingの基本は「トランザクションIDをSerialization Orderとして予め与えておき、それに違反する読み書きをしたらabort」というプロトコルである．</p>

<p>大まかには，各タプルに <code class="highlighter-rouge">read timestamp</code> <code class="highlighter-rouge">write timestamp</code> を付与し，これを更新することで直列実行との等価性を検証する．すなわち，<code class="highlighter-rouge">write ts &lt; my_ts</code> のとき読めるし，<code class="highlighter-rouge">read_ts &lt; my_ts</code> のとき書ける，といった様に(厳密には異なるが)規定される．読み書きはすべてタイムスタンプの更新を伴う．<br />
これは前述した構造体に <code class="highlighter-rouge">read ts</code>を追加することで実装できる． <code class="highlighter-rouge">begin-ts</code> <code class="highlighter-rouge">end-ts</code> はそれぞれwrite timestampを記録する．<br />
タイムスタンプの獲得はトランザクション開始時<code class="highlighter-rouge">(beginning of read phase)</code>とする．</p>

<p>この実装は既存のDBMSには存在せず理論のみが提案されているものである．</p>

<h3 id="32-mvocc">3.2 MVOCC</h3>

<p><a href="https://the-weekly-paper.github.io/jekyll/update/2017/06/11/on-optimistic-concurrency-control.html">OCC</a>を用いたMVCCの実装．</p>

<ul>
  <li>read-phaseの最初にtidを決める.</li>
  <li>read phaseでは，自分が読める値(<code class="highlighter-rouge">begin-ts &lt; ts &lt; end-ts</code>のタプル)を読む.</li>
  <li>write-phaseでは<code class="highlighter-rouge">next</code>ポインタに新しいレコードをCAS命令で繋げる. (事実上これで<code class="highlighter-rouge">w-w</code>の依存関係は潰せる.)</li>
  <li><code class="highlighter-rouge">txn-id</code> にtidをセットしてロック済みとする.</li>
</ul>

<p>OCCのvalidation phaseではread-setに入っているタプルが変化しているか(チェーンが伸びているか)を調べる.</p>

<p>この実装はHekatonのものと殆ど同じ.</p>

<h3 id="33-mv2pl">3.3 MV2PL</h3>

<p>この論文のAuthorに名を連ねる<a href="http://www.cs.cmu.edu/~pavlo/">Andy Pavlo</a>が2016年の<a href="http://cmudb.io/15721-s16-lect02">CMUの講義</a>で「これは何でかわかるか?」と学生に聞いていた話が書いてある. 以下.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In a disk-based DBMS, locks are stored separately from tuples so that they are never swapped to disk.
This separation is unnecessary in an in-memory DBMS,
thus with MV2PL the locks are embedded in the tuple headers.
</code></pre></div></div>

<p>Andy Pavloは更にSIGMOD’17のKeynoteでもこの点がHekaton論文の偉大なcontributionであったと述べている.</p>

<p>要点は以下である．</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Two-phase_locking#Strict_two-phase_locking">S2PL</a>の実現のためには<strong>リーダーライターロック</strong>が必要．
    <ul>
      <li>このために <code class="highlighter-rouge">read-cnt</code> を構造体に追加.
        <ul>
          <li><code class="highlighter-rouge">read-cnt</code> をincrementすることでリーダーロックを取る．</li>
          <li>なお実際には<code class="highlighter-rouge">read-cnt</code>の64bitでライターロックも兼ねる．</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>2PLの性能を左右する大きな選択として，デッドロック回避アルゴリズムが挙げられる．
    <ul>
      <li>Monoversionの場合は <code class="highlighter-rouge">no-wait</code> が最もスケールすることが<a href="">先行研究</a>[5]で挙げられている</li>
    </ul>
  </li>
</ul>

<h3 id="34-serilization-certifier">3.4 Serilization Certifier</h3>

<p>いわゆる<a href="http://dl.acm.org/citation.cfm?id=1071615">SSI</a>[6]．<br />
あるいは<a href="http://dl.acm.org/citation.cfm?id=2771949">SSN</a>[7]というより軽量な実装も論文が出ている．</p>

<p>これはどちらも<code class="highlighter-rouge">r-w</code>の依存関係がcyclicであるかどうかを検出する機構である．</p>

<h3 id="35-discussion">3.5 Discussion</h3>

<p>どの手法もconflictへの取り組み方が違う.<br />
あるワークロードに強いものはあるワークロードに弱い．銀の弾丸はない．</p>

<ul>
  <li>MV2PLはリーダーライターロックを使うため，<code class="highlighter-rouge">read</code>命令でキャッシュを汚すオーバヘッドがある．
    <ul>
      <li>あるタプルへの読み書きが重なったら，どちらかがアボートする．</li>
    </ul>
  </li>
  <li>MVTOは<code class="highlighter-rouge">read-ts</code>を更新する．この点でMV2PLに近い挙動.
    <ul>
      <li>しかしロックで直列化しているわけではないので，読み書きが重なっても両方通りうることもある．</li>
    </ul>
  </li>
  <li>MVOCCはリーダーロックも<code class="highlighter-rouge">read timestamp</code>も使わない．つまり<code class="highlighter-rouge">r-w</code>の検出をしない．
    <ul>
      <li>アボートに倒す実装になっており，偽陽性がある．</li>
      <li>long-running read-only transactionが不要にアボートしうる．いわゆるStarvation．</li>
    </ul>
  </li>
</ul>

<p>さらなる最適化手法も検討されている.<br />
どちらも，<strong>「他のトランザクションにロックを取られているタプルを読み書きした場合にどうするか」</strong>という議論．</p>

<ul>
  <li><strong>speculatively read</strong> はHekatonのアプローチで，Dirtyな値を読んだ場合にそのタプルが永続化されるまで待つという手法．</li>
  <li><strong>eagerly update</strong> は上記に加えて，投機的にそのタプルをさらに上書きするチェーンを伸ばしてしまう手法．これは<code class="highlighter-rouge">w-w</code>の依存関係を作ってしまう．</li>
</ul>

<p>これらのアプローチは，全てのトランザクションがコミットに至ると仮定した場合には，不要なアボートを削減できる．<br />
ただでさえMVCCは新しいバージョンのタプルを生成するため<code class="highlighter-rouge">malloc</code>を発行したり，スレッドローカルな変数を多く用いることから，<br />
実装上のオーバヘッドが高いと言われているため，このような投機的実行は一つの選択としてありうる．</p>

<p>しかし，上記二種の最適化は，<a href="https://www.slideshare.net/nikezono/ss-73837761">いわゆる連鎖的アボートの回避スケジュールから回復可能スケジュールへの変更</a>であるため，注意深く実装しなければオーバヘッドが上回ることもある．</p>

<p>と，色々と考慮すべき点はあれども，マルチコアにおける原則は<strong>decentralized data structures/alghorithms</strong>である．</p>

<h2 id="4-version-storage">4. Version Storage</h2>

<p>MVCCは全ての更新を新しいバージョンの生成として行う.<br />
ここで用いるデータ構造は問わないが，一般的にはポインタを使う線形リストで実装される．<br />
MonoversionのDBMSに比べて，このリストの走査がパフォーマンスに与える影響というのが存在する．<br />
もちろん空間計算量も多く取ることになるため，キャッシュを意識した実装が性能に影響するということもある．</p>

<p>ここの実装の差分がもたらす性能差についてこの章では見ている．</p>

<p>大別すると３つの手法がある．</p>

<h3 id="41-append-only-storage">4.1 Append-only Storage</h3>

<p>PostgreSQL, Hekaton, MemSQLなどのアプローチ.<br />
Lock-free Doubly Linked Listを(現実的な速度で?)扱うことは難しいため, 単方向リストになることが一般的.</p>

<p>方向性に細かい決定がある．まずは「チェーンの方向」．</p>

<p><img src="https://gyazo.com/3217a867b1f7adc535391470fb7b0652.png" alt="" /></p>

<ul>
  <li>oldest-to-newest(<strong>O2N</strong>): 古いデータから新しいデータに伸びていくリスト．<br />
      * indexを更新する必要がないが, pointer chasingが長引く可能性が高い. GCが細かく実行されれば問題ない.</li>
  <li>newest-to-oldest(<strong>N2O</strong>): 新しいデータから古いデータに伸びていくリスト．どんな時でもindex(head)を更新することになる.<br />
      * セカンダリインデックスを実装している場合，こちらも含めてアトミックに更新しなければならない.<br />
              * 間接参照を用いることで解決できる.</li>
</ul>

<p>さらに他にも方向性がある.「Blobが与えられた場合の挙動」が性能に影響する．</p>

<ul>
  <li>Blobをコピーする: リストの各ノードで，構造体をまるごとコピーする.
    <ul>
      <li>もちろん非効率だが，参照には優しい．</li>
    </ul>
  </li>
  <li>更新の差分だけを記録する(delta-update). MySQLの取っている戦略．
    <ul>
      <li>リストを辿ることによって構造体を完成させる．このため更新に強いが参照に弱いと考えられる．</li>
    </ul>
  </li>
</ul>

<h3 id="42-time-travel-storage">4.2 Time travel storage</h3>

<p>こちらはSAP HANAが取っている戦略である．が，割愛する．</p>

<h3 id="43-delta-storage">4.3 Delta Storage</h3>

<p>MySQLとOracleが採用しているもの.<br />
master versionとdelta storageを分離して管理する.</p>

<h3 id="44-discussion">4.4 Discussion</h3>

<p>かなり細かい実装上のポイントがある．</p>

<ul>
  <li>append-only storageはanalytical queryに強い.全てのバージョンが連続してメモリに乗っているため，CPUのキャッシュに優しい．プリフェッチがきく.</li>
  <li><code class="highlighter-rouge">malloc</code> を工夫するのがポイント． メモリ上で連続したレイアウトに同じタプルが乗るようにするとよい.</li>
  <li>indexの管理やdelta storageとのやりとりのロックを使うと，そこがボトルネックになる．ロックフリー化するとよい．</li>
</ul>

<h2 id="5gabage-collection">5.Gabage Collection</h2>

<p>リストから不要な領域を削除したり，コンパクションを行うことをMVCCにおけるGCと呼ぶ．</p>

<p>GCにかかる時間が長いと単純にペナルティが大きい． が, 長大なリストを辿るのもオーバヘッドがやはり大きい．<br />
このトレードオフをうまく吸収できる設計が，GCに求められている役割である．</p>

<p>GCの主な機能は,</p>

<ol>
  <li>detect expired version
    <ul>
      <li>現在走っている全てのトランザクションIDより若いバージョンは削除(誰にも読まれない)</li>
      <li>これを実装しようとすると，全てのトランザクションで共有するデータ構造を必要とする．これはcentralized data structureになる.</li>
      <li><a href="http://dl.acm.org/citation.cfm?id=2522713">Silo</a>[8]のようにepoch-based Commit/GCすると緩和できる．</li>
    </ul>
  </li>
  <li>unlink those versions</li>
  <li>reclaim their storage</li>
</ol>

<p>GCの設計は大きく2種類ある．</p>

<p><img src="https://gyazo.com/5b30be83637687b37dae186d0f484b04.png" alt="" /></p>

<h3 id="51-tuple-level-gc">5.1 Tuple-level GC</h3>

<p>一般的なMVCCのGCといえばこのスタイルだろう．<br />
あるバージョンのレコードを意味するタプルが線形リストとして表現されるもの．</p>

<p>この場合のGC戦略はさらに細分化して二種類ある:</p>

<ul>
  <li>VACUUM: PostgreSQLのものが有名．GC用のスレッドを作る． 一般的なやり方ではあるが，DBの規模とワーカスレッド数が巨大になると追いつかなくなってくる．</li>
  <li>COOP: 各トランザクションのワーカスレッドが，自分が触ったリストを最適化して帰っていく．
    <ul>
      <li>これはO2N(oldest to newest)の時しかうまく動かない. 加えて殆ど触られないリストがある場合不要なレコードが残り続ける. これをHekatonでは<strong>“dusty corners”</strong>と呼んでいる.</li>
    </ul>
  </li>
</ul>

<h3 id="52-transaction-level-gc">5.2 Transaction-level GC</h3>

<p>これは一般的なアプローチではない．トランザクションのRead/Write Setをそのままタプルの表現として用いるアプローチ．<br />
つまりトランザクション構造体の線形リストとなる．</p>

<p>単純に考えると，タプルを <code class="highlighter-rouge">malloc</code> して <code class="highlighter-rouge">memcpy</code> するTuple-Level GCに対して，トランザクションのワーキングセットをそのまま <code class="highlighter-rouge">move</code> すれば良いため，<br />
実装上の効率は良いと考えられる．</p>

<h3 id="53-discussion">5.3 Discussion</h3>

<p>Tuple-Level GC + VACUUMが最も一般的な選択である．この理由としては実装の容易さもあるだろう．</p>

<h2 id="6-index-management">6. Index Management</h2>

<p>セカンダリインデックスなどを考慮すると, Atomicityのためにはインデックスを更新するためのラッチの使い方が変わってくる.<br />
ここにも大別して二つの戦略がある. それ以外はHybridと呼べる．</p>

<p><img src="https://gyazo.com/78023be0531610ab707b8717ed5857b8.png" alt="" /></p>

<ol>
  <li>Logical Pointer: 間接参照を用いて, アトミックにインデックスを更新する．
    <ul>
      <li>更新には強いが参照時に一回，無駄にメモリアクセスする可能性がある.</li>
    </ul>
  </li>
  <li>Physical Pointer: インデックスに直接タプルを埋め込む.
    <ul>
      <li>参照は速いが，セカンダリインデックスをどう更新するかという問題がある(ナイーブには，ロックを使うしかない)</li>
    </ul>
  </li>
</ol>

<h2 id="7-experimental-analysis">7. Experimental Analysis</h2>

<p>本論文では上記の設計上の選択をすべてPelotonに実装してベンチマークを行っている．<br />
このブログでは論文のベンチマーク結果を個々には取り上げず，概要のみ紹介するが，<br />
それぞれの図は興味深い結果を見せているので，一読する価値はある．</p>

<h4 id="concurrency-control-protocol">Concurrency Control Protocol</h4>

<p>同時実行制御手法については，先行研究で得られた知見とおおよそ同様の結果が得られた．<br />
読取りロックを用いるS2PLや読取りタイムスタンプを用いるMVTOは <code class="highlighter-rouge">read</code> の多い参照系ワークロードでは性能が低下する．</p>

<p>しかし，読取りロックを用いないOCCは，局所性が高く競合する割合が増えるワークロードでは偽陽性のあるアボートをしてしまい，むしろ性能が落ち込む．</p>

<p>といった様に，先行研究で得られた知見と同等の結果が出ている．</p>

<h4 id="version-storage">Version Storage</h4>

<p>それぞれの選択についての比較を行っている．</p>

<ul>
  <li>Non-Inline Attributes: blobをコピーせず前のバージョンから持ってくる. full-copyしない戦略. 性能が2倍程度向上した．</li>
  <li>N2O/O2N: N2Oのほうが参照・更新の性能共に良い. IndexのHEADを差し替えるために間接参照を用いるなどのオーバヘッドを差し引いても良い．</li>
  <li>Append Only/Delta Update: 変更するテーブルの列数が多い場合，差分更新を行うDelta Updateは性能が上がる．が，10列程度では変化がない．
    <ul>
      <li>Attributes modified: Delta Updateを採用した場合，クエリが変更する列数が増えるとむしろ性能が劣化する場合がある．</li>
    </ul>
  </li>
</ul>

<h4 id="gabage-collection">Gabage Collection</h4>

<ul>
  <li>VACUUM/Cooperative: それほどスレッド数の増減などを行った際の性能特性に差はない．
    <ul>
      <li>が，総じてCOOPのほうが45%ほど性能が良い.</li>
    </ul>
  </li>
  <li>Tuple-level/Transaction-level GC: Transaction-levelのほうがupdate-heavyなワークロードでは20%ほど性能が良い．<br />
      * 実装上のオーバヘッドを潰せたという以上の意味はないだろう．</li>
</ul>

<h4 id="index-management">Index Management</h4>

<p>どのようなワークロードでもPhysical Pointerに対してLogical Pointerが25~40%ほど性能が良い．</p>

<h2 id="8-discussion">8. Discussion</h2>

<p>現状のベンチマークを踏まえて，<br />
インメモリデータベース上でMVCCを実装する際の最も有効な選択は<strong>MVTO+N2O+Delta Update+Logical Pointer+Cooperative GC</strong>での実装になるだろう，と述べている．</p>

<h1 id="所感">所感</h1>

<p>Andy Pavloのチームは彼らが実装したPelotonをベースにここ数年，多くの論文を発表している．<br />
<a href="http://db.cs.cmu.edu/papers/2017/p42-pavlo-cidr17.pdf">RNNを用いたDBMSの自動管理</a>などもその一つである．</p>

<p>研究者の手元に，コントロール可能なDBMSの実装があるというのは非常に重要で，DBMS研究が各コンポーネント（ログ・同時実行制御・オプティマイザ・etc..）のマイクロベンチマークに閉じず，<br />
DBMS全体の性能に対する影響を計測することを可能にしてくれる．</p>

<p>このような論文はアカデミアとインダストリアルの架け橋になるものだと思う．</p>

<h1 id="参考文献">参考文献</h1>

<p>[1] PostgreSQL: Time Travel, https://www.postgresql.org/docs/6.3/static/c0503.htm</p>

<p>[2] Peloton, https://github.com/cmu-db/peloton</p>

<p>[3] Per-Åke Larson, Spyros Blanas, Cristian Diaconu, Craig Freedman, Jignesh M. Patel, and Mike Zwilling. 2011. High-performance concurrency control mechanisms for main-memory databases. Proc. VLDB Endow. 5, 4 (December 2011), 298-309. DOI=http://dx.doi.org/10.14778/2095686.2095689</p>

<p>[4] Philip A. Bernstein and Nathan Goodman. 1980. Timestamp-based algorithms for concurrency control in distributed database systems. In Proceedings of the sixth international conference on Very Large Data Bases - Volume 6 (VLDB ‘80), Vol. 6. VLDB Endowment 285-300.</p>

<p>[5] Xiangyao Yu, George Bezerra, Andrew Pavlo, Srinivas Devadas, and Michael Stonebraker. 2014. Staring into the abyss: an evaluation of concurrency control with one thousand cores. Proc. VLDB Endow. 8, 3 (November 2014), 209-220. DOI=http://dx.doi.org/10.14778/2735508.2735511</p>

<p>[6] Alan Fekete, Dimitrios Liarokapis, Elizabeth O’Neil, Patrick O’Neil, and Dennis Shasha. 2005. Making snapshot isolation serializable. ACM Trans. Database Syst. 30, 2 (June 2005), 492-528. DOI=http://dx.doi.org/10.1145/1071610.1071615</p>

<p>[7] Tianzheng Wang, Ryan Johnson, Alan Fekete, and Ippokratis Pandis. 2015. The Serial Safety Net: Efficient Concurrency Control on Modern Hardware. In Proceedings of the 11th International Workshop on Data Management on New Hardware (DaMoN’15), Ippokratis Pandis and Martin Kersten (Eds.). ACM, New York, NY, USA, , Article 8 , 8 pages. DOI=http://dx.doi.org/10.1145/2771937.2771949</p>

<p>[8] Stephen Tu, Wenting Zheng, Eddie Kohler, Barbara Liskov, and Samuel Madden. 2013. Speedy transactions in multicore in-memory databases. In Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles (SOSP ‘13). ACM, New York, NY, USA, 18-32. DOI: https://doi.org/10.1145/2517349.2522713</p>

<h1 id="参考資料">参考資料</h1>

<ul>
  <li><a href="http://d.hatena.ne.jp/okachimachiorz/20160104/1451904249">CSRとMVSR</a></li>
  <li><a href="https://www.slideshare.net/nikezono/ss-73837761">トランザクションの回復可能性</a></li>
</ul>
