<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>LUA基础入门教程 &#8211; LUA教程</title>
<meta name="description" content="LUA教程:Lua是一门精巧的语言，与其它语言配合使用，发挥更高的效能。特别是与C和C++语言的配合。著名的项目Openresty就是使用了Lua。">
<meta name="keywords" content="lua, lua语言零基础教程, lua入门, 机械键盘, 静电容键盘, 码农, lua教程, lua入门教程, lua基础, lua基础教程, lua基础入门教程, 友情岁月, lua.ren">


<!-- Baidu ZZ www.lua.ren-->
<meta name="baidu-site-verification" content="code-mUfTLvBErv" />
<!-- Baidu ZZ lua.ren-->
<meta name="baidu-site-verification" content="code-1frv44bXq0" />
<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="LUA基础入门教程">
<meta property="og:description" content="LUA教程:Lua是一门精巧的语言，与其它语言配合使用，发挥更高的效能。特别是与C和C++语言的配合。著名的项目Openresty就是使用了Lua。">
<meta property="og:url" content="http://0.0.0.0:8081/page31/">
<meta property="og:site_name" content="LUA教程">
<meta property="og:image" content="http://0.0.0.0:8081/images/images/logo.png">





<link rel="canonical" href="http://0.0.0.0:8081/page31/">
<link href="http://0.0.0.0:8081/feed.xml" type="application/atom+xml" rel="alternate" title="LUA教程 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"/>

<!-- For all browsers -->
<link rel="stylesheet" href="http://0.0.0.0:8081/assets/css/main.css">
<link rel="stylesheet" href="http://0.0.0.0:8081/assets/css/jquery.mmenu.all.css">
<link rel="stylesheet" href="http://0.0.0.0:8081/assets/css/jquery.floating-social-share.min.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script type="text/javascript" src="http://0.0.0.0:8081/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://0.0.0.0:8081/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://0.0.0.0:8081/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://0.0.0.0:8081/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://0.0.0.0:8081/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://0.0.0.0:8081/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://0.0.0.0:8081/images/apple-touch-icon-144x144-precomposed.png">





<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?14cc93bf3f08d31c458639d309dde522";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>
   r

</head>

<body id="post-index">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->




<div class="header-menu header-menu-top">
    <ul class="header-item-container">
      <li class="header-item-title header-toggle "><a href="#menu"><h2><i class="fa fa-bars"></i></h2></a></li>
      <li class="header-item-title">
        <a href="http://0.0.0.0:8081/">
          
            <img class="logo" src="http://0.0.0.0:8081/images/logo.png" alt="LUA教程">
          
          <a href="http://0.0.0.0:8081/" class="title"> LUA教程</a>
        </a>
      </li>
      
        
        

        
          <li class="header-item "><a href="http://0.0.0.0:8081/categories"><h3>分类</h3></a>
            <ul class="header-submenu">
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#      .md">      .md</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#AI">AI</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#Documents">Documents</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#HiLua框架">HiLua框架</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#LUA教程">LUA教程</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#Lapis框架">Lapis框架</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#MoonScript语法">MoonScript语法</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#MoonScript项目">MoonScript项目</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#OPENRESTY">OPENRESTY</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#lua_guide">lua_guide</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#lua教程">lua教程</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#mysql">mysql</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#openresty最佳实践">openresty最佳实践</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#python">python</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#tools">tools</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#topic">topic</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#动态库">动态库</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#安全">安全</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#机械键盘">机械键盘</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#网关">网关</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#键盘">键盘</a></li>
              
                
                  <li class="sub-item"><a href="http://0.0.0.0:8081/categories/#静电容键盘">静电容键盘</a></li>
              
            </ul>
          </li>
        
      
        
        

        
            
                <li class="header-item "><a href="http://0.0.0.0:8081/tags"><h3>标签</h3></a></li>
            
        
      
        
        

        
          <li class="header-item "><a href="http://0.0.0.0:8081/"><h3>Lua高级</h3></a>
            <ul class="header-submenu">
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/error-handling/">Lua错语处理</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/coroutines/">Lua协程</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/metatables/">Lua元表</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/garbage-collection/">Lua垃圾回收机制</a></li>
              
            </ul>
          </li>
        
      
        
        

        
          <li class="header-item "><a href="http://0.0.0.0:8081/"><h3>Lua循环</h3></a>
            <ul class="header-submenu">
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/lua教程/for/">for循环</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/lua教程/while/">while循环</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/loop/">loop循环</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/repeat-until/">repeat until循环</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/iterators/">iterators迭代器</a></li>
              
            </ul>
          </li>
        
      
        
        

        
          <li class="header-item "><a href="http://0.0.0.0:8081/"><h3>Lua判断</h3></a>
            <ul class="header-submenu">
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/decision-making/">Lua判断</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/if-statement/">If语句</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/if-else-if-statement/">If else语句</a></li>
              
            </ul>
          </li>
        
      
        
        

        
          <li class="header-item "><a href="http://0.0.0.0:8081/"><h3>Lua基础语法</h3></a>
            <ul class="header-submenu">
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/lua教程/variables/">变量</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/strings/">字符串</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/tables/">表</a></li>
              
                <li class="sub-item"><a href="http://0.0.0.0:8081/lua_guide/operators/">操作符</a></li>
              
            </ul>
          </li>
        
      
      <li class="header-item"><a href="http://0.0.0.0:8081/search"><h3><i class="fa fa-search"></i></h3></a></li>
    </ul>
  </div>

<div class="entry-header">
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>LUA基础入门教程</h1>
      
        <h2><span class="entry-date"><time>&nbsp;</time></span></h2>
      

      
          <p class="entry-reading-time">
            &nbsp;
          </p>
      
    </div>
  </div>
</div>

<nav id="menu" style="display: none">
  <ul>
    
      
        <li><a href="http://0.0.0.0:8081/"><h3>Lua基础语法</h3></a>
          <ul>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/lua教程/variables/">变量</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/strings/">字符串</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/tables/">表</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/operators/">操作符</a></li>
            
          </ul>
        </li>
      
    
      
        <li><a href="http://0.0.0.0:8081/"><h3>Lua判断</h3></a>
          <ul>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/decision-making/">Lua判断</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/if-statement/">If语句</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/if-else-if-statement/">If else语句</a></li>
            
          </ul>
        </li>
      
    
      
        <li><a href="http://0.0.0.0:8081/"><h3>Lua循环</h3></a>
          <ul>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/lua教程/for/">for循环</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/lua教程/while/">while循环</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/loop/">loop循环</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/repeat-until/">repeat until循环</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/iterators/">iterators迭代器</a></li>
            
          </ul>
        </li>
      
    
      
        <li><a href="http://0.0.0.0:8081/"><h3>Lua高级</h3></a>
          <ul>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/error-handling/">Lua错语处理</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/coroutines/">Lua协程</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/metatables/">Lua元表</a></li>
            
              <li><a href="http://0.0.0.0:8081/lua_guide/garbage-collection/">Lua垃圾回收机制</a></li>
            
          </ul>
        </li>
      
    
      
        <li><a href="http://0.0.0.0:8081/tags"><h3>标签</h3></a></li>
      
    
      
        <li><a href="http://0.0.0.0:8081/categories"><h3>分类</h3></a>
          <ul>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#      .md">      .md</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#AI">AI</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#Documents">Documents</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#HiLua框架">HiLua框架</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#LUA教程">LUA教程</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#Lapis框架">Lapis框架</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#MoonScript语法">MoonScript语法</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#MoonScript项目">MoonScript项目</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#OPENRESTY">OPENRESTY</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#lua_guide">lua_guide</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#lua教程">lua教程</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#mysql">mysql</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#openresty最佳实践">openresty最佳实践</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#python">python</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#tools">tools</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#topic">topic</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#动态库">动态库</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#安全">安全</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#机械键盘">机械键盘</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#网关">网关</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#键盘">键盘</a></li>
            
              
                <li><a href="http://0.0.0.0:8081/categories/#静电容键盘">静电容键盘</a></li>
            
          </ul>
        </li>
      
    
  </ul>
</nav>









<script type="text/javascript">
  window.onload = function(){
    new SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: 'http://0.0.0.0:8081/search.json',
      searchResultTemplate: '<li class="entry-title"><a href="{url}" title="{title}">{title}</a></li>'
    });
  };
</script>





<div id="main" role="main">
  <!--
    <h3>lua</h3>
  -->
    <section id="disqus_thread" class="read-more">            
    <div class="read-more-header">
      <a href="http://0.0.0.0:8081/tags/" class="read-more-btn">搜索</a>
    </div><!-- /.read-more-header -->

      
      

      <ul class="entry-meta inline-list">
        
          
          <li><a href="#CJSON" class="tag"><span class="term">CJSON</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#ES" class="tag"><span class="term">ES</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#Graylog" class="tag"><span class="term">Graylog</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#Graylog SDK" class="tag"><span class="term">Graylog SDK</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#HiLua" class="tag"><span class="term">HiLua</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#JSON" class="tag"><span class="term">JSON</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#LUA" class="tag"><span class="term">LUA</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#LUA-CJSON" class="tag"><span class="term">LUA-CJSON</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#LUA教程" class="tag"><span class="term">LUA教程</span> <span class="count">4</span></a></li>
        
          
          <li><a href="#Lapis" class="tag"><span class="term">Lapis</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#Lapis框架" class="tag"><span class="term">Lapis框架</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#LazyTable" class="tag"><span class="term">LazyTable</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#Map排序" class="tag"><span class="term">Map排序</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#MoonScript官方文档" class="tag"><span class="term">MoonScript官方文档</span> <span class="count">4</span></a></li>
        
          
          <li><a href="#MoonScript简介" class="tag"><span class="term">MoonScript简介</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#OpenResty Timer" class="tag"><span class="term">OpenResty Timer</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#RESTY-HTTP" class="tag"><span class="term">RESTY-HTTP</span> <span class="count">3</span></a></li>
        
          
          <li><a href="#RESTY-REDIS" class="tag"><span class="term">RESTY-REDIS</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#abc" class="tag"><span class="term">abc</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#apisix" class="tag"><span class="term">apisix</span> <span class="count">4</span></a></li>
        
          
          <li><a href="#basic" class="tag"><span class="term">basic</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#c" class="tag"><span class="term">c</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#dashboard" class="tag"><span class="term">dashboard</span> <span class="count">3</span></a></li>
        
          
          <li><a href="#datetime" class="tag"><span class="term">datetime</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#django" class="tag"><span class="term">django</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#fuser" class="tag"><span class="term">fuser</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#gateway" class="tag"><span class="term">gateway</span> <span class="count">4</span></a></li>
        
          
          <li><a href="#lapis" class="tag"><span class="term">lapis</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#lua" class="tag"><span class="term">lua</span> <span class="count">124</span></a></li>
        
          
          <li><a href="#lua json" class="tag"><span class="term">lua json</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#lua二分查找" class="tag"><span class="term">lua二分查找</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#lua循环" class="tag"><span class="term">lua循环</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#lua循环遍历" class="tag"><span class="term">lua循环遍历</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#lua文章" class="tag"><span class="term">lua文章</span> <span class="count">1126</span></a></li>
        
          
          <li><a href="#moonscript" class="tag"><span class="term">moonscript</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#mysql" class="tag"><span class="term">mysql</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#nc" class="tag"><span class="term">nc</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#nginx" class="tag"><span class="term">nginx</span> <span class="count">3</span></a></li>
        
          
          <li><a href="#niz" class="tag"><span class="term">niz</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#openresty" class="tag"><span class="term">openresty</span> <span class="count">28</span></a></li>
        
          
          <li><a href="#tengine" class="tag"><span class="term">tengine</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#二分查找" class="tag"><span class="term">二分查找</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#库" class="tag"><span class="term">库</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#折半查找" class="tag"><span class="term">折半查找</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#机械键盘" class="tag"><span class="term">机械键盘</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#深度学习" class="tag"><span class="term">深度学习</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#码农" class="tag"><span class="term">码农</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#码农键盘，键盘入坑" class="tag"><span class="term">码农键盘，键盘入坑</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#神经网络" class="tag"><span class="term">神经网络</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#程序员机械键盘" class="tag"><span class="term">程序员机械键盘</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#程序员薄膜键盘" class="tag"><span class="term">程序员薄膜键盘</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#程序员键盘" class="tag"><span class="term">程序员键盘</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#程序员静电容键盘" class="tag"><span class="term">程序员静电容键盘</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#选择排序" class="tag"><span class="term">选择排序</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#静电容键盘" class="tag"><span class="term">静电容键盘</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#静电容键盘，plum" class="tag"><span class="term">静电容键盘，plum</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#风控笔记" class="tag"><span class="term">风控笔记</span> <span class="count">29</span></a></li>
        
      </ul>
   
      
    <!--
      <ul class="entry-meta inline-list">
        
          
          <li><a href="#      .md" class="tag"><span class="term">      .md</span> <span class="count"></span></a></li>
        
          
          <li><a href="#AI" class="tag"><span class="term">AI</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#Documents" class="tag"><span class="term">Documents</span> <span class="count">4</span></a></li>
        
          
          <li><a href="#HiLua框架" class="tag"><span class="term">HiLua框架</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#LUA教程" class="tag"><span class="term">LUA教程</span> <span class="count">2</span></a></li>
        
          
          <li><a href="#Lapis框架" class="tag"><span class="term">Lapis框架</span> <span class="count">5</span></a></li>
        
          
          <li><a href="#MoonScript语法" class="tag"><span class="term">MoonScript语法</span> <span class="count">4</span></a></li>
        
          
          <li><a href="#MoonScript项目" class="tag"><span class="term">MoonScript项目</span> <span class="count">2</span></a></li>
        
          
          <li><a href="#OPENRESTY" class="tag"><span class="term">OPENRESTY</span> <span class="count">6</span></a></li>
        
          
          <li><a href="#lua_guide" class="tag"><span class="term">lua_guide</span> <span class="count">34</span></a></li>
        
          
          <li><a href="#lua教程" class="tag"><span class="term">lua教程</span> <span class="count">2</span></a></li>
        
          
          <li><a href="#mysql" class="tag"><span class="term">mysql</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#openresty最佳实践" class="tag"><span class="term">openresty最佳实践</span> <span class="count">17</span></a></li>
        
          
          <li><a href="#python" class="tag"><span class="term">python</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#tools" class="tag"><span class="term">tools</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#topic" class="tag"><span class="term">topic</span> <span class="count">1438</span></a></li>
        
          
          <li><a href="#动态库" class="tag"><span class="term">动态库</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#安全" class="tag"><span class="term">安全</span> <span class="count">29</span></a></li>
        
          
          <li><a href="#机械键盘" class="tag"><span class="term">机械键盘</span> <span class="count">1</span></a></li>
        
          
          <li><a href="#网关" class="tag"><span class="term">网关</span> <span class="count">3</span></a></li>
        
          
          <li><a href="#键盘" class="tag"><span class="term">键盘</span> <span class="count">2</span></a></li>
        
          
          <li><a href="#静电容键盘" class="tag"><span class="term">静电容键盘</span> <span class="count">1</span></a></li>
        
      </ul>
    -->



      <div style="text-align: center">
        <h3>按回车确认检索</h3>
        <input type="text" placeholder="输入关键字并按回车。" id="search-input"/>
      </div>

      <ul id="results-container">
      </ul>

    </section>

</div><!-- /#main -->


<!--

<div id="main" role="main">
    <section id="disqus_thread" class="read-more">            
    <div class="read-more-header">
      <a href="http://0.0.0.0:8081" class="read-more-btn">检索</a>
    </div>
      <div style="text-align: center">
          <h3>关键字: 标题、标签、分类等。</h3>
        <input type="text" placeholder="输入标题、标签、按回车。" id="search-input"/>
      </div>

      <ul id="results-container">
      </ul>
    </section>
</div>
-->


<div id="main" role="main">
  <section id="disqus_thread" class="read-more">            
  <div class="read-more-header">
    <a href="http://0.0.0.0:8081" class="read-more-btn">置顶</a>
  </div><!-- /.read-more-header -->
  
      <h1><li><a href="http://0.0.0.0:8081/静电容键盘/niz静电容键盘怎么样/" >程序员神器</a></li></h1>
  
      <h1><li><a href="http://0.0.0.0:8081/images/download/lua.pdf" >Lua基础入门教程（PDF）</a></li></h1>
  
</div><!-- /#main -->



<div class="read-more">
  <div class="read-more-header">
    <a href="http://0.0.0.0:8081/lua_guide/if-else-if-statement/" class="read-more-btn">基础</a>
  </div><!-- /.read-more-header -->
 
  <div class="read-more-content">
    <h4>第一部分：变量与基础</h4>
    <p>Lua的基础知识</p>
  </div><!-- /.read-more-content -->

  <div class="read-more-list">
      <div class="list-item">
        <h3><a href="/lua_guide/lua教程/variables/" title="">1.变量</a></h3>
        <span>variables</span>
        <h3><a href="/lua_guide/strings/" title="">2.字符串</a></h3>
        <span>strings</span>
      </div><!-- /.list-item -->
      <div class="list-item">
        <h3><a href="/lua_guide/tables/" title="">3.表</a></h3>
        <span>tables</span>
        <h3><a href="/lua_guide/operators/" title="">4.操作符</a></h3>
        <span>operators</span>
      </div><!-- /.list-item -->
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->

<div class="read-more">
  <div class="read-more-header">
    <a href="http://0.0.0.0:8081/lua_guide/if-else-if-statement/" class="read-more-btn">判断</a>
  </div><!-- /.read-more-header -->
 
  <div class="read-more-content">
    <h4>第二部分：判断控制</h4>
    <p>Lua的判断控制操作</p>
  </div><!-- /.read-more-content -->

  <div class="read-more-list">
      <div class="list-item">
        <h3><a href="/lua_guide/decision-making/" title="">1.Lua判断</a></h3>
        <span>decision making</span>
        <h3><a href="/lua_guide/if-statement/" title="">2.if语句</a></h3>
        <span>if</span>
      </div><!-- /.list-item -->
      <div class="list-item">
        <h3><a href="/lua_guide/if-else-if-statement/" title="">3.if...else 语句</a></h3>
        <span>if else</span>
      </div><!-- /.list-item -->
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->

<div class="read-more">
  <div class="read-more-header">
    <a href="/lua_guide/if-else-if-statement/" class="read-more-btn">循环</a>
  </div><!-- /.read-more-header -->
 
  <div class="read-more-content">
    <h4>第三部分：循环控制</h4>
    <p><h5>while 循环	先检测条件，条件为真时再执行循环体，直到条件为假时结束。</h5></p>
    <p><h5>for 循环	执行一个语句序列多次，可以简化管理循环变量的代码。</h5></p>
    <p><h5>repeat...until 循环	重复执行一组代码语句，直到 until 条件为真为止。</h5></p>
  </div><!-- /.read-more-content -->

  <div class="read-more-list">
      <div class="list-item">
        <h3><a href="/lua_guide/lua教程/for/" title="">1.for循环</a></h3>
        <span>for循环几使用</span>
        <h3><a href="/lua_guide/lua教程/while/" title="">2.while循环</a></h3>
        <span>while循环使用</span>
      </div><!-- /.list-item -->
      <div class="list-item">
        <h3><a href="/lua_guide/loop/" title="">3.loop循环</a></h3>
        <span>loop循环使用</span>
        <h3><a href="/lua_guide/repeat-until/" title="">4.repeat...until</a></h3>
        <span>repeat...until循环使用</span>
        <h3><a href="/lua_guide/iterators/" title="">5.iterators</a></h3>
        <span>Lua迭代器</span>
      </div><!-- /.list-item -->
      </div><!-- /.list-item -->
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->


<div class="read-more">
  <div class="read-more-header">
    <a href="/lua_guide/if-else-if-statement/" class="read-more-btn">高级</a>
  </div><!-- /.read-more-header -->
 
  <div class="read-more-content">
    <h4>第四部分：高级功能</h4>
    <p>介绍几种的Lua高级功能</p>
  </div><!-- /.read-more-content -->

  <div class="read-more-list">
      <div class="list-item">
        <h3><a href="/lua_guide/error-handling/" title="">1.Lua错误处理</a></h3>
        <span>error-handling</span>
        <h3><a href="/lua_guide/coroutines/" title="">2.Lua 协程</a></h3>
        <span>coroutines</span>
      </div><!-- /.list-item -->
      <div class="list-item">
        <h3><a href="/lua_guide/metatables/" title="">3.Lua元表</a></h3>
        <span>metatables</span>
        <h3><a href="/lua_guide/garbage-collection/" title="">4.Lua垃圾回收机制</a></h3>
        <span>garbage-collection</span>
      </div><!-- /.list-item -->
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->



<div id="main" role="main">
  <section id="disqus_thread" class="read-more">            
  <div class="read-more-header">
    <a href="http://0.0.0.0:8081" class="read-more-btn">基础</a>
  </div><!-- /.read-more-header -->

        
            
                <li class="entry-title"><a href="/lua_guide/lua%E6%95%99%E7%A8%8B/for/" title="Lua中的for循环">Lua中的for循环</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/lua%E6%95%99%E7%A8%8B/while/" title="Lua的while循环">Lua的while循环</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/lua%E6%95%99%E7%A8%8B/variables/" title="Lua的变量">Lua的变量</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/tables/" title="Lua表">Lua表</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/strings/" title="Lua字符串">Lua字符串</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/standard-libraries/" title="Lua标准库">Lua标准库</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/repeat-until/" title="repeat...until 循环">repeat...until 循环</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/overview/" title="概述">概述</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/operators/" title="操作符">操作符</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/operating-system-facilities/" title="Lua操作系统工具库">Lua操作系统工具库</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/object-oriented/" title="Lua面向对象">Lua面向对象</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/nested-loop/" title="Lua循环嵌套">Lua循环嵌套</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/nested-if-statement/" title="Lua中的嵌套 if 语句">Lua中的嵌套 if 语句</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/modules/" title="Lua模块">Lua模块</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/metatables/" title="Metatables">Metatables</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/math-library/" title="Lua数学函数库">Lua数学函数库</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/loop/" title="LUA的Loop循环">LUA的Loop循环</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/iterators/" title="Lua迭代器">Lua迭代器</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/if-statement/" title="Lua中的if语句">Lua中的if语句</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/if-else-if-statement/" title="Lua中的 if...else 语句">Lua中的 if...else 语句</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/garbage-collection/" title="Lua垃圾回收机制">Lua垃圾回收机制</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/game-programming/" title="Lua游戏开发">Lua游戏开发</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/functions/" title="Lua函数">Lua函数</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/file-io/" title="Lua文件I/O">Lua文件I/O</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/error-handling/" title="Lua错误处理">Lua错误处理</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/environment/" title="Lua运行环境">Lua运行环境</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/decision-making/" title="Lua判断">Lua判断</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/debugging/" title="Lua调试">Lua调试</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/database-access/" title="Lua数据库访问">Lua数据库访问</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/data-types/" title="数据类型">数据类型</a></li>
            
         
            
                <li class="entry-title"><a href="/lua_guide/coroutines/" title="Lua协程">Lua协程</a></li>
            
         

</div><!-- /#main -->


<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://0.0.0.0:8081/topic/tweyseo-WalkOnLuaJIT-1/" title="Walk on LuaJIT"><img src="http://0.0.0.0:8081/images/feature.jpg" alt="Walk on LuaJIT"></a>
        

      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2019-05-21T12:50:18+08:00"><a href="http://0.0.0.0:8081/topic/tweyseo-WalkOnLuaJIT-1/">May 21, 2019</a></time></span><span class="author vcard"><span class="fn"><a href="http://0.0.0.0:8081/about/" title="About 糖果">糖果</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
        Reading time ~42 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://0.0.0.0:8081/topic/tweyseo-WalkOnLuaJIT-1/" rel="bookmark" title="Walk on LuaJIT" itemprop="url">Walk on LuaJIT</a></h1>
    
  </header>
  <div class="entry-content">
<!--
      <h1 id="0-背景"><strong>0. 背景</strong></h1>

<h2 id="a-目的"><strong>a. 目的</strong></h2>

<p>这里主要研究LuaJIT的Trace的相关原理，并且展示如何使用LuaJIT提供的<a href="https://github.com/LuaJIT/LuaJIT/blob/master/src/jit/v.lua">v.lua</a>和<a href="https://github.com/LuaJIT/LuaJIT/blob/master/src/jit/dump.lua">dump.lua</a>工具来分析LuaJIT的行为，方便后续使优化工作在LuaJIT下的lua代码。当然，遵守<a href="http://wiki.luajit.org/Numerical-Computing-Performance-Guide">Performance-Guide</a>的规则，一定不会出现性能太差的代码。</p>

<h2 id="b-准备工作"><strong>b. 准备工作</strong></h2>

<p>首先配置调试<a href="https://github.com/LuaJIT/LuaJIT/tree/v2.1.0-beta3">LuaJIT-v2.1.0-beta3</a>源码的环境（Windows 64位 + VS 2019）：</p>
<ol>
  <li>如果要得到精确的栈，需要修改\src\msvcbuild.bat，将<code class="highlighter-rouge">/O2</code>替换为<code class="highlighter-rouge">/Od</code>；</li>
  <li>在64位版本的vs命令行里执行<code class="highlighter-rouge">msvcbuild.bat debug</code>，生成luajit.exe，luajit.lib和lua51.lib；</li>
  <li>在VS里建立个命令工程（64位），设置\src为工作目录，指定\src为附加包含目录和附加库目录，并且在附加依赖项里加入luajit.lib和lua51.lib</li>
  <li>新建main.cpp，内容如下：
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
 lua_State *L = luaL_newstate(); /*创建一个解释器句柄*/
 luaL_openlibs(L);             /*打开所有的Lua库*/

 luaL_loadfile(L, "../LuaJIT-Debug/t1.lua"); /*调入Lua脚本文件，注意路径*/

 lua_pcall(L, 0, 0, 0); /*执行Lua脚本*/
 lua_close(L);       /*关闭句柄*/

 return 0;
}
</code></pre></div>    </div>
    <p>可以先简单的调试下，测试lua脚本是否成功载入。</p>
  </li>
</ol>

<h1 id="1-luajit介绍"><strong>1. LuaJIT介绍</strong></h1>

<h2 id="a-luajitvm概览"><strong>a. LuaJITVM概览</strong></h2>

<p>首先通过下面的图了解大概的LuaJITVM的模型，link表示静态的映射行为，而bind表示动态的映射行为（因为main lua_State是会切换的）。其中CTState涉及到ffi相关知识，在后续文章中会介绍。<img src="https://github.com/tweyseo/gallery/blob/master/LuaJIT/LuaJITVM-glance.png" alt="img1" /></p>

<h2 id="b-luajit的解释模式"><strong>b. LuaJIT的解释模式</strong></h2>

<p>要知道，所有的lua文件都会被LuaJIT编译成<strong>字节码</strong>（BC，bytecode），然后在LuaJIT的<strong>解释模式</strong>（interpreter）下执行。LuaJIT使用一个<strong>指令数组</strong>保存所有编译后生成的BC，在解释执行时，会从数组里逐条取出BC，使用其对应的<strong>操作码</strong>（opcode，在该BC的最低字节）作为索引在<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_dispatch.h#L99">ASMFunction</a>数组中取出对应内部汇编函数，执行具体操作（使用该BC中指定的寄存器里的内容作为操作参数），这样就把所有的BC都衔接了起来，而且这个过程中大多数操作都是使用机器指令直接编码的，所以，LuaJIT的解释模式比lua原生的解释器效率高好几倍。</p>

<h2 id="c-trace的生成"><strong>c. trace的生成</strong></h2>

<p>解释执行字节码的时同时，LuaJIT会统计一些运行时的信息，如每个循环的实际执行次数，每个函数的实际调用次数等。当这些<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_dispatch.h#L97"><strong>HotCount</strong></a>（low-overhead hashed profiling counters）超过某个阈值时（这里其实是先初始化为阈值，然后通过递减来计算的，而且对于（递归）函数和循环有所不同，具体见<a href="https://github.com/LuaJIT/LuaJIT/commit/82eca898db87bde10fbbb14a0f35ef75b6c3dcc6">commit</a>），便认为对应的代码段足够的“<strong>热</strong>”，此时就会触发<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L727">lj_trace_hot</a>开始<strong>tracing</strong>（提前是当前LuaJIT没有在做其它tracing）。</p>

<p>tracing的过程就是通过<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L727">lj_trace_ins</a>里的循环，驱动<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L635">trace_state</a>状态机，逐条<strong>记录</strong>（recording）对应代码段内即将执行的BC，其中记录的过程就是把BC转换成LuaJIT自定义<strong>中间码</strong>（<a href="https://en.wikipedia.org/wiki/Intermediate_representation">IR</a>，Intermediate Representation），引入IR的目的是为了描述便于快速且有效进行优化的代码路径。要注意的是，IR并没有包含对应代码段内的所有BC，而是记录过程中，此代码段内实际执行的代码对应的BC：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")
---
local a = 0
for i = 1, 58 do
    if i &lt;= 56 then -- i == 56 trigger hotcount, start tracing
        a = 13
    else
        a = function() end -- 只尝试转换这部分代码对应的BC到IR
    end
end
for i = 1, 58 do
    if i &lt;= 56 then -- i == 56 trigger hotcount, start tracing
        a = function() end
    else
        a = 13 -- 只尝试转换这部分代码对应的BC到IR
    end
end
</code></pre></div></div>
<p>对应vlog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:8]
[TRACE   1 t1.lua:11 loop]
</code></pre></div></div>
<p>同时也说明了，trace abort（后面将会介绍）只会发生在tracing阶段；而触发hotcount阈值的统计里，则仅仅只是循环/调用次数的统计，而不会有trace abort的。</p>

<p>成功记录完成后，再对生成的IR进行优化（使用启发式算法进行快速优化）；优化完成后，把最终的IR翻译为对应目标体系结构的<strong>机器码</strong>（MC，machine code），然后在打完补丁后最终提交MC，最后停止tracing，成功生成trace。</p>

<h1 id="2-trace介绍"><strong>2. trace介绍</strong></h1>

<h2 id="a-trace"><strong>a. trace</strong></h2>

<p>首先，trace是线性的，这意味着一个trace对应一个代码路径，也就是说不能包含条件代码或内部跳转。trace又分为<strong>roottrace</strong>（一般就叫trace）和<strong>sidetrace</strong>（会在后面介绍），上面描述的生成trace的过程，其实是roottrace的生成过程：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")
---
local function f1(v)
    if v == 0 then
        return
    end

    f1(v - 1)
end

local function f2(v)
    if v == 0 then
        return
    end

    return f2(v - 1) -- return (f2(v - 1))就变成了普通递归（up-recursion）
end

for i = 1, 58 do end
f1(112)
f2(114)
</code></pre></div></div>
<p>对应的vlog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE   1 t1.lua:19 loop]
[TRACE   2 t1.lua:3 up-recursion]
[TRACE   3 t1.lua:11 tail-recursion]
</code></pre></div></div>
<p>观察此log可以知道，TRACE 1是一个roottrace，是由包含for循环的代码段（第19行）足够“热”而生成的；TRACE 2也是一个roottrace，是由包含递归的函数f1所在的代码段（第3行）足够“热”而生成的；同样地，TRACE 3也还是一个roottrace，是由包含尾递归的函数f2所在的代码段（第11行）足够“热”而生成的。</p>

<p>前面讲的都是trace生成的过程，下面再来看看<strong>trace运行</strong>的过程。</p>

<p>trace的运行，其实就是<strong>运行对应代码段的MC</strong>。前面提到，trace是线性的，为了保持这个特性，会在tracing的记录的时候（用IR描述），在trace对应的代码段中的分支（同代码段，但是与当前trace有着不同代码路径，如if，循环的结束，等）上，建立<strong>快照</strong>（snapshot），用于储存<strong>trace运行时的所有更新的一致性视图</strong>（补偿代码的形式），并且设置相应的<strong>守卫</strong>（guard）。在运行该trace的时候，一旦条件发生改变（包含循环的结束），进入了分支，就会触发守卫失败，从而使得当前trace<strong>退出</strong>（exit），最后根据trace退出之前，最近的快照（快照里的内容实际是相关的寄存器的地址信息（tracing时确定），真正的更新内容是在对应的寄存器里的信息（trace运行时确定））更新（<a href="http://wiki.luajit.org/Allocation-Sinking-Optimization#implementation_snapshot-handling_snapshot-restore">Snapshot Restore</a>）解释模式下的LuaJITVM的状态，并且切换到解释模式。要注意，无论是在解释模式，还是运行trace的模式，LuaJITVM的状态都必须保持执行时的一致。使用下面代码来说明此过程（使用dump的时候，s表示snapshot，i表示IR，x表示trace exit）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.dump").on("six", "t1.dlog")
---
local a
for i = 1, 100 do
    if i == 80 then
        a = 13
    else
        a = 67
    end
end
</code></pre></div></div>
<p>对应的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:4
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #2    CI
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- 0001 ---- ---- 0001 ]
<span class="p">0002 &gt;  int NE     0001  +80 
0003  + int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #2   [ ---- +67  ]
<span class="p">0004 &gt;  int LE     0003  +100
</span><span class="err">....</span>        SNAP   #3   [ ---- +67  0003 ---- ---- 0003 ]
<span class="p">0005 ------ LOOP ------------
</span><span class="err">....</span>        SNAP   #4   [ ---- +67  0003 ---- ---- 0003 ]
<span class="p">0006 &gt;  int NE     0003  +80 
0007  + int ADD    0003  +1  
</span><span class="err">....</span>        SNAP   #5   [ ---- +67  ]
<span class="p">0008 &gt;  int LE     0007  +100
0009    int PHI    0003  0007
</span><span class="gd">---- TRACE 1 stop -&gt; loop
</span>
---- TRACE 1 exit 4
<span class="gd">---- TRACE 1 exit 5
</span></code></pre></div></div>
<p>观察日志可以知道，trace 1在<code class="highlighter-rouge">i == 80</code>的时候，分支条件发生改变（生成的trace 1的代码路径里没有包含<code class="highlighter-rouge">i == 80</code>里的代码路径），守卫<code class="highlighter-rouge">0006 &gt;  int NE     0003  +80</code>失败，此时trace1退出，然后根据快照4里的内容，更新解释模式下的LuaJITVM的状态，然后切换到解释模式，对应<code class="highlighter-rouge">TRACE 1 exit 4</code>；类似地，trace 1在<code class="highlighter-rouge">i &gt; 100</code>的时候，分支条件发生改变（生成的trace 1的代码路径里没有包含<code class="highlighter-rouge">i &gt; 100</code>后的代码路径），守卫<code class="highlighter-rouge">0008 &gt;  int LE     0007  +100</code>失败，此时trace1退出，然后根据快照5里的内容，更新解释模式下的LuaJITVM的状态，然后切换到解释模式，对应<code class="highlighter-rouge">TRACE 1 exit 5</code>。</p>

<p><strong><em>这里为什么if和循环结束都对应了2个guard（1和4，2和5）</em></strong></p>

<p>通过调试上述代码，发现<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L830">lj_trace_exit</a>确实是被调用了2次，而且在此函数中，会调用<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L786">lj_snap_restore</a>获取对应快照中的内容，然后通过<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L861">lj_vmevent_send</a>更新相应内容到解释模式下的LuaJITVM的状态，最后带着运行trace产生的返回值（如果有的话）一起切换到解释模式。</p>

<p>实际上，LuaJIT为了效率考虑，并且由于快照的事务性的特点（每个快照就相当于一个提交，在守卫失败，trace退出的时候，只需要获取在这之前的，最后一次提交，进行回滚），所以对那些失败概率比较低的守卫是不会生成快照的，此特性叫做<strong>稀疏快照</strong>（<a href="http://lua-users.org/lists/lua-l/2009-11/msg00089.html">sparse snapshot</a>）。</p>

<p>再来看看前面例子中的vlog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE   1 t1.lua:19 loop]
[TRACE   2 t1.lua:3 up-recursion]
[TRACE   3 t1.lua:11 tail-recursion]
</code></pre></div></div>
<p>这里，每个trace的最后（loop，up-recursion和tail-recursion）部分，表示trace的<strong>连接</strong>（link），成功生成trace后，紧接着（的BC）就是该trace的运行，那么这个生成的trace就会连接到该trace的运行(的BC)，当这些trace全部运行结束后，仅会有一次（<strong><em>但是多次非尾递归的情况下，有多次其它出口的该trace退出日志，不大理解</em></strong>）该trace退出的行为（lj_trace_exit），表现为连接到自身；反之，如果只有trace的生成，没有trace的运行（循环表现为产生leaving loop in root trace的trace abort而生成trace失败；递归则是需要trace的运行次数到达一定阈值的），自然也不会有trace的退出行为，表现为连接到return（对应LJ_TRLINK_RETURN，即return到解释模式）。连接是在<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L256">lj_record_stop</a>的时候设置的，它有好几种<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_jit.h#L214">类型</a>。</p>

<p>所以，这里的的log表示trace 1，2，3都分别各自连接到自身（循环和递归）。但是注意，如果把f1的调用次数修改为[109, 111]：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")
---
local function f1(v)
    if v == 0 then
        return
    end

    f1(v - 1)
end
f1(111) -- 109和110也是link return的vlog
</code></pre></div></div>
<p>vlog就会显示连link return：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE   1 t1.lua:3 return]
</code></pre></div></div>
<p>先来分析其生成trace的过程（<strong><em>要提前说明的是，对于普通递归，在此测试环境编译出来的LuaJIT执行jit.v（jit.v的日志和在此测试环境中调试该LuaJIT时的行为一致）和jit.dump的日志有偏差（jit.dump分别在110，111，112出现link return的日志）的情况，具体原因还没搞明白，这里暂时按照调试的过程来说明</em></strong>）：普通递归函数触发tracing的阈值是109，可是开始记录的时候，v的值已经为0了，此时就直接走BC RET0对应的处理函数<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L784">lj_record_ret</a>，设置连接到return后，停止记录和tracing，成功生成trace：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lj_record_stop(J, LJ_TRLINK_RETURN, 0);  /* Return to interpreter. */
</code></pre></div></div>
<p>而在调用值为大于109的时候，在记录的时候，v的值不为0，还会再递归调用f1，所以会在BC CALL对应的处理函数<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L726">lj_record_call</a>里，递增调用帧的深度以后，再在BC FUNCF对应的处理函数的逻辑中，调用<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L1644">check_call_unroll</a>。此函数对于非递归调用，会检测调用展开的限制；而对于递归调用，（从记录开始）超过递归调用要求的<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_jit.h#L114">最小调用次数2</a>（也就是前面提到的需要达到的trace运行次数的最小阈值），就会设置连接到递归自身（Up-recursion），然后停止记录和tracing，成功生成trace（尾递归f2也类似，但由于<strong>尾递归不会在当前函数展开调用堆栈的缘故</strong>，所以对应尾递归会设置连接到尾递归自身，即Tail-rec，具体见BC CALLT对于的处理函数<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L736">lj_record_tailcall</a>。还有一点是，尾递归触发tracing的阈值是111）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (J-&gt;framedepth + J-&gt;retdepth == 0)
    lj_record_stop(J, LJ_TRLINK_TAILREC, J-&gt;cur.traceno);  /* Tail-rec. */
else
    lj_record_stop(J, LJ_TRLINK_UPREC, J-&gt;cur.traceno);  /* Up-recursion. */
</code></pre></div></div>
<p>而上面由于110和111都没有超过tracing的记录过程中，递归调用要求的最小调用次数，所以在递归调用结束后进入了BC RET0的逻辑（lj_record_ret），从而设置连接到return后，停止记录和tracing，当然，也还是成功生成了trace。</p>

<p>对于link return和link self的trace，在trace运行上面也有很大的区别（这里使用尾递归来分析，递归会涉及dowe-recursion，这个稍后介绍）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.dump").on("six", "t1.dlog")--require("jit.v").on("t1.log")--
---
local function f1(v)
    if v == 0 then
        return
    end

    return f1(v - 1)
end

f1(114) -- link self
-- f1(113) -- link return
f1(30)
</code></pre></div></div>
<p>对应的link self的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:3
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ---- ]
<span class="p">0001 &gt;  num SLOAD  #1    T
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- ]
<span class="p">0002 &gt;  num NE     0001  +0  
</span><span class="err">....</span>        SNAP   #2   [ ---- ---- ]
<span class="p">0003    fun SLOAD  #0    R
0004 &gt;  fun EQ     0003  t1.lua:3
0005    num SUB    0001  +1  
</span><span class="err">....</span>        SNAP   #3   [ t1.lua:3|---- ]
<span class="p">0006 &gt;  num NE     0005  +0  
0007    num SUB    0005  +1  
</span><span class="err">....</span>        SNAP   #4   [ t1.lua:3|---- ]
<span class="p">0008 &gt;  num NE     0007  +0  
0009  + num SUB    0007  +1  
</span><span class="err">....</span>        SNAP   #5   [ t1.lua:3|0009 ]
<span class="p">0010 ------ LOOP ------------
</span><span class="err">....</span>        SNAP   #6   [ t1.lua:3|0009 ]
<span class="p">0011 &gt;  num NE     0009  +0  
0012    num SUB    0009  +1  
</span><span class="err">....</span>        SNAP   #7   [ t1.lua:3|0009 ]
<span class="p">0013 &gt;  num NE     0012  +0  
0014    num SUB    0012  +1  
</span><span class="err">....</span>        SNAP   #8   [ t1.lua:3|0009 ]
<span class="p">0015 &gt;  num NE     0014  +0  
0016  + num SUB    0014  +1  
0017    num PHI    0009  0016
</span><span class="gd">---- TRACE 1 stop -&gt; tail-recursion
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 1 exit 6
</span></code></pre></div></div>
<p>对应的link return的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:3
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ---- ]
<span class="p">0001 &gt;  num SLOAD  #1    T
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- ]
<span class="p">0002 &gt;  num NE     0001  +0  
</span><span class="err">....</span>        SNAP   #2   [ ---- ---- ]
<span class="p">0003    fun SLOAD  #0    R
0004 &gt;  fun EQ     0003  t1.lua:3
0005    num SUB    0001  +1  
</span><span class="err">....</span>        SNAP   #3   [ t1.lua:3|---- ]
<span class="p">0006 &gt;  num NE     0005  +0  
0007    num SUB    0005  +1  
</span><span class="err">....</span>        SNAP   #4   [ t1.lua:3|0007 ]
<span class="p">0008 &gt;  num EQ     0007  +0  
</span><span class="err">....</span>        SNAP   #5   [ t1.lua:3|]
<span class="gd">---- TRACE 1 stop -&gt; return
</span>
---- TRACE 1 exit 4
<span class="gd">---- TRACE 1 exit 4
---- TRACE 1 exit 4
---- TRACE 1 exit 4
---- TRACE 1 exit 4
---- TRACE 1 exit 4
---- TRACE 1 exit 4
---- TRACE 1 exit 4
---- TRACE 1 exit 4
---- TRACE 1 exit 4
---- TRACE 2 start 1/4 t1.lua:8
---- TRACE 2 abort t1.lua:12 -- NYI: bytecode 50
</span></code></pre></div></div>
<p>对比上面2个dumplog可以发现，link self的trace，只有两次退出，紧邻trace生成的trace运行完毕（<code class="highlighter-rouge">f(114)</code>）退出，和第二次调用f触发的trace运行完毕（<code class="highlighter-rouge">f(30)</code>）退出；而link return的trace，在<code class="highlighter-rouge">f(113)</code>的时候只有trace的生成，没有trace的运行，由于生成的是link return的trace，所以在第二次调用f中，每次trace运行完毕就会退出（这里的trace1在exit4退出达到了hot side exit的阈值，产生了sidetrace的tracing，虽然tracing由于NYI而trace abort了。而至于这个第二<code class="highlighter-rouge">f(30)</code>，是跟<code class="highlighter-rouge">f(113)</code>生成的该trace的tracing递归了3次而结束tracing，成功生成该trace的行为对应的，hot side exit的阈值是30/3，所以<code class="highlighter-rouge">f(112)</code>对应<code class="highlighter-rouge">f(20)</code>，<code class="highlighter-rouge">f(111)</code>对应<code class="highlighter-rouge">f(10)</code>。这里先简单了解下这个概念，后面会详细介绍）。</p>

<p>循环的连接则没有link return的行为，取而代之的是直接生成trace失败，这一点后面会介绍。</p>

<p><strong><em>还有个比较特殊的连接类型 ——  LJ_TRLINK_DOWNREC（Down-recursion），但是目前还不是很理解down-recursion的行为。</em></strong></p>

<h2 id="b-trace-abort"><strong>b. trace abort</strong></h2>

<p>如果tracing的过程中产生了错误，就会导致<strong>trace abort</strong>，从而停止tracing，当然也不会生成trace。一般地，这些错误都是通过<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L37">lj_trace_err</a>递出来，触发LJ_TRACE_ERR状态以后在<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L551">trace_abort</a>函数中处理。</p>

<p>当生成roottrace的tracing过程中产生了trace abort，且此tracing起始的BC的操作码不是return类操作码（RETM，RET，RET0，RET1）的情况下，就会对该tracing的起始BC进行“惩罚”。</p>

<p>“惩罚”的过程，即在jit_State的<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_jit.h#L451">惩罚数组</a>中查找是否对应BC已经被记录过（没有就记录下来），有记录就按<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L382">特定算法</a>增加其惩罚因子，增加后的惩罚因子如果超过阈值就把该BC列入黑名单，即直接修改该BC的<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L371">操作码</a>。一旦某个BC被加入黑名单，就不会再对该BC进行解释时的hotcount的统计，而只对该BC做单纯的解释执行（这也意味着比普通的解释会更快）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")--require("jit.dump").on("six", "t1.dlog")--
---
local a
local function f1()
    for _ = 1, 1e5 do
        a = function() end
    end
end
f1()
f1()    -- debug发现不会触发lj_trace_hot
local function f2()
    f1()
end
f2()    -- debug发现不会触发lj_trace_hot
</code></pre></div></div>
<p>而且如果在其它hotcount触发的tracing过程中，遇到被列入黑名单的BC，相应地，也会产生<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L2406">LJ_TRERR_BLACKL</a>的trace abort：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")--require("jit.dump").on("six", "t1.dlog")--
---
local function f1()
    for i = 1, 1e5 do
        if i &gt;= 57 then
            local a = function() end
        end
    end
end
f1()
for i = 1, 58 do
    if i == 57 then
        f1()
    end
end
</code></pre></div></div>
<p>对应的vlog为：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:4 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:11 -- blacklisted at t1.lua:4]
</code></pre></div></div>
<p>还有一点要注意的是，如果该BC的惩罚因子没超过黑名单的阈值，则会修改其对应的<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L397">hotcount的阈值</a>（也就是说，tracing起始的BC的操作码不是return类操作码，且未进入黑名单的情况下，会更改该BC的hotcount的阈值）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")--require("jit.dump").on("six", "t1.dlog")--
---
for i = 1, 168 do
    if i == 57 then
        -- 生成trace的时候产生trace abort,修改hotcount的阈值为72(循环/2),
        local a = function() end
    end
    if i == 94 then 
        -- 57 + 72/2 + 1的时候生成trace的时候再次产生trace abort,修改hotcount的阈值为144(循环/2),
        local a = function() end
    end
    -- 所以94 + 144/2 + 1 = 167的时候再次tracing成功(注意,168才成功的生成trace,具体原因下面介绍)
end
</code></pre></div></div>
<p>vlog的内容很好的说明了这一点：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE --- t1.lua:3 -- NYI: bytecode 51 at t1.lua:6]
[TRACE --- t1.lua:3 -- NYI: bytecode 51 at t1.lua:10]
[TRACE   1 t1.lua:3 loop]
</code></pre></div></div>
<p><strong><em><a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L579">Self-link is blacklisted</a>的情况怎么理解</em></strong></p>

<p>trace abort中还有两种特殊的的情况分别是：当引起trace abort的错误是LJ_TRERR_DOWNREC的话，就会尝试调用<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L535">trace_downrec</a>函数针对down-recursion的情况来生成新的roottrace（过程和生成普通的roottrace一样）；如果TraceError是LJ_TRERR_MCODELM，也会进行重试，不同的是，这种情况是从LJ_TRACE_ASM状态开始重试。</p>

<p>导致trace abort的原因很多（具体可以参考<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_traceerr.h">lj_traceerr.h</a>），这里主要介绍一些常见的类型以及避免办法：</p>
<ul>
  <li><strong>NYI</strong>，这个应该是最常见的trace abort了，NYI也有很多具体很多，具体可以参考<a href="http://wiki.luajit.org/NYI">官方的wiki</a>。由于vlog提供的NYI都是id，不熟悉的话，可以使用<a href="http://www.freelists.org/post/luajit/frames-and-tail-calls,1">bc.lua</a>找出对应的BC，然后再去官方<a href="http://wiki.luajit.org/Bytecode-2.0">Bytecode-2.0</a>中对照查看。</li>
  <li><strong>leaving loop in root trace</strong>，往往出现在生成循环类roottrace的时候。虽然循环的hotcount的阈值是56，但是由于额外的<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L2031">记录闭合循环的</a>规则，所以循环次数为56的时候无法成功生成trace；而对于57，虽然满足了记录闭合循环的规则，但是由于for循环对应的trace，其主要工作就是模拟FOR循环迭代器的运行时行为（可以认为循环类的trace，是在<code class="highlighter-rouge">i == 57</code>的时候生成的，注意和递归的情况的区别），而到达57以后，循环就结束了，模拟也就没有意义，所以这里也无法成功生成trace，具体细节见循环中BC FORL的相关处理函数<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L360">rec_for_iter</a>。这里要注意区分，与前面提到的递归类trace中的link return的行为的不同。</li>
  <li><strong><em>inner loop in root trace，不是很理解。</em></strong></li>
  <li><strong>loop unroll limit reached</strong>，在tracing的过程（包括用于生成sidetrace的tracing）中，如果遇到了未生成trace的循环或者递归（包括尾递归，如果不希望尾递归，可以使用括号包装返回值来避免，如，<code class="highlighter-rouge">return funccall()</code>改为<code class="highlighter-rouge">return (funccall())</code>），就会尝试把循环或者递归展开来记录，如果展开的次数超过了<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_jit.h#L112">阈值15</a>（减去初始的1次和&lt;的要求，实际值是17），就会产生此trace abort。比较特殊的地方是，导致的该trace abort的循环或者递归，可能在后面生成其它的trace。</li>
  <li><strong>call unroll limit reached</strong>，前面提到，在触发tracing的时候，对于非递归的函数调用，会对其做展开限制检查，如果调用帧的深度（在BC CALL对应的处理函数lj_record_call里递增）超过了<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_jit.h#L113">阈值3</a>，就会产生LJ_TRERR_CUNROLL的trace abort，而无法成功生成trace。</li>
  <li><strong><em>down-recursion, restarting，不是很理解。</em></strong></li>
  <li><strong><em>NYI: return to lower frame，不是很理解。</em></strong></li>
  <li><strong>blacklisted</strong>，tracing中遇到了被列入黑名单的BC而产生的trace abort。要注意的是，被列入黑名单的BC虽然是在纯解释执行，性能会比普通的解释执行要好，但是由它带来的trace abort还是会使得生成trace失败的。</li>
</ul>

<p>不过不用担心，作者说过，trace abort是很常见的，只要不是因为特定的trace abort占用过多的CPU，其实是不用去过分优化的，而且LuaJIT的解释模式也是很快的：</p>
<blockquote>
  <p>Don’t worry – trace aborts are quite common, even in programs which can be fully compiled. The compiler may retry several times until it finds a suitable trace.</p>
</blockquote>

<blockquote>
  <p>Of course this doesn’t work with features that are not-yet-implemented (NYI error messages). The VM simply falls back to the interpreter. This may not matter at all if the particular trace is not very high up in the CPU usage profile. Oh, and the interpreter is quite fast, too.</p>
</blockquote>

<h2 id="c-sidetrace"><strong>c. sidetrace</strong></h2>

<p>前面提到的守卫失败，trace退出的时候，在<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L830">lj_trace_exit</a>函数里，除了从快照恢复VM的状态以外，还会触发<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L877">trace_hotside</a>检测对应的<strong>side exit</strong>（守卫失败对应的出口）是否达到hot side exit的条件（当前side exit对应的快照里，对于该side exit的计数是否超过<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_jit.h#L108">阈值</a>），以开始新的tracing生成<strong>sidetrace</strong>。</p>

<p>tracing生成sidetrace的过程和生成roottrace的过程基本上是一样的，只是tracing开始的<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L2534">记录设置</a>里，会把该side trace对应的快照里的内容用于<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_snap.c#L456">初始化</a>（<a href="http://wiki.luajit.org/Allocation-Sinking-Optimization#implementation_snapshot-handling_snapshot-replay">Snapshot Replay</a>）这个side trace的IR。</p>

<p>可以认为生成sidetrace的trace，是该sidetrace的父trace，他们在运行的过程中是连接在一起的，也就是说，运行生成过sidetrace的父trace的过程中守卫失败时，守卫对应的出口不会再退出到解释模式，而且连接到此出口对应的sidetrace上：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.dump").on("six", "t1.dlog")--require("jit.v").on("t1.log")--
---
for i = 1, 12 do
    for i = 1, 58 do end
end
</code></pre></div></div>
<p>对应的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:4
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #5    CI
0002  + int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- ---- ---- ---- ]
<span class="p">0003 &gt;  int LE     0002  +58 
</span><span class="err">....</span>        SNAP   #2   [ ---- ---- ---- ---- ---- 0002 ---- ---- 0002 ]
<span class="p">0004 ------ LOOP ------------
0005  + int ADD    0002  +1  
</span><span class="err">....</span>        SNAP   #3   [ ---- ---- ---- ---- ---- ]
<span class="p">0006 &gt;  int LE     0005  +58 
0007    int PHI    0002  0005
</span><span class="gd">---- TRACE 1 stop -&gt; loop
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 2 start 1/3 t1.lua:3
---- TRACE 2 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ---- ---- ---- ---- ]
<span class="p">0001    num SLOAD  #1    I
0002    num ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ]
<span class="p">0003 &gt;  num LE     0002  +12 
</span><span class="err">....</span>        SNAP   #2   [ ---- 0002 ---- ---- 0002 +1   +58  +1   +1   ]
<span class="gd">---- TRACE 2 stop -&gt; 1
</span>
---- TRACE 2 exit 1
</code></pre></div></div>
<p>观察dumplog可以知道，在trace1在exit3退出超过hot side exit的阈值，而触发tracing（<code class="highlighter-rouge">i == 10</code>），并且成功生成sidetrace trace2了以后（<code class="highlighter-rouge">i == 11</code>），后续trace1在守卫<code class="highlighter-rouge">0006 &gt;  int LE     0005  +58</code>失败，通过出口exit3就不再是退回到解释模式，而是连接到sidetrace trace2了（<code class="highlighter-rouge">i == 12</code>）。</p>

<p>还有一点就是，对于在生成sidetrace的tracing的记录过程中，遇到非父trace的循环和递归，分别对应BC <a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L2396">JFORL</a>（或者BC <a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L2379">JFORI</a>，一般是嵌套循环的情况）和BC <a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L2424">JFUNCF</a>的处理逻辑来结束记录，并且设置连接到该trace（<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L603"><strong><em>extra loop</em></strong></a><strong><em>和</em></strong><a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L1739"><strong><em>extra tail-recursion</em></strong></a><strong><em>的情况是怎么出现的</em></strong>）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")--require("jit.dump").on("six", "t1.dlog")--
---
for i = 1, 12 do
    for i = 1, 58 do end
    for i = 1, 58 do end
end
</code></pre></div></div>
<p>对应的vlog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE   1 t1.lua:4 loop]
[TRACE   2 t1.lua:5 loop]
[TRACE   3 (1/3) t1.lua:5 -&gt; 2]
[TRACE   4 (2/3) t1.lua:3 -&gt; 1]
</code></pre></div></div>
<p>跟roottrace的link self的行为类似，一旦生成连接到roottrace的sidetrace，后续逻辑如果遇到该代码路径，就会直接运行这这些连接在一起的roottrace和sidetrace，中间是不会有trace退出（到解释模式）的行为出现的（当然是运行这些trace的时候，没有新的守卫失败的情况）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.dump").on("six", "t1.dlog")--require("jit.v").on("t1.log")--
---
local function f()
    for _ = 1, 12 do
        for _ = 1, 58 do end
    end
end

f()
f()
f()
f()
f()
</code></pre></div></div>
<p>对应的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:5
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #5    CI
0002  + int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- ---- ---- ---- ]
<span class="p">0003 &gt;  int LE     0002  +58 
</span><span class="err">....</span>        SNAP   #2   [ ---- ---- ---- ---- ---- 0002 ---- ---- 0002 ]
<span class="p">0004 ------ LOOP ------------
0005  + int ADD    0002  +1  
</span><span class="err">....</span>        SNAP   #3   [ ---- ---- ---- ---- ---- ]
<span class="p">0006 &gt;  int LE     0005  +58 
0007    int PHI    0002  0005
</span><span class="gd">---- TRACE 1 stop -&gt; loop
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 2 start 1/3 t1.lua:4
---- TRACE 2 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ---- ---- ---- ---- ]
<span class="p">0001    num SLOAD  #1    I
0002    num ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ]
<span class="p">0003 &gt;  num LE     0002  +12 
</span><span class="err">....</span>        SNAP   #2   [ ---- 0002 ---- ---- 0002 +1   +58  +1   +1   ]
<span class="gd">---- TRACE 2 stop -&gt; 1
</span>
---- TRACE 2 exit 1
<span class="gd">---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
</span></code></pre></div></div>
<p>观察上面的dumplog可以知道，trace1在退出达到hot side exit的阈值生成sidetrace trace2了以后，后续调用f（包括第一个f调用里的<code class="highlighter-rouge">i == 12</code>的情况下），就都只有sidetrace trace2的退出了，也就是说，后续对f（包括第一个f调用里的<code class="highlighter-rouge">i == 12</code>的情况下）的调用中，trace1运行完毕（此时trace1没有退出）是直接运行sidetrace trace2，然后才退出到解释模式的。</p>

<p>当然，sidetrace也有link return的情况：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.dump").on("six", "t1.dlog")--require("jit.v").on("t1.log")--
---
local function f()
    for _ = 1, 11 do
        for _ = 1, 58 do end
    end
end

f()
</code></pre></div></div>
<p>对应的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:5
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #5    CI
0002  + int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- ---- ---- ---- ]
<span class="p">0003 &gt;  int LE     0002  +58 
</span><span class="err">....</span>        SNAP   #2   [ ---- ---- ---- ---- ---- 0002 ---- ---- 0002 ]
<span class="p">0004 ------ LOOP ------------
0005  + int ADD    0002  +1  
</span><span class="err">....</span>        SNAP   #3   [ ---- ---- ---- ---- ---- ]
<span class="p">0006 &gt;  int LE     0005  +58 
0007    int PHI    0002  0005
</span><span class="gd">---- TRACE 1 stop -&gt; loop
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 2 start 1/3 t1.lua:4
---- TRACE 2 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ---- ---- ---- ---- ]
<span class="p">0001    num SLOAD  #1    I
0002    num ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- 0002 ---- ---- 0002 ]
<span class="p">0003 &gt;  num GT     0002  +11 
</span><span class="err">....</span>        SNAP   #2   [ ---- ]
<span class="p">0004 &gt;  p32 RETF   proto: 0x3fdf82a8  [0x3fdf8314]
</span><span class="err">....</span>        SNAP   #3   [ ---- ]
<span class="gd">---- TRACE 2 stop -&gt; return
</span></code></pre></div></div>
<p>观察上面的dumplog可以知道，这里也只是生成了sidetrace trace2，并没有sidetrace trace2的运行。</p>

<p>sidetrace在运行的时候，也会有守卫失败，sidetrace退出的情况，所以sidetrace的退出达到阈值后，也是会有新sidetrace生成的：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.dump").on("six", "t1.dlog")--require("jit.v").on("t1.log")--
---
for i = 1, 58 + 10 + 10 do
    if i == 57 then
    else
        if i == 67 then end
    end
end
</code></pre></div></div>
<p>对应的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:3
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #1    CI
</span><span class="err">....</span>        SNAP   #1   [ ---- 0001 ---- ---- 0001 ]
<span class="p">0002 &gt;  int EQ     0001  +57 
0003  + int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #2   [ ---- ]
<span class="p">0004 &gt;  int LE     0003  +78 
</span><span class="err">....</span>        SNAP   #3   [ ---- 0003 ---- ---- 0003 ]
<span class="p">0005 ------ LOOP ------------
</span><span class="err">....</span>        SNAP   #4   [ ---- 0003 ---- ---- 0003 ]
<span class="p">0006 &gt;  int EQ     0003  +57 
0007  + int ADD    0003  +1  
</span><span class="err">....</span>        SNAP   #5   [ ---- ]
<span class="p">0008 &gt;  int LE     0007  +78 
0009    int PHI    0003  0007
</span><span class="gd">---- TRACE 1 stop -&gt; loop
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 2 start 1/1 t1.lua:6
---- TRACE 2 IR
</span><span class="p">0001    int SLOAD  #1    PI
</span><span class="err">....</span>        SNAP   #0   [ ---- 0001 ---- ---- 0001 ]
<span class="err">....</span>        SNAP   #1   [ ---- 0001 ---- ---- ---- ]
<span class="p">0003 &gt;  int EQ     0001  +67 
0004    int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #2   [ ---- ]
<span class="p">0005 &gt;  int LE     0004  +78 
0006    num CONV   0004  num.int
</span><span class="err">....</span>        SNAP   #3   [ ---- 0006 ---- ---- 0006 ]
<span class="gd">---- TRACE 2 stop -&gt; 1
</span>
---- TRACE 2 exit 1
<span class="gd">---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 3 start 2/1 t1.lua:3
---- TRACE 3 IR
</span><span class="p">0001    int SLOAD  #1    PI
</span><span class="err">....</span>        SNAP   #0   [ ---- 0001 ---- ---- ---- ]
<span class="p">0002    int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ]
<span class="p">0003 &gt;  int LE     0002  +78 
0004    num CONV   0002  num.int
</span><span class="err">....</span>        SNAP   #2   [ ---- 0004 ---- ---- 0004 ]
<span class="gd">---- TRACE 3 stop -&gt; 1
</span>
---- TRACE 3 exit 1
</code></pre></div></div>
<p>观察上面的dumplog可以知道，trace3是trace2的快照1对应的守卫<code class="highlighter-rouge">0003 &gt;  int EQ     0001  +67</code> （<code class="highlighter-rouge">i == 67</code>）失败达到阈值后产生的，不过可以看到，由于trace2和trace3生成的先后关系的缘故，所以trace2和trace3都是link到trace1（roottrace）的。</p>

<p>根据前面提到的，link return的sidetrace运行结束会退出到解释模式，然后sidetrace在退出达到阈值后会生成新的sidetrace，所以跟（递归类）trace的行为一样，link return的sidetrace也是会产生sidetrace的：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.dump").on("six", "t1.dlog")--require("jit.v").on("t1.log")--
---
local function f()
    for _ = 1, 12 do -- 12 link trace1 / 11 link return
        for _ = 1, 58 do end
    end
end

f()
f()
</code></pre></div></div>
<p>对应的link trace1的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:5
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #5    CI
0002  + int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- ---- ---- ---- ]
<span class="p">0003 &gt;  int LE     0002  +58 
</span><span class="err">....</span>        SNAP   #2   [ ---- ---- ---- ---- ---- 0002 ---- ---- 0002 ]
<span class="p">0004 ------ LOOP ------------
0005  + int ADD    0002  +1  
</span><span class="err">....</span>        SNAP   #3   [ ---- ---- ---- ---- ---- ]
<span class="p">0006 &gt;  int LE     0005  +58 
0007    int PHI    0002  0005
</span><span class="gd">---- TRACE 1 stop -&gt; loop
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 2 start 1/3 t1.lua:4
---- TRACE 2 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ---- ---- ---- ---- ]
<span class="p">0001    num SLOAD  #1    I
0002    num ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ]
<span class="p">0003 &gt;  num LE     0002  +12 
</span><span class="err">....</span>        SNAP   #2   [ ---- 0002 ---- ---- 0002 +1   +58  +1   +1   ]
<span class="gd">---- TRACE 2 stop -&gt; 1
</span>
---- TRACE 2 exit 1
<span class="gd">---- TRACE 2 exit 1
</span></code></pre></div></div>
<p>对应的link return的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:5
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #5    CI
0002  + int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- ---- ---- ---- ]
<span class="p">0003 &gt;  int LE     0002  +58 
</span><span class="err">....</span>        SNAP   #2   [ ---- ---- ---- ---- ---- 0002 ---- ---- 0002 ]
<span class="p">0004 ------ LOOP ------------
0005  + int ADD    0002  +1  
</span><span class="err">....</span>        SNAP   #3   [ ---- ---- ---- ---- ---- ]
<span class="p">0006 &gt;  int LE     0005  +58 
0007    int PHI    0002  0005
</span><span class="gd">---- TRACE 1 stop -&gt; loop
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 1 exit 3
---- TRACE 2 start 1/3 t1.lua:4
---- TRACE 2 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ---- ---- ---- ---- ]
<span class="p">0001    num SLOAD  #1    I
0002    num ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- 0002 ---- ---- 0002 ]
<span class="p">0003 &gt;  num GT     0002  +11 
</span><span class="err">....</span>        SNAP   #2   [ ---- ]
<span class="p">0004 &gt;  p32 RETF   proto: 0x2e668140  [0x2e6681ac]
</span><span class="err">....</span>        SNAP   #3   [ ---- ---- ]
<span class="p">0005 &gt;  fun SLOAD  #1    T
0006 &gt;  fun EQ     0005  t1.lua:3
</span><span class="err">....</span>        SNAP   #4   [ ---- ---- t1.lua:3|+1   +11  +1   +1   +1   +58  +1   +1   ]
<span class="gd">---- TRACE 2 stop -&gt; 1
</span>
---- TRACE 2 exit 1
<span class="gd">---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 3 start 2/1 t1.lua:5
---- TRACE 3 IR
</span><span class="p">0001    num SLOAD  #1    PI
</span><span class="err">....</span>        SNAP   #0   [ ---- 0001 ---- ---- 0001 ]
<span class="err">....</span>        SNAP   #1   [ ---- 0001 ---- ---- 0001 +1   +58  +1   +1   ]
<span class="gd">---- TRACE 3 stop -&gt; 1
</span>
---- TRACE 2 exit 2
</code></pre></div></div>
<p>对比上面2个dumplog可以发现，由于外层循环12的时候，生成了link trace1的sidetrace trace2，所以在第二次调用f的时候，在循环里，trace1和trace2运行结束后是直接连接到下一次循环里的trace1和trace2的，所以在trace2生成以后直到结束，就只有2次（对应2次f调用的）trace2的退出了；而外层循环11的时候，生成的却是link return的sidetrace trace2（<strong><em>dumplog中虽然是连link trace1的，但是测试和调试trace2的行为却是link return的，不大理解</em></strong>），所以在第二次调用f的时候，在循环里，trace1和trace2运行结束后是从trace2的exit1退出到解释模式，如此反复，直到在循环的第10里，exit1的退出达到hot side exit的阈值10，从而触发了在循环的第11次里tracing，并成功生成了新的sidetrace trace3（<strong><em>这里的trace3在生成后，就算再次调用f或者把第二次的f循环次数加大，也都不会被运行到，测试和调试发现trace2的行为，在生成trace3之后变成了真正的link trace1，所以推测是在生成trace3的时候同时也改变了trace2的link行为，但是看源代码并没找到</em></strong>）。</p>

<p>特别地，在tracing生成sidetrace的过程中，如果trace abort而退出tracing的次数超过<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_jit.h#L109">阈值</a>，就会在下次触发tracing的时候，记录之前就<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_record.c#L2596">直接结束tracing</a>，并且生成一个连接到“fallback to interpreter”的sidetrace（注意和上面连接到return的sidetrace的区别）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log") -- require("jit.dump").on("six", "t1.dlog")
---
local a
for i = 1, 94 do
    if i &gt;= 80 then
        a = function() end
    else
        a = 67
    end
end
</code></pre></div></div>
<p>对应的vlog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE   1 t1.lua:4 loop]
[TRACE --- (1/1) t1.lua:6 -- NYI: bytecode 51]
[TRACE --- (1/1) t1.lua:6 -- NYI: bytecode 51]
[TRACE --- (1/1) t1.lua:6 -- NYI: bytecode 51]
[TRACE --- (1/1) t1.lua:6 -- NYI: bytecode 51]
[TRACE   2 (1/1) t1.lua:6 -- fallback to interpreter]
</code></pre></div></div>
<p>对应的dumplog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:4
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #2    CI
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- 0001 ---- ---- 0001 ]
<span class="p">0002 &gt;  int LT     0001  +80 
0003  + int ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #2   [ ---- +67  ]
<span class="p">0004 &gt;  int LE     0003  +94 
</span><span class="err">....</span>        SNAP   #3   [ ---- +67  0003 ---- ---- 0003 ]
<span class="p">0005 ------ LOOP ------------
</span><span class="err">....</span>        SNAP   #4   [ ---- +67  0003 ---- ---- 0003 ]
<span class="p">0006 &gt;  int LT     0003  +80 
0007  + int ADD    0003  +1  
</span><span class="err">....</span>        SNAP   #5   [ ---- +67  ]
<span class="p">0008 &gt;  int LE     0007  +94 
0009    int PHI    0003  0007
</span><span class="gd">---- TRACE 1 stop -&gt; loop
</span>
---- TRACE 1 exit 4
<span class="gd">---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 1 exit 1
---- TRACE 2 start 1/1 t1.lua:6
---- TRACE 2 abort t1.lua:6 -- NYI: bytecode 51
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 2 start 1/1 t1.lua:6
---- TRACE 2 abort t1.lua:6 -- NYI: bytecode 51
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 2 start 1/1 t1.lua:6
---- TRACE 2 abort t1.lua:6 -- NYI: bytecode 51
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 2 start 1/1 t1.lua:6
---- TRACE 2 abort t1.lua:6 -- NYI: bytecode 51
</span>
---- TRACE 1 exit 1
<span class="gd">---- TRACE 2 start 1/1 t1.lua:6
---- TRACE 2 IR
</span><span class="p">0001    int SLOAD  #2    PI
</span><span class="err">....</span>        SNAP   #0   [ ---- ---- 0001 ---- ---- 0001 ]
<span class="p">0002    num CONV   0001  num.int
</span><span class="err">....</span>        SNAP   #1   [ ---- ---- 0002 ---- ---- 0002 ]
<span class="gd">---- TRACE 2 stop -&gt; interpreter
</span></code></pre></div></div>
<p>观察dump.log可以知道，在快照1对应的守卫<code class="highlighter-rouge">0002 &gt;  int LT     0001  +80</code>（<code class="highlighter-rouge">i &lt; 80</code>）失败而退出到解释模式<code class="highlighter-rouge">---- TRACE 1 exit 110</code>次以后，（第11次，<code class="highlighter-rouge">i == 90</code>）达到的hot side exit的阈值，从而触发了sidetrace的tracing（<code class="highlighter-rouge">---- TRACE 2 start 1/1 t1.lua:6</code>），但是由于tracing过程中的<code class="highlighter-rouge">---- TRACE 2 abort t1.lua:6 -- NYI: bytecode 51</code>带来的trace abort而退出到解释模式4次以后，达到了阈值，下次（第5次，<code class="highlighter-rouge">i == 94</code>）再次触发此side exit的时候，就直接生成了一个连接到“fallback to interpreter”的sidetrace（<code class="highlighter-rouge">---- TRACE 2 stop -&gt; interpreter</code>）。</p>

<p>这样看来，sidetrace的理想状态是trace间的承上启下，所以这里可以大概描述出trace间的工作流：<img src="https://github.com/tweyseo/gallery/blob/master/LuaJIT/trace-glance.png" alt="img2" /></p>

<h2 id="d-stitch"><strong>d. stitch</strong></h2>

<p>trace stitch是LuaJIT 2.1新增的功能，它允许在tracing的记录过程遇到某个Lua CFunction或者NYI的内置函数的时候（FUNCC和FUNCCW），通过<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_ffrecord.c#L99">recff_stitch</a>函数完成<a href="https://github.com/LuaJIT/LuaJIT/issues/13#issuecomment-132711024">在栈上存储此函数的相关信息</a>（为了通俗的理解，把这个函数叫做待缝合函数）的操作后，停止记录和tracing，成功生成<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_ffrecord.c#L133">连接到stitch</a>的trace；然后待缝合的函数执行次数达到一定阈值后，会通过<a href="https://github.com/LuaJIT/LuaJIT/blob/v2.1.0-beta3/src/lj_trace.c#L760">lj_dispatch_stitch</a>触发tracing生成一个新的trace，连接到前一个trace（或者return）：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")--require("jit.dump").on("six", "t1.dlog")--
---
for _ = 1, 59 do 
    local a = unpack({})
end
</code></pre></div></div>
<p>对应的v.log：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE   1 t1.lua:3 stitch unpack]
[TRACE   2 (1/stitch) t1.lua:4 -&gt; 1]
</code></pre></div></div>
<p>值得注意的地方是，这里看v.log是生成了2个trace，但是实际上这2个trace是缝合在一起的，所以只会有一个trace运行和退出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:3
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #1    CI
0002    fun SLOAD  #0    R
0003    tab FLOAD  0002  func.env
0004    int FLOAD  0003  tab.hmask
0005 &gt;  int EQ     0004  +63 
0006    p32 FLOAD  0003  tab.node
0007 &gt;  p32 HREFK  0006  "unpack" @46
0008 &gt;  fun HLOAD  0007
0009 &gt;  tab TNEW   #0    #0  
0010 &gt;  fun EQ     0008  unpack
0011    num CONV   0001  num.int
</span><span class="err">....</span>        SNAP   #1   [ ---- 0011 ---- ---- 0011 trace: 0x2bb01428 [0x00003226] unpack|0009 ]
<span class="gd">---- TRACE 1 stop -&gt; stitch
</span>
---- TRACE 2 start 1/stitch t1.lua:4
<span class="gd">---- TRACE 2 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    num SLOAD  #1    I
0002    num ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ]
<span class="p">0003 &gt;  num LE     0002  +59 
</span><span class="err">....</span>        SNAP   #2   [ ---- 0002 ---- ---- 0002 ]
<span class="gd">---- TRACE 2 stop -&gt; 1
</span>
---- TRACE 2 exit 1
</code></pre></div></div>
<p>这里再来看个非常特殊例子：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")--require("jit.dump").on("six", "t1.dlog")--
---
local function f1()
    for i = 1, 58 do 
        local a = unpack({})
    end
end

f1()
f1()
</code></pre></div></div>
<p>其对应的dump.log：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">---- TRACE 1 start t1.lua:4
---- TRACE 1 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    int SLOAD  #1    CI
0002    fun SLOAD  #0    R
0003    tab FLOAD  0002  func.env
0004    int FLOAD  0003  tab.hmask
0005 &gt;  int EQ     0004  +63 
0006    p32 FLOAD  0003  tab.node
0007 &gt;  p32 HREFK  0006  "unpack" @46
0008 &gt;  fun HLOAD  0007
0009 &gt;  tab TNEW   #0    #0  
0010 &gt;  fun EQ     0008  unpack
0011    num CONV   0001  num.int
</span><span class="err">....</span>        SNAP   #1   [ ---- 0011 ---- ---- 0011 trace: 0x239d14e8 [0x00003226] unpack|0009 ]
<span class="gd">---- TRACE 1 stop -&gt; stitch
</span>
---- TRACE 2 start 1/stitch t1.lua:5
<span class="gd">---- TRACE 2 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    num SLOAD  #1    I
0002    num ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- 0002 ---- ---- 0002 ]
<span class="p">0003 &gt;  num GT     0002  +58 
</span><span class="err">....</span>        SNAP   #2   [ ---- ]
<span class="p">0004 &gt;  p32 RETF   proto: 0x239b8140  [0x239b81ac]
</span><span class="err">....</span>        SNAP   #3   [ ---- ---- ]
<span class="p">0005 &gt;  fun SLOAD  #1    T
0006 &gt;  fun EQ     0005  t1.lua:3
</span><span class="err">....</span>        SNAP   #4   [ ---- ---- t1.lua:3|+1   +58  +1   +1   ]
<span class="gd">---- TRACE 2 stop -&gt; 1
</span>
---- TRACE 2 exit 1
<span class="gd">---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 2 exit 1
---- TRACE 3 start 2/1 t1.lua:5
---- TRACE 3 IR
</span><span class="p">0001    num SLOAD  #1    PI
</span><span class="err">....</span>        SNAP   #0   [ ---- 0001 ---- ---- 0001 ]
<span class="p">0002    fun SLOAD  #0    R
0003    tab FLOAD  0002  func.env
0004    int FLOAD  0003  tab.hmask
0005 &gt;  int EQ     0004  +63 
0006    p32 FLOAD  0003  tab.node
0007 &gt;  p32 HREFK  0006  "unpack" @46
0008 &gt;  fun HLOAD  0007
0009 &gt;  tab TNEW   #0    #0  
0010 &gt;  fun EQ     0008  unpack
</span><span class="err">....</span>        SNAP   #1   [ ---- 0001 ---- ---- 0001 trace: 0x239d30c0 [0x00003226] unpack|0009 ]
<span class="gd">---- TRACE 3 stop -&gt; stitch
</span>
---- TRACE 4 start 3/stitch t1.lua:5
<span class="gd">---- TRACE 4 IR
</span><span class="err">....</span>        SNAP   #0   [ ---- ]
<span class="p">0001    num SLOAD  #1    I
0002    num ADD    0001  +1  
</span><span class="err">....</span>        SNAP   #1   [ ---- ]
<span class="p">0003 &gt;  num LE     0002  +58 
</span><span class="err">....</span>        SNAP   #2   [ ---- 0002 ---- ---- 0002 ]
<span class="gd">---- TRACE 4 stop -&gt; 1
</span>
---- TRACE 4 exit 1
</code></pre></div></div>
<p>注意到这里的dump.log中的trace 2有10次退出，从而生成了一个sidetrace。跟前面link return的sidetrace生成新的sidetrace的行为一样，是因为，在把循环的59改为58的时候第一次调用f1生成的stitchtrace实际是连接到return的。所以在第二次调用f1的循环中，link return的stitchtrace退出达到一定阈值而生成了连接到该stitchtrace的sidetrace。比较特殊地方是，这个sidetrace是有缝合行为的（缝合到stitchtrace trace4），vlog很好的体现了这点：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE   1 t1.lua:4 stitch unpack]
[TRACE   2 (1/stitch) t1.lua:5 -&gt; 1]
[TRACE   3 (2/1) t1.lua:5 stitch unpack]
[TRACE   4 (3/stitch) t1.lua:5 -&gt; 1]
</code></pre></div></div>
<p>在使用stitch的特性的时候，也有需要注意的地方，看下面的例子：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require("jit.v").on("t1.log")--require("jit.dump").on("six", "t1.dlog")--
---
for _ = 1, 59 do 
    local a = unpack({...})
end
</code></pre></div></div>
<p>对应的vlog：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[TRACE --- t1.lua:3 -- NYI: bytecode 71 at t1.lua:4]
</code></pre></div></div>
<p>这里是由于，在tracing生成连接到stitch的trace的过程中，遇到了<a href="http://wiki.luajit.org/NYI">VARG的NYI</a>而产生trace abort，使得tracing结束，生成trace失败。这一点说明了，tracing stitchtrace的时候，是有记录待缝合函数和其参数的。当然这个VARG的NYI在生成普通trace的tracing中也会产生trace abort。</p>

<p>这里也给出stitch的workflow：<img src="https://github.com/tweyseo/gallery/blob/master/LuaJIT/stitchtrace-workflow.png" alt="img3" /></p>

<h1 id="3-总结"><strong>3. 总结</strong></h1>

<p>之前在通过<a href="https://github.com/moonbingbing/openresty-best-practices/blob/master/SUMMARY.md">最佳实践</a>学习OpenResty的时候，接触到了LuaJIT，<a href="https://github.com/moonbingbing/openresty-best-practices/blob/master/lua/what_jit.md">相关章节的例子</a>中，一个小小的“魔法”操作，使得效率提示了几十倍，这个时候，我就已经对LuaJIT非常感兴趣了，无奈网上资料太少，LuaJIT的源码也相对比较晦涩（也许是我缺乏编译器，特别是JIT类编译器的相关知识的缘故），所以当时就放弃了。</p>

<p>后来在沉淀自己线上项目的<a href="https://github.com/tweyseo/Mirana">框架</a>的时候，就想说顺便遵循LuaJIT的特性来优化下自己的框架，于是参照<a href="http://wiki.luajit.org/Numerical-Computing-Performance-Guide">Performance-Guide</a>的规则，开始着手优化自己的框架。虽然Performance-Guide里给出了不少有效的参考性意见，可是由于太多概念性的东西不是很理解，使得优化的过程比较的痛苦，于是只好又重新借助LuaJIT的源码以及LuaJIT的邮件讨论组，重新再来学习和研究
LuaJIT，这样才有了这个文章。</p>

<p>大家如果有关注最新版的<a href="https://openresty.org/cn/changelog-1015008.html">OpenResty</a>就会发现，LuaJIT已经是OpenResty的必选项了，并且同样变为必选项的<a href="https://github.com/openresty/lua-resty-core">resty.core</a>，也是为了淘汰掉OpenResty现有的一套Lua CFunction接口，而通过更为高效和友好的LuaJIT的FFI实现的，所以LuaJIT离我们并不远，就在我们OpenRestyer的眼前。</p>

<p>这个文章涉及的只是LuaJIT的基础部分的知识点，还有很多其他的高级内容（比如强大的<a href="http://luajit.org/ext_ffi_tutorial.html">FFI</a>）没涉及到，有空了我也会研究并且整理出相关的文章，分享出来供大家参考学习讨论。</p>

<p>最后，希望这个文章在帮助大家学习了解LuaJIT的同时，大家也能帮忙一起来完善LuaJIT的相关知识，也算是为OR社区做出一点小小的贡献。</p>

<h1 id="todo"><strong>TODO</strong></h1>

<p>文章里的内容都是我个人研究LuaJIT的<a href="https://github.com/LuaJIT/LuaJIT/tree/v2.1.0-beta3">源码</a>和LuaJIT的<a href="https://www.freelists.org/archive/luajit/">邮件讨论组</a>里讨论总结出来的，难免有一些不是很准确，甚至错误的地方，希望大家在读这个文章的时候能帮忙指出问题，我会参与讨论并及时修正的。</p>

<p>另外，文章中有部分<strong><em>斜粗体</em></strong>，是目前为止，我尚未研究透的，也希望大家有思路的话能给我指导，我会参与讨论并及时补充的。</p>

-->
      
  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://0.0.0.0:8081/page30/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://0.0.0.0:8081/">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://0.0.0.0:8081/page29/">29</a></li>
      
    
      
        
        
        
        <li><a href="http://0.0.0.0:8081/page30/">30</a></li>
      
    
      
        <li><strong class="current-page">31</strong></li>
      
    
      
        
        
        
        <li><a href="http://0.0.0.0:8081/page32/">32</a></li>
      
    
      
        
        
        
        <li><a href="http://0.0.0.0:8081/page33/">33</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://0.0.0.0:8081/page1611/">1611</a></li>
    

    
    
      <li><a href="http://0.0.0.0:8081/page32/" class="btn">Next</a></li>
    
  </ul>
</div>





</div><!-- /#main -->




<script type="text/javascript" src="/assets/js/vendor/jquery-1.9.1.min.js"></script>
<script type="text/javascript" src="http://0.0.0.0:8081/assets/js/plugins/jekyll-search.js"></script>
<!--
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="/assets/js/vendor/jquery-1.9.1.min.js"></script>
<script type="text/javascript">window.jQuery || document.write('<script type="text/javascript" src="http://0.0.0.0:8081/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script type="text/javascript" async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<script type="text/javascript" src="http://0.0.0.0:8081/assets/js/scripts.min.js"></script>
-->




<!--
<script type="text/javascript">!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
-->



<!-- Asynchronous Google Analytics snippet -->

<script>
var _hmt = _hmt || [];
(function() {
   var hm = document.createElement("script");
     hm.src = "//hm.baidu.com/hm.js?14cc93bf3f08d31c458639d309dde522";
       var s = document.getElementsByTagName("script")[0]; 
         s.parentNode.insertBefore(hm, s);
         })();
</script>








<script type="text/javascript">
    sharing();
</script>

<script type="text/javascript" >
    $(document).ready(function () {
        $(".term").on("click", function (event) {
            var searchInput = $("#search-input");
            searchInput.val($(this).text());
            searchInput.trigger("change keyup");
            searchInput.keyup();
            searchInput.change();
        })
    })
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>




<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '18349-1575875948454-349',
        name: '糖果的实验室',
        qrcode: '/images/media/wechat_subscription.png',
        keyword: 'lua',
    });
</script>






<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2020 糖果 </span>
<span>ICP证:<a href="http://www.beian.miit.gov.cn/">辽ICP备16003836号-2</a> </span>

  </footer>
</div><!-- /.footer-wrapper -->

</body>
</html>
